<!DOCTYPE html>
<html id="top">
<!--
  CodeBites_AgentAI.html
-->
<head>
  <title>Using Agents</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="../images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeCode.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="../js/SitePagesForTools.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <script src="../WebDev/Components/CodeViewerComponent/js/CodeViewer.js" defer></script>
  <link rel="stylesheet" href="../WebDev/Components/CodeViewerComponent/css/CodeViewer.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreCode.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .ai-pros-cons {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .ai-refactoring {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .ai-unit-tests {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .ai-security {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .ai-documentation {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .rust-naming {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .cpp-naming {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .csharp-naming {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    .python-naming {
      border: 1px solid rgba(5,2,3,0.7);
      padding:0.25rem 1.5rem;
      width: max-content;
    }
    details div h3 {
      margin:0.25rem 0rem;
    }
    details div ol {
      padding:0.5rem 0rem;
      margin: 0rem;
    }
    details div ul {
      padding:0.5rem 0rem;
      margin: 0rem;
    }
    details div li {
      padding:0.05rem 0.0rem;
      margin:0rem;
    }
  </style>
  <style>
    #md_content {
      font-size: 16px; /* Base size for all content */
    }
    
    #md_content h1 { font-size: 2em; }
    #md_content h2 { font-size: 1.5em; }
    #md_content code { font-size: 0.9em; }
    #md_content pre { font-size: 0.85em; }
    #md_content ol { margin-left: 2rem; }
    #md_content ul { margin-left: 2rem; }
  </style>
</head>
<body id="github" onload="load()">

  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    CodeBites_AgentAI.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 01/01/2026
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">CodeBites: Using AI Agents</h2>
        <h4 id="subtitle" class="indent">
          access and modify local code<br />
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0rem 0rem 0.25rem 0rem; margin-top:0.125rem; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25rem; margin-left:1.5rem;">About</a>
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett/NewSite/tree/main/Code" style="margin-left: 1rem; color:var(--atten); ">Code Repo</a>
      </div>

    </header>
    <div style="height:1rem;"></div>
    <h3 id="intro">1.0 - Introduction</h3>
    <tm-b>
      Agents allow a developer to remove the limitations of using AI bots with a browser application.
      The outer agent code, perhaps python, handles file management activities that a browser is not 
      allowed to do for secuity reasons. Most of the code management will be done with an AI model.
    </tm-b>
    <t-b>
      This page presents an example agent written in python that:
      <ul class="tight" style="margin-left:2rem;">
        <li>
          analyzes a specified path to a Rust crate, looking for its library 
        </li>
        <li>
          creates a list of public interface functions and encodes that in a markdown file.
        </li>
        <li>
          Generates an application in the Rust language that demonstrates 
          each of the public member functions.
        </li>
        <li>
          Places the demo application in the crate&apos;s examples directory. Users can then build
          the library and run the demo using Rust&apos;s Cargo tool.
        </li>
      </ul>
      All of this is demonstrated with the code and screenshots below.
    </t-b>
    <h3 id="agent_code">2.0 - Agent Code</h3>
    <tm-b>
      Here is the prompt used with Claude Sonnet 4.5:
      <div style="border: 2px dashed var(--dark); margin: 0.75rem 0.0rem; padding:0.5rem 1.5rem;">
        "generate a python based agent that, given a path to a local Rust crate, generates a markdown 
        file summarizing the crate's public interface and places a rust application that demonstrates 
        the public interface, in a directory, sibling to the src directory, named examples"
      </div>
      That generated markdown successfully.
    </tm-b>
    <t-b>
<details>
  <summary class="darkItem">Agent Generated Project Summary</summary>
  <div id="md_content" style="padding:0.5rem 2.0rem;"></div>
  <div>
  <script>
    fetch('./AI/RustDemoAgent-Claude/PROJECT_SUMMARY.md')
      .then(response => response.text())
      .then(text => {
        document.getElementById('md_content').innerHTML = marked.parse(text);
      });
  </script>
  </div>
</details>
    </t-b>
    <tm-b>
      The demo application was filled with not very useful
      placeholders and failed to build.
    </tm-b>
    <t-b>
      After several iterations with prompts showing error messages and sample working code the python agent 
      finally generated useful Rust demonstration code. 
    </t-b>
    <t-b>
      <div style="height:0.75rem;"></div>
      <details>
        <summary class="darkItem">Python Agent Code</summary>
    <code-viewer width="90ch" font-size="1.0rem" highlight="prism" language="css"  bg-color="var(--light)" title-bg-color="#ccc" style="margin-left:-1rem; overflow-x: auto;">
      Figure 1. Python Agent Code
      <pre slot="code"><code>  1 #!/usr/bin/env python3
  2 &quot;&quot;&quot;
  3 Rust Crate Analyzer Agent - Enhanced Version
  4
  5 Analyzes a Rust crate's public interface and generates:
  6 1. A markdown summary of the public API
  7 2. A WORKING demonstration Rust application (not just comments!)
  8 &quot;&quot;&quot;
  9
 10 import os
 11 import sys
 12 import re
 13 from pathlib import Path
 14 from typing import List, Dict, Tuple, Optional
 15
 16
 17 class RustCrateAnalyzer:
 18     &quot;&quot;&quot;Analyzes Rust crate structure and public interface.&quot;&quot;&quot;
 19
 20     def __init__(self, crate_path: str):
 21         self.crate_path = Path(crate_path).resolve()
 22         self.src_path = self.crate_path / &quot;src&quot;
 23         self.examples_path = self.crate_path / &quot;examples&quot;
 24         self.cargo_toml = self.crate_path / &quot;Cargo.toml&quot;
 25
 26         # Validate paths
 27         if not self.crate_path.exists():
 28             raise FileNotFoundError(f&quot;Crate path does not exist: {self.crate_path}&quot;)
 29         if not self.src_path.exists():
 30             raise FileNotFoundError(f&quot;Source directory does not exist: {self.src_path}&quot;)
 31         if not self.cargo_toml.exists():
 32             raise FileNotFoundError(f&quot;Cargo.toml not found: {self.cargo_toml}&quot;)
 33
 34         self.crate_name = self._extract_crate_name()
 35         self.public_items = {
 36             'structs': [],
 37             'enums': [],
 38             'traits': [],
 39             'functions': [],
 40             'constants': [],
 41             'modules': [],
 42             'impl_blocks': {}  # Maps struct name to list of methods
 43         }
 44
 45     def _extract_crate_name(self) -&gt; str:
 46         &quot;&quot;&quot;Extract crate name from Cargo.toml.&quot;&quot;&quot;
 47         with open(self.cargo_toml, 'r', encoding='utf-8') as f:
 48             for line in f:
 49                 if line.strip().startswith('name'):
 50                     match = re.search(r'name&#92;s*=&#92;s*[&quot;&#92;']([^&quot;&#92;']+)[&quot;&#92;']', line)
 51                     if match:
 52                         return match.group(1)
 53         return self.crate_path.name
 54
 55     def analyze(self):
 56         &quot;&quot;&quot;Analyze all Rust source files in the crate.&quot;&quot;&quot;
 57         print(f&quot;Analyzing crate: {self.crate_name}&quot;)
 58         print(f&quot;Crate path: {self.crate_path}&quot;)
 59
 60         # Find all .rs files
 61         rs_files = list(self.src_path.rglob(&quot;*.rs&quot;))
 62         print(f&quot;Found {len(rs_files)} Rust source files&quot;)
 63
 64         for rs_file in rs_files:
 65             self._analyze_file(rs_file)
 66
 67         return self.public_items
 68
 69     def _analyze_file(self, file_path: Path):
 70         &quot;&quot;&quot;Analyze a single Rust source file for public items.&quot;&quot;&quot;
 71         try:
 72             with open(file_path, 'r', encoding='utf-8') as f:
 73                 content = f.read()
 74         except Exception as e:
 75             print(f&quot;Warning: Could not read {file_path}: {e}&quot;)
 76             return
 77
 78         # Remove comments and strings to avoid false matches
 79         cleaned = self._remove_comments_and_strings(content)
 80
 81         # Extract public items
 82         self._extract_structs(cleaned, file_path)
 83         self._extract_enums(cleaned, file_path)
 84         self._extract_traits(cleaned, file_path)
 85         self._extract_impl_blocks(content, file_path)  # Parse impl blocks FIRST to get context
 86         self._extract_functions(cleaned, file_path)
 87         self._extract_constants(cleaned, file_path)
 88         self._extract_modules(cleaned, file_path)
 89
 90     def _remove_comments_and_strings(self, content: str) -&gt; str:
 91         &quot;&quot;&quot;Remove comments and string literals to avoid false matches.&quot;&quot;&quot;
 92         # Remove line comments
 93         content = re.sub(r'//.*$', '', content, flags=re.MULTILINE)
 94         # Remove block comments
 95         content = re.sub(r'/&#92;*.*?&#92;*/', '', content, flags=re.DOTALL)
 96         # Remove string literals
 97         content = re.sub(r'&quot;(?:[^&quot;&#92;&#92;]|&#92;&#92;.)*&quot;', '&quot;&quot;', content)
 98         return content
 99
100     def _extract_structs(self, content: str, file_path: Path):
101         &quot;&quot;&quot;Extract public struct definitions.&quot;&quot;&quot;
102         pattern = r'pub&#92;s+struct&#92;s+(&#92;w+)&#92;s*(?:&lt;[^&gt;]+&gt;)?(?:&#92;s*&#92;([^)]*&#92;)|&#92;s*&#92;{[^}]*&#92;})?'
103         matches = re.finditer(pattern, content)
104         for match in matches:
105             struct_name = match.group(1)
106             # Get the full definition for better context
107             full_match = self._extract_full_definition(content, match.start())
108             self.public_items['structs'].append({
109                 'name': struct_name,
110                 'definition': full_match,
111                 'file': file_path.relative_to(self.src_path),
112                 'has_generics': '&lt;' in full_match
113             })
114
115     def _extract_enums(self, content: str, file_path: Path):
116         &quot;&quot;&quot;Extract public enum definitions.&quot;&quot;&quot;
117         pattern = r'pub&#92;s+enum&#92;s+(&#92;w+)&#92;s*(?:&lt;[^&gt;]+&gt;)?&#92;s*&#92;{'
118         matches = re.finditer(pattern, content)
119         for match in matches:
120             enum_name = match.group(1)
121             full_match = self._extract_full_definition(content, match.start())
122             variants = self._extract_enum_variants(full_match)
123             self.public_items['enums'].append({
124                 'name': enum_name,
125                 'definition': full_match,
126                 'file': file_path.relative_to(self.src_path),
127                 'variants': variants
128             })
129
130     def _extract_traits(self, content: str, file_path: Path):
131         &quot;&quot;&quot;Extract public trait definitions.&quot;&quot;&quot;
132         pattern = r'pub&#92;s+trait&#92;s+(&#92;w+)&#92;s*(?:&lt;[^&gt;]+&gt;)?'
133         matches = re.finditer(pattern, content)
134         for match in matches:
135             trait_name = match.group(1)
136             full_match = self._extract_full_definition(content, match.start())
137             self.public_items['traits'].append({
138                 'name': trait_name,
139                 'definition': full_match,
140                 'file': file_path.relative_to(self.src_path)
141             })
142
143     def _extract_impl_blocks(self, content: str, file_path: Path):
144         &quot;&quot;&quot;Extract impl blocks to associate methods with structs.&quot;&quot;&quot;
145         # Match impl blocks: impl&lt;T&gt; StructName&lt;T&gt; { ... }
146         pattern = r'impl&#92;s*(?:&lt;[^&gt;]+&gt;)?&#92;s+(&#92;w+)&#92;s*(?:&lt;[^&gt;]+&gt;)?&#92;s*&#92;{'
147         matches = re.finditer(pattern, content)
148
149         for match in matches:
150             struct_name = match.group(1)
151             impl_start = match.end()
152
153             # Find the closing brace of this impl block
154             brace_count = 1
155             pos = impl_start
156             impl_end = impl_start
157
158             while pos &lt; len(content) and brace_count &gt; 0:
159                 if content[pos] == '{':
160                     brace_count += 1
161                 elif content[pos] == '}':
162                     brace_count -= 1
163                     if brace_count == 0:
164                         impl_end = pos
165                         break
166                 pos += 1
167
168             impl_body = content[impl_start:impl_end]
169
170             # Extract public methods from this impl block
171             method_pattern = r'pub&#92;s+fn&#92;s+(&#92;w+)'
172             method_matches = re.finditer(method_pattern, impl_body)
173
174             for method_match in method_matches:
175                 method_name = method_match.group(1)
176                 if struct_name not in self.public_items['impl_blocks']:
177                     self.public_items['impl_blocks'][struct_name] = []
178                 self.public_items['impl_blocks'][struct_name].append(method_name)
179
180     def _extract_functions(self, content: str, file_path: Path):
181         &quot;&quot;&quot;Extract public function definitions.&quot;&quot;&quot;
182         pattern = r'pub&#92;s+(?:async&#92;s+)?fn&#92;s+(&#92;w+)&#92;s*(?:&lt;[^&gt;]+&gt;)?&#92;s*&#92;([^)]*&#92;)'
183         matches = re.finditer(pattern, content)
184         for match in matches:
185             fn_name = match.group(1)
186             full_match = self._extract_full_definition(content, match.start())
187
188             # Determine if it's a method or standalone function
189             is_method = '&self' in full_match or '&mut self' in full_match
190
191             self.public_items['functions'].append({
192                 'name': fn_name,
193                 'definition': full_match,
194                 'file': file_path.relative_to(self.src_path),
195                 'is_method': is_method
196             })
197
198     def _extract_constants(self, content: str, file_path: Path):
199         &quot;&quot;&quot;Extract public constants.&quot;&quot;&quot;
200         pattern = r'pub&#92;s+const&#92;s+(&#92;w+)&#92;s*:&#92;s*[^=]+=&#92;s*[^;]+;'
201         matches = re.finditer(pattern, content)
202         for match in matches:
203             const_name = match.group(1)
204             self.public_items['constants'].append({
205                 'name': const_name,
206                 'definition': match.group(0),
207                 'file': file_path.relative_to(self.src_path)
208             })
209
210     def _extract_modules(self, content: str, file_path: Path):
211         &quot;&quot;&quot;Extract public module declarations.&quot;&quot;&quot;
212         pattern = r'pub&#92;s+mod&#92;s+(&#92;w+)&#92;s*;'
213         matches = re.finditer(pattern, content)
214         for match in matches:
215             mod_name = match.group(1)
216             self.public_items['modules'].append({
217                 'name': mod_name,
218                 'file': file_path.relative_to(self.src_path)
219             })
220
221     def _extract_full_definition(self, content: str, start_pos: int, max_lines: int = 15) -&gt; str:
222         &quot;&quot;&quot;Extract a complete definition starting from start_pos.&quot;&quot;&quot;
223         lines = content[start_pos:].split('&#92;n')
224         result_lines = []
225         brace_count = 0
226         in_definition = False
227
228         for line in lines[:max_lines]:
229             result_lines.append(line)
230             brace_count += line.count('{') - line.count('}')
231
232             if '{' in line:
233                 in_definition = True
234
235             # If we've closed all braces or hit a semicolon at top level
236             if in_definition and brace_count == 0:
237                 break
238             elif not in_definition and ';' in line:
239                 break
240
241         return '&#92;n'.join(result_lines).strip()
242
243     def _extract_enum_variants(self, enum_def: str) -&gt; List[str]:
244         &quot;&quot;&quot;Extract variant names from enum definition.&quot;&quot;&quot;
245         variants = []
246         # Look for variant patterns
247         lines = enum_def.split('&#92;n')
248         in_body = False
249         for line in lines:
250             if '{' in line:
251                 in_body = True
252                 continue
253             if '}' in line:
254                 break
255             if in_body:
256                 # Match variant names (word at start of trimmed line, before comma/brace/paren)
257                 match = re.match(r'&#92;s*(&#92;w+)', line)
258                 if match:
259                     variant = match.group(1)
260                     if variant and variant not in ['pub', 'enum']:
261                         variants.append(variant)
262         return variants
263
264     def generate_markdown(self) -&gt; str:
265         &quot;&quot;&quot;Generate markdown documentation of the public interface.&quot;&quot;&quot;
266         md_lines = [
267             f&quot;# {self.crate_name} - Public Interface&quot;,
268             &quot;&quot;,
269             f&quot;This document summarizes the public API of the `{self.crate_name}` crate.&quot;,
270             &quot;&quot;,
271             &quot;## Overview&quot;,
272             &quot;&quot;,
273             f&quot;- **Structs**: {len(self.public_items['structs'])}&quot;,
274             f&quot;- **Enums**: {len(self.public_items['enums'])}&quot;,
275             f&quot;- **Traits**: {len(self.public_items['traits'])}&quot;,
276             f&quot;- **Functions**: {len(self.public_items['functions'])}&quot;,
277             f&quot;- **Constants**: {len(self.public_items['constants'])}&quot;,
278             f&quot;- **Modules**: {len(self.public_items['modules'])}&quot;,
279             &quot;&quot;
280         ]
281
282         # Add each category
283         if self.public_items['structs']:
284             md_lines.extend(self._format_items_section(&quot;Structs&quot;, self.public_items['structs']))
285
286         if self.public_items['enums']:
287             md_lines.extend(self._format_items_section(&quot;Enums&quot;, self.public_items['enums']))
288
289         if self.public_items['traits']:
290             md_lines.extend(self._format_items_section(&quot;Traits&quot;, self.public_items['traits']))
291
292         if self.public_items['functions']:
293             md_lines.extend(self._format_items_section(&quot;Functions&quot;, self.public_items['functions']))
294
295         if self.public_items['constants']:
296             md_lines.extend(self._format_items_section(&quot;Constants&quot;, self.public_items['constants']))
297
298         if self.public_items['modules']:
299             md_lines.extend(self._format_modules_section())
300
301         return '&#92;n'.join(md_lines)
302
303     def _format_items_section(self, title: str, items: List[Dict]) -&gt; List[str]:
304         &quot;&quot;&quot;Format a section of items for markdown.&quot;&quot;&quot;
305         lines = [f&quot;## {title}&quot;, &quot;&quot;]
306
307         for item in items:
308             lines.append(f&quot;### `{item['name']}`&quot;)
309             lines.append(&quot;&quot;)
310             lines.append(f&quot;*Defined in: `{item['file']}`*&quot;)
311             lines.append(&quot;&quot;)
312             lines.append(&quot;```rust&quot;)
313             lines.append(item['definition'])
314             lines.append(&quot;```&quot;)
315             lines.append(&quot;&quot;)
316
317         return lines
318
319     def _format_modules_section(self) -&gt; List[str]:
320         &quot;&quot;&quot;Format modules section for markdown.&quot;&quot;&quot;
321         lines = [&quot;## Modules&quot;, &quot;&quot;]
322
323         for mod in self.public_items['modules']:
324             lines.append(f&quot;- `{mod['name']}` (declared in `{mod['file']}`)&quot;)
325
326         lines.append(&quot;&quot;)
327         return lines
328
329     def generate_example(self) -&gt; str:
330         &quot;&quot;&quot;Generate a WORKING Rust example that demonstrates the public interface.&quot;&quot;&quot;
331         example_lines = [
332             f&quot;// Example demonstrating the {self.crate_name} crate public interface&quot;,
333             f&quot;// This file was auto-generated by rust_crate_analyzer&quot;,
334             &quot;&quot;,
335             f&quot;use {self.crate_name}::*;&quot;,
336             &quot;&quot;,
337             &quot;fn main() {&quot;,
338             f'    println!(&quot;Demonstrating {self.crate_name} crate&quot;);',
339             '    println!(&quot;{}&quot;, &quot;=&quot;.repeat(50));',
340             &quot;&quot;
341         ]
342
343         section_num = 1
344
345         # Find constructors using impl block information
346         struct_with_new = {}
347         for struct_name, method_names in self.public_items['impl_blocks'].items():
348             if 'new' in method_names:
349                 # Find the new function
350                 for func in self.public_items['functions']:
351                     if func['name'] == 'new':
352                         struct_with_new[struct_name] = func
353                         break
354
355         # Find methods for each struct using impl block information
356         methods_by_struct = {}
357         for struct_name, method_names in self.public_items['impl_blocks'].items():
358             struct_methods = []
359             for func in self.public_items['functions']:
360                 if func['name'] in method_names and func['name'] != 'new':  # Exclude constructor
361                     struct_methods.append(func)
362             if struct_methods:
363                 methods_by_struct[struct_name] = struct_methods
364
365         # Generate comprehensive struct examples with usage
366         if self.public_items['structs']:
367             for struct in self.public_items['structs'][:2]:  # Focus on first 2 structs
368                 struct_name = struct['name']
369                 var_name = struct_name.lower()
370
371                 # Only generate if we have a constructor OR methods
372                 if struct_name in struct_with_new or struct_name in methods_by_struct:
373                     example_lines.append(f'    println!(&quot;&#92;&#92;n{section_num}. {struct_name} demonstrations...&quot;);')
374
375                     # Create instance
376                     if struct_name in struct_with_new:
377                         if struct['has_generics']:
378                             example_lines.append(f&quot;    let {var_name} = {struct_name}::&lt;String&gt;::new();&quot;)
379                         else:
380                             example_lines.append(f&quot;    let {var_name} = {struct_name}::new();&quot;)
381                     else:
382                         example_lines.append(f&quot;    // let {var_name} = {struct_name} {{ /* fields */ }};&quot;)
383                     example_lines.append(&quot;&quot;)
384
385                     # Find and use methods
386                     struct_methods = methods_by_struct.get(struct_name, [])
387
388                     # Look for common patterns (enqueue/push methods)
389                     # Normalize names by removing underscores for pattern matching
390                     enqueue_methods = [m for m in struct_methods if any(name in m['name'].replace('_', '').lower() for name in ['push', 'enq', 'add', 'insert', 'put'])]
391                     dequeue_methods = [m for m in struct_methods if any(name in m['name'].replace('_', '').lower() for name in ['pop', 'deq', 'remove', 'get', 'take'])]
392
393                     if enqueue_methods:
394                         enq_method = enqueue_methods[0]
395                         example_lines.append(f'    println!(&quot;   Enqueuing items...&quot;);')
396                         example_lines.append(f&quot;    for i in 1..=5 {{&quot;)
397                         example_lines.append(f'        let msg = format!(&quot;msg{{}}&quot;, i);')
398                         example_lines.append(f&quot;        {var_name}.{enq_method['name']}(msg);&quot;)
399                         example_lines.append(f'        println!(&quot;      Enqueued: msg{{}}&quot;, i);')
400                         example_lines.append(f&quot;    }}&quot;)
401                         example_lines.append(&quot;&quot;)
402
403                     if dequeue_methods:
404                         deq_method = dequeue_methods[0]
405                         example_lines.append(f'    println!(&quot;   Dequeuing items...&quot;);')
406                         example_lines.append(f&quot;    for _ in 1..=5 {{&quot;)
407                         example_lines.append(f&quot;        let msg = {var_name}.{deq_method['name']}();&quot;)
408                         example_lines.append(f'        println!(&quot;      Dequeued: {{}}&quot;, msg);')
409                         example_lines.append(f&quot;    }}&quot;)
410                         example_lines.append(&quot;&quot;)
411
412                     example_lines.append(f'    println!(&quot;   {struct_name} operations complete!&quot;);')
413                     example_lines.append(&quot;&quot;)
414                     section_num += 1
415
416         # Generate standalone function examples (not methods)
417         standalone_fns = [f for f in self.public_items['functions']
418                          if not f['is_method'] and f['name'] != 'new']
419
420         if standalone_fns:
421             example_lines.append(f'    println!(&quot;&#92;&#92;n{section_num}. Standalone functions...&quot;);')
422             for func in standalone_fns[:5]:
423                 func_name = func['name']
424                 params = self._generate_params_from_definition(func['definition'])
425
426                 # Try to determine if it returns something
427                 if '-&gt;' in func['definition'] and '()' not in func['definition'].split('-&gt;')[-1]:
428                     example_lines.append(f&quot;    let result = {func_name}({params});&quot;)
429                     example_lines.append(f'    println!(&quot;   {func_name} returned: {{:?}}&quot;, result);')
430                 else:
431                     example_lines.append(f&quot;    {func_name}({params});&quot;)
432                     example_lines.append(f'    println!(&quot;   Called {func_name}&quot;);')
433             example_lines.append(&quot;&quot;)
434             section_num += 1
435
436         # Generate enum examples
437         if self.public_items['enums']:
438             example_lines.append(f'    println!(&quot;&#92;&#92;n{section_num}. Enum usage...&quot;);')
439             for enum in self.public_items['enums'][:2]:
440                 enum_name = enum['name']
441                 if enum.get('variants'):
442                     first_variant = enum['variants'][0]
443                     example_lines.append(f&quot;    let _value = {enum_name}::{first_variant};&quot;)
444                     example_lines.append(f'    println!(&quot;   Created {enum_name}::{first_variant}&quot;);')
445
446                     # Show pattern matching if multiple variants
447                     if len(enum['variants']) &gt; 1:
448                         example_lines.append(f&quot;    match _value {{&quot;)
449                         for variant in enum['variants'][:3]:
450                             example_lines.append(f&quot;        {enum_name}::{variant} =&gt; println!(&#92;&quot;      Matched {variant}&#92;&quot;),&quot;)
451                         if len(enum['variants']) &gt; 3:
452                             example_lines.append(f&quot;        _ =&gt; println!(&#92;&quot;      Other variant&#92;&quot;),&quot;)
453                         example_lines.append(f&quot;    }}&quot;)
454             example_lines.append(&quot;&quot;)
455             section_num += 1
456
457         # Generate constant examples
458         if self.public_items['constants']:
459             example_lines.append(f'    println!(&quot;&#92;&#92;n{section_num}. Constants...&quot;);')
460             for const in self.public_items['constants']:
461                 const_name = const['name']
462                 example_lines.append(f'    println!(&quot;   {const_name}: {{}}&quot;, {const_name});')
463             example_lines.append(&quot;&quot;)
464
465         example_lines.extend([
466             '    println!(&quot;&#92;&#92;nExample complete!&quot;);',
467             &quot;}&quot;
468         ])
469
470         return '&#92;n'.join(example_lines)
471
472     def _generate_params_from_definition(self, func_def: str) -&gt; str:
473         &quot;&quot;&quot;Generate example parameters from function definition.&quot;&quot;&quot;
474         # Extract parameter list
475         match = re.search(r'&#92;((.*?)&#92;)', func_def)
476         if not match:
477             return &quot;&quot;
478
479         params_str = match.group(1)
480         if not params_str.strip():
481             return &quot;&quot;
482
483         # Parse parameters
484         result_params = []
485         for param in params_str.split(','):
486             param = param.strip()
487             if not param or param.startswith('self'):
488                 continue
489
490             # Extract type hint
491             if ':' in param:
492                 param_type = param.split(':')[1].strip()
493                 example_val = self._type_to_example(param_type)
494                 result_params.append(example_val)
495
496         return ', '.join(result_params) if result_params else &quot;/* params */&quot;
497
498     def _type_to_example(self, type_str: str) -&gt; str:
499         &quot;&quot;&quot;Convert a type string to an example value.&quot;&quot;&quot;
500         type_lower = type_str.lower()
501
502         if 'string' in type_lower:
503             return '&quot;example&quot;.to_string()'
504         elif '&str' in type_str:
505             return '&quot;example&quot;'
506         elif 'i32' in type_lower or 'i64' in type_lower:
507             return '42'
508         elif 'u32' in type_lower or 'u64' in type_lower or 'usize' in type_lower:
509             return '10'
510         elif 'f32' in type_lower or 'f64' in type_lower:
511             return '3.14'
512         elif 'bool' in type_lower:
513             return 'true'
514         elif 'vec' in type_lower:
515             return 'vec![]'
516         else:
517             return '/* value */'
518
519     def write_outputs(self):
520         &quot;&quot;&quot;Write the markdown documentation and example files.&quot;&quot;&quot;
521         # Create examples directory if it doesn't exist
522         self.examples_path.mkdir(exist_ok=True)
523
524         # Write markdown documentation
525         md_output_path = self.crate_path / f&quot;{self.crate_name}_interface.md&quot;
526         md_content = self.generate_markdown()
527         with open(md_output_path, 'w', encoding='utf-8') as f:
528             f.write(md_content)
529         print(f&quot;&#92;n√ Generated documentation: {md_output_path}&quot;)
530
531         # Write example application
532         example_output_path = self.examples_path / &quot;demo.rs&quot;
533         example_content = self.generate_example()
534         with open(example_output_path, 'w', encoding='utf-8') as f:
535             f.write(example_content)
536         print(f&quot;√ Generated example: {example_output_path}&quot;)
537
538         return md_output_path, example_output_path
539
540
541 def main():
542     &quot;&quot;&quot;Main entry point for the analyzer agent.&quot;&quot;&quot;
543     if len(sys.argv) != 2:
544         print(&quot;Usage: python rust_crate_analyzer.py &lt;path_to_rust_crate&gt;&quot;)
545         print(&quot;&#92;nExample:&quot;)
546         print(&quot;  python rust_crate_analyzer.py /path/to/my_crate&quot;)
547         sys.exit(1)
548
549     crate_path = sys.argv[1]
550
551     try:
552         # Create analyzer
553         analyzer = RustCrateAnalyzer(crate_path)
554
555         # Analyze the crate
556         public_items = analyzer.analyze()
557
558         # Print summary
559         print(&quot;&#92;n&quot; + &quot;=&quot; * 60)
560         print(&quot;ANALYSIS COMPLETE&quot;)
561         print(&quot;=&quot; * 60)
562         print(f&quot;&#92;nPublic Interface Summary:&quot;)
563         print(f&quot;  Structs:   {len(public_items['structs'])}&quot;)
564         print(f&quot;  Enums:     {len(public_items['enums'])}&quot;)
565         print(f&quot;  Traits:    {len(public_items['traits'])}&quot;)
566         print(f&quot;  Functions: {len(public_items['functions'])}&quot;)
567         print(f&quot;  Constants: {len(public_items['constants'])}&quot;)
568         print(f&quot;  Modules:   {len(public_items['modules'])}&quot;)
569
570         # Write outputs
571         print(&quot;&#92;nGenerating outputs...&quot;)
572         analyzer.write_outputs()
573
574         print(&quot;&#92;n&quot; + &quot;=&quot; * 60)
575         print(&quot;SUCCESS&quot;)
576         print(&quot;=&quot; * 60)
577
578     except FileNotFoundError as e:
579         print(f&quot;Error: {e}&quot;, file=sys.stderr)
580         sys.exit(1)
581     except Exception as e:
582         print(f&quot;Unexpected error: {e}&quot;, file=sys.stderr)
583         import traceback
584         traceback.print_exc()
585         sys.exit(1)
586
587
588 if __name__ == &quot;__main__&quot;:
589     main()</code></pre>
        </code-viewer>
      </details>
    </t-b>
    <t-b>
      <details>
        <summary class="darkItem">Rust Demo Code</summary>
    <code-viewer width="90ch" font-size="1.0rem" highlight="prism" language="css"  bg-color="var(--light)" title-bg-color="#ccc" style="margin-left:-1rem; overflow-x: auto;">
      Figure 1. Rust BlockingQueue Demo
      <pre slot="code"><code> 1 // Example demonstrating the rust_blocking_queue crate public interface
 2 // This file was auto-generated by rust_crate_analyzer
 3
 4 use rust_blocking_queue::*;
 5
 6 fn main() {
 7     println!(&quot;Demonstrating rust_blocking_queue crate&quot;);
 8     println!(&quot;{}&quot;, &quot;=&quot;.repeat(50));
 9
10     println!(&quot;&#92;n1. BlockingQueue demonstrations...&quot;);
11     let blockingqueue = BlockingQueue::&lt;String&gt;::new();
12
13     println!(&quot;   Enqueuing items...&quot;);
14     for i in 1..=5 {
15         let msg = format!(&quot;msg{}&quot;, i);
16         blockingqueue.en_q(msg);
17         println!(&quot;      Enqueued: msg{}&quot;, i);
18     }
19
20     println!(&quot;   Dequeuing items...&quot;);
21     for _ in 1..=5 {
22         let msg = blockingqueue.de_q();
23         println!(&quot;      Dequeued: {}&quot;, msg);
24     }
25
26     println!(&quot;   BlockingQueue operations complete!&quot;);
27
28     println!(&quot;&#92;nExample complete!&quot;);
29 }</code></pre>
        </code-viewer>  
      </details>
    </t-b>
    <tm-b>
      <details>
        <summary class="darkItem">Rust Demo Output</summary>
        <code-viewer width="90ch" font-size="1.0rem" highlight="prism" language="css"  bg-color="var(--light)" title-bg-color="#ccc" style="margin-left:-1rem; overflow-x: auto;">
          Figure 1. Demo Output
          <pre slot="code"><code>
C:\github\JimFawcett\RustBlockingQueue
> cargo run --example demo
   Compiling rust_blocking_queue v0.1.0 (C:\github\JimFawcett\RustBlockingQueue)     
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running `target\debug\examples\demo.exe`
Demonstrating rust_blocking_queue crate
==================================================

1. BlockingQueue demonstrations...
   Enqueuing items...
      Enqueued: msg1
      Enqueued: msg2
      Enqueued: msg3
      Enqueued: msg4
      Enqueued: msg5
   Dequeuing items...
      Dequeued: msg1
      Dequeued: msg2
      Dequeued: msg3
      Dequeued: msg4
      Dequeued: msg5
   BlockingQueue operations complete!

Example complete!
C:\github\JimFawcett\RustBlockingQueue
>
          </code></pre>
        </code-viewer>
      </details>
    </tm-b>
    <t-b>
      This page is just starting.  It will eventually contain completed examples of local file access and modification:
      <ol>
        <li>
          Creation of project folders with starter code for Rust and C++ managed with git. 
          <hr>
          This agent should provide the project infrastructure for building from the 
          VSCode terminal using Rust's cargo or CMake for C++.
          Eventially building Tomal files 
          and Visual Studio project and solution files will be added.
        </li>
        <li>
          Interactive refactoring of local files.
          <hr>
          Start with creating a new git branch, then display the results of refactoring and if 
          accepted change the local files.  Merging will be left to developer descretion, but adding 
          a merge management tool would be useful.
        </li>
        <li>
          Build code management tools inspired by Rust's cargo, e.g., cargo_cpp, cargo_csharp, 
          cargo_python. Not sure that cargo_csharp or cargo_python are worth the effort because 
          C# already has dotnet CLI, and python code management is fairly simple.
          <hr>
          Expect to build each of the parts of a cargo like tool in python, e.g., project creator,
          builder, unit tester, ... Then wrap the python parts in a Rust shell. That would probably 
          use the pyo3 crate.
        </li>
        <li>
          Create multi-threaded message passing libraries with blocking queues, thread pool, and 
          handcrafted threaded buffer management. Create a new project with the same specs using 
          async-await methods to replace handcrafted threading where that makes sense.
          <hr>
          I've constructed several libraries like the first mentioned here.  The hope is that 
          agents will make these trials productive enough to try more options.
        </li>
      </ol>
    </t-b>

<div style="height:5rem;"></div>
</content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/CodeBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 4, 10);
  </script>
</body>
</html>
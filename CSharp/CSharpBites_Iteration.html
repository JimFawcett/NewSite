<!DOCTYPE html>
<html id="top">
<!--
  CSharpBites_Iteration.html
-->
<head>
  <title>C# Iteration</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeCSharp.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <!-- <link rel="stylesheet" href="../css/Styles_BitsContent.css" />
  <script src="../js/Scripts_BitsContent.js"></script> -->
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreCSharp.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
    .wrapper {
      display:flex;
      flex-direction: row;
      /* border:2px solid var(--dark); */
    }
    .codewrapfloat {
      padding:0rem 0.25rem;
      border:2px solid var(--dark);
    }
    .textwrap {
      padding:0rem 1rem; 
      width:30rem; 
      border:2px solid var(--dark);
    }

    details {
      margin-top:1rem;
    }


  </style>
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="CSharpBites_Data.html"></a>
  <a id="prev" class="hidden" href="CSharpBites_HelloCSharp.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    CSharpBites_Iteration.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 06/20/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">C# Bites: Iteration</h2>
        <h4 id="subtitle" class="indent">
          iterate over library and user-defined types
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="CSharpHome.html" style="color:var(--atten); margin-left:1.5rem;">C# Track</a>
      </div>

      <!--<div style="padding-right:25px; position:absolute; top:1.1em; right:13em; z-index:5;">-->
    </header>
        <t-b  id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates uses of C# iteration.
          <hr class="spread" />
          <ul>
            <li>
              C# iteration acts on types that implement the <c-s>IEnumerable</c-s> and
              <c-s>IEnumerable&lt;T&gt;</c-s> interfaces. These include:
              <div class="inset">
                <c-s>List&lt;T&gt;, Dictionary&lt;K, V&gt;, string</c-s>, and user-defined
                types that implement them.
              </div>
            </li>
            <li>
              C# arrays do not explicitly implement the <c-s>IEnumerable&lt;T&gt;</c-s> interface,
              but the CLR code generation process implicitly creates methods needed for enumeration.
            </li>
            <li>
              The C# <c-s>foreach</c-s> loop implicitly uses methods of the enumeration interfaces to
              simplify iteration through collections.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <!-- <under-construction>
          This page is under construction. All of the code blocks will change.
        </under-construction> -->
        <details id="notes">
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            All of the languages covered in this demonstrtion support iteration using iterators.
          </t-b>
          <t-b>
            C# iterators are provided by enumerable containers and implement a public interface with the method
            <c-s style="white-space:nowrap;">bool MoveNext();</c-s> and property <c-s style="white-space:nowrap;">T Current { get; }</c-s>.
          </t-b>
          <t-b>
            This demonstration illustrates use of iterators with a series of functions that provide code,
            in several forms, for iterating through containers. It includes demos for library types and
            for a user-defined point class.
          </t-b>
        </details>
        <h3 id="enumeration">1.0 Enumeration</h3>
        <t-b><hr /></t-b>
        <t-b>
          C# provides a rich set of enumeration facilities for standard and user-defined collection types.
          The four interfaces presented below show how to step through collections and build functions
          that accept collections for modification and display.
        </t-b>
        <t-b>
          Enumeration over C# collections is based on two interfaces. The first provides access
          to an enumeration object:
          <div class="inset">
            <c-s>
              public interface IEnumerable&lt;T&gt; : IEnumerable, IDisposable<br />
              {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;IEnumerator&lt;T&gt; GetEnumerator();<br />
              }
            </c-s>
          </div>
          The base <c-s>IEnumerable</c-s> interface declares the same <c-s>GetEnumerator()</c-s> method,
          but that returns a non-generic enumerator.
          Deriving from this base supports access to enumerators for either generic or non-generic
          collections. The <c-s>IDisposable</c-s> interface declares a <c-s>Dispose()</c-s> method for preemtively
          enqueuing an instance for the next resource collection.
        </t-b>
        <t-b>
          The Second interface provides methods to step through, and return values from,
          enumerable collections using the enumerator returned from <c-s>GetEnumerator()</c-s>.
          <div class="inset">
            <c-s>
              public interface IEnumerator&lt;T&gt; : IEnumerator, IDisposable<br />
              {<br />
              &nbsp;&nbsp;&nbsp;T Current { get; }<br />
              &nbsp;&nbsp;&nbsp;bool MoveNext();<br />
              &nbsp;&nbsp;&nbsp;void Reset();<br />
              }
            </c-s>
          </div>
          Deriving from the non-generic base interface, <c-s>IEnumerator</c-s>, supports indexing
          both generic and non-generic collections.
        </t-b>
        <t-b class="spread">
          <hr />
        </t-b>
        <h3 id="relatedinterf">1.1 Related Interfaces</h3>
        <t-b>
        </t-b>
        <t-b>
          There are two other interfaces frequently associated with enumeration: <c-s>ICollection&lt;T&gt;</c-s>
          which provides operations that focus on the collection as a whole, and <c-s>IList&lt;T&gt;</c-s> which
          provides methods for managing individual elements.
        </t-b>
        <t-b>
          <div class="inset">
            <c-s>
              public interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerable<br />
              {<br />
              &nbsp;&nbsp;&nbsp;int Count { get; }<br />
              &nbsp;&nbsp;&nbsp;bool Contains(T item);<br />
              &nbsp;&nbsp;&nbsp;void CopyTo(T[] array, int index);<br />
              &nbsp;&nbsp;&nbsp;bool IsReadOnly { get; }<br />
              &nbsp;&nbsp;&nbsp;void Add(T item);<br />
              &nbsp;&nbsp;&nbsp;bool Remove(T item);<br />
              &nbsp;&nbsp;&nbsp;void Clear();<br />
              }
            </c-s>
          </div>
        </t-b>
        <t-b>
          Deriving from the non-generic base interface, <c-s>IEnumerable</c-s>, supports working with
          both generic and non-generic collections.
        </t-b>
        <t-b>
          The <c-s>IList&lt;T&gt;</c-s> interface supports indexing operations on the collecton. This
          doesn&apos;t have to be just lists.  It is often implemented by user-defined types, and the
          native C# array is provided with these methods by the CLR during translation.
        </t-b>
        <t-b>
          <div class="inset">
            <c-s>
              public interface IList&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable<br />
              {<br />
              &nbsp;&nbsp;&nbsp;Object this [int index] { get; set; }<br />
              &nbsp;&nbsp;&nbsp;int IndexOf(T item);<br />
              &nbsp;&nbsp;&nbsp;void Insert(int index, T item);<br />
              &nbsp;&nbsp;&nbsp;void RemoveAt(int index);<br />
              }
            </c-s>
          </div>
        </t-b>
        <t-b>
          Deriving from the non-generic base interface, <c-s>IEnumerable</c-s>, supports indexing
          both generic and non-generic collections.
        </t-b>
        <h3 id="lambdas">1.2 Lambda Expressions</h3>
        <t-b>
          Lambdas are used in several of the demonstrations below. Here&apos;s what you need to know
          about them for this topic:
        </t-b>
        <t-b>
          A lambda expression defines an anonymous function of the form:
          <div class="inset">
            <c-s>(a1, a2, ...) => { e1; e2; ... }</c-s>
          </div>
          where <c-s>a1, a1, ...</c-s> are arguments and <c-s>e1, e2, ...</c-s> are expressions, each
          of which is terminated with a semicolon, making them statements.
          The return type of a lambda expression is inferred.
        </t-b>
        <t-b>
          If there is only a single input argument the left-hand parentheses may be omitted. If there is
          only a single statement, the right-hand braces may be omitted.
        </t-b>
        <t-b>
          An example is:
          <div class="inset">
            <c-s>x => x * x;</c-s>
          </div>
        </t-b>
        <t-b>
          During compilation, lamda expressions are converted to private methods
        </t-b>
        <h3 id="delegates">1.3 Delegates</h3>
        <t-b>
          A <c-s>delegate</c-s> type defines a proxy for some lambda or method:
          <div class="inset">
            <c-s>delegate R DelegateName(T t, U u, ...);</c-s>
          </div>
          defines a proxy for any method that accepts arguments of type <c-s>T, U, ...</c-s> and returns a value
          of type <c-s>R</c-s>.
          It is instantiated by assigning to it the name of some function or lambda with the same signature:
          <div class="inset">
            <c-s>int Square(int x) => x * x;</c-s><br />
            <c-s>delegate int DoOp(int x);</c-s><br />
            <c-s>DoOp = Square</c-s>
          </div>
          Sometime later:
          <div class="inset">
            <c-s>var sqrd = DoOp(5);</c-s>
          </div>
        </t-b>
        <tb>
          Delegates are often used for event handling or plug-ins for processing
          that is published as a utility, supporting user defined operations. The utility defines 
          and exposes a delegate as part of its public interface.
          Then users supply a specific operation invoked by the delegate.
        </tb>
        <h3 id="stddel">1.3.1 Standard Delegates</h3>
        <t-b>
          The .Net std library defines many delegates. Here we list a few of the most common:
          <div class="inset">
            <table>
              <tr>
                <td><c-s>Action</c-s></td>
                <td>
                  Proxy for methods that take no parameters and return nothing.
                </td>
              </tr>
              <tr>
                <td><c-s>Action&lt;T&gt;</c-s></td>
                <td>
                  Represents methods that take a single argument and return nothing.
                </td>
              </tr>
              <tr>
                <td><c-s>Func&lt;T,&nbsp;R&gt;</c-s></td>
                <td>
                  Proxy for methods that accept an argument of type <c-s>T</c-s> and return
                  a value of type <c-s>R</c-s>.
                </td>
              </tr>
            </table>
          </div>
        </t-b>
        <div style="height:0.25em;"></div>
        <h3 id="code">2.0 Source Code</h3>
        <t-b>
          Examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <t-b>
          These demonstrations of iteration in C# code are partitioned into modules Program.cs, PointsIter.cs,
          and AnalysisIter.cs.  Discussion of each of these will be
          presented in separate sections of the page, below, accessed from links in the left panel.
        </t-b>
        <div style="height:0.0em;"></div>
        <h3 id="stdlib">2.1 Standard Generic Library Types</h3>
        <t-b>
          Standard <c-s>IEnumerable&lt;T&gt;</c-s> types are defined in the
          <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/standard/class-library-overview">.Net Standard Library</a>
          and include many more than shown here. We have selected three frequently used types for
          demonstration: arrays, lists, and dictionaries. You can find details of the others from the <a target="_blank" href="#refs">references</a>.
        </t-b>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <t-b>
          Alter splitter-bar panel widths by dragging splitter bar or clicking in either panel
          to expand that panel&apos;s width. Default widths are set by setting width style on
          left panel.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="stdlib-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('stdlib-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------------
  Enumerate standard library types
*/
static void EnumStdTypes() {

  Display.ShowNote(&quot;  Enumerate standard types&quot;, &quot;&#92;n&quot;);

  Display.ShowOp(&quot;array - basic enumeration&quot;);
  int[] arri = { 0, 1, 2, 1, 0 };
  var enm = arri.GetEnumerator();
  enm.MoveNext();
  Console.Write(&quot;  {0}&quot;, enm.Current);
  while (enm.MoveNext()) {
    Console.Write(&quot;, {0}&quot;, enm.Current);
  }
  Console.WriteLine(&quot;&#92;n&quot;);

  Display.ShowOp(&quot;enumerate list with foreach&quot;);
  List&lt;double&gt; ld = new List&lt;double&gt;{1.0, 1.5, 2.0, 2.5, 3.0 };
  bool first = true;
  foreach (var item in ld) {
    if (first) {
      Console.Write(&quot;  {0:0.0}&quot;, item);
      first = false;
    }
    else {
      Console.Write(&quot;, {0:0.0}&quot;, item);
    }
  }
  Console.WriteLine(&quot;&#92;n&quot;);

  Display.ShowOp(&quot;enumerate dictionary with foreach&quot;);
  Dictionary&lt;string, int&gt; dsi =
    new Dictionary&lt;string, int&gt;{
      {&quot;zero&quot;, 0}, {&quot;one&quot;, 1}, {&quot;two&quot;, 2}, {&quot;three&quot;, 3}, {&quot;four&quot;, 4},
    };
  first = true;
  foreach (var item in dsi) {
    if (first) {
      Console.Write(&quot;  {0}&quot;, item);
      first = false;
    }
    else {
      Console.Write(&quot;, {0}&quot;, item);
    }
  }
  Console.WriteLine(&quot;&#92;n&quot;);
}
  </code></pre>
              </div>
            </first-item>
            <splitter-bar id="stdlib-seperator"></splitter-bar>
            <second-item id="stdlib-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('stdlib-first')">
                <pre style="width:200em;"><code class="language-shell">--------------------------------------------------
  Enumerate standard types
--------------------------------------------------




--- array - basic enumeration ---
  0, 1, 2, 1, 0








--- enumerate list with foreach ---
  1.0, 1.5, 2.0, 2.5, 3.0












--- enumerate dictionary with foreach ---
  [zero, 0], [one, 1], [two, 2], [three, 3], [four, 4]

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <div style="height:1em"></div>
        <h3 id="userdef">2.2 User-defined Custom Types</h3>
        <t-b>
          C# defines custom types with the &quot;<c-s>class</c-s>&quot; keyword. Classes are
          patterns for laying out instances in memory and define operations for the instance
          data.
        </t-b>
        <t-b>
          Generic classes use one or more generic parameters as placeholders for specific defined
          types. That supports providing a single design that works for multiple types, improving
          code abstraction and developer productivity.
        </t-b>
        <div style="height:0.25em;"></div>

        <h3 id="pointdef">2.2.1 BasicPoint&lt;T&gt; and Point&lt;T&gt; Definitions</h3>
        <t-b>
          <c-s>Point&lt;T&gt;</c-s> is similar to the generic types <c-s>Point&lt;T, N&gt;</c-s> defined
          for C++ and Rust. There is one fundamental difference; the C++ template and Rust generic point
          types each take an integer parameter <c-s>N</c-s>. The C# generic point class does not.
        </t-b>
        <t-b>
          C# does not support adding integer types to a generic parameter list, e.g., <c-s>&lt;T, N&gt;</c-s>
          is not allowed.
        </t-b>
        <t-b>
          The <c-s>BasicPoint&lt;T&gt;</c-s> type fully implements enumeration and indexing capability.
          However, to be accepted by functions that expect standard collections, we need to implement
          <c-s>ICollection&lt;T&gt;</c-s> and <c-s>IList&lt;T&gt;</c-s> interfaces.
        </t-b>
        <t-b>
          For that reason, we also define the derived <c-s>Point&lt;T&gt;</c-s> type.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="pointdef-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('pointdef-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  Points.cs
  - provides definitions for user-defined class BasicPoint&lt;T&gt;
*/

using System.Collections;
using System.Collections.Generic;   // IEnumerable&lt;T&gt;, List&lt;T&gt;
using Analysis;

namespace Points {

  /*----------------------------------------------------------------------
    BasicPoint&lt;T&gt;
     - holds any finite number of generic coordinates
     - coordinates are held in a List&lt;T&gt;
     - implements IEnumerable&lt;T&gt; so it can be indexed and iterated
     - does not implement ICollection&lt;T&gt; or IList&lt;T&gt; to avoid making
       demonstration too complicated for learning example
     - it is a reference type because it is implemented with a class.
       its List&lt;T&gt; is also a reference type
  */
  public class BasicPoint&lt;T&gt; : IEnumerable&lt;T&gt;, Analysis.IShow {
    /*--------------------------------------------------------------------
      Constructs a BasicPoint with N coordinates each with default value
    */
    public BasicPoint(int N) {
      coor = new List&lt;T&gt;();
      for(int i = 0; i&lt;N; ++i) {
        T? test = default(T);
        if(test != null) {
          coor.Add(test);
        }
      }
    }
    /*--------------------------------------------------------------------
      Supports building BasicPoint by Adding elements after construction
    */
    public BasicPoint() {
      coor = new List&lt;T&gt;();
    }
    /*-----------------------------------------------------
      Add element to back of coordinate list
      - supports using list initializer, e.g.
        var p = new BasicPoint&lt;int&gt; { 1, 2. 3 }
    */
    public void Add(T t) {
      coor.Add(t);
    }
    /* translates IShow::show() for needs of BasicPoint class */
    public void Show(string name) {
      PrintSelf(name);
    }
    /*
      Displays structure and state of N-dimensional BasicPoint.
      - state is a set of rows of coordinate data
      - property Width specifies number of elements in each row
      - property Left specifies offset of row from terminal Left edge
    */
    public void PrintSelf(string name) {
      Console.Write(Display.Indent(Left));
      Console.Write(&quot;{0} {{&#92;n{1}&quot;, name, Display.Indent(Left + 2));
      for(int i=0; i&lt;coor.Count; ++i) {
        Console.Write(&quot;{0}&quot;, coor[i]);
        if(i &lt; coor.Count - 1) {
          Display.print(&quot;, &quot;);
        }
        if((i+1) % Width == 0 && i != coor.Count - 1) {
          Console.Write(&quot;&#92;n&quot;);
          Console.Write(Display.Indent(Left + Indent));
        }
      }
      Console.Write("\n" + Display.Indent(Left + Indent) + "{0}", dt);
      Console.Write(&quot;&#92;n{0}&quot;, Display.Indent(Left));
      Console.WriteLine(&quot;}&quot;);
    }
    /* The functions below support indexing and iterating */
    public T this[int index] {
      get { return coor[index]; }
      set { coor.Insert(index, value); }
    }
    /*-- returns coor enumerator --*/
    public IEnumerator&lt;T&gt; GetEnumerator() {
      return coor.GetEnumerator();
    }
    /*-- returns BasicPoint&lt;T&gt; enumerator --*/
    IEnumerator IEnumerable.GetEnumerator() {
      return this.GetEnumerator();
    }
    /*-- returns BasicPoint&lt;T&gt; iterator --*/
    public IEnumerable&lt;T&gt; iter() {
      foreach (var item in coor) {
        yield return item;
      }
    }
    public List&lt;T&gt; coor { get; set; }
    public DateTime dt { get; set; } = DateTime.Now;
    public int Length { get { return coor.Count; } }
    public int Width { get; set; } = 5;   // default row size
    public int Left { get; set; } = 2;    // default offset
    public int Indent { get; set; } = 2;
    /* initializers */
    public BasicPoint&lt;T&gt; width(int w) {
      this.Width = w;
      return this;
    }
    public BasicPoint&lt;T&gt; left(int l) {
      this.Left = l;
      return this;
    }
    public BasicPoint&lt;T&gt; indent(int i) {
      this.Indent = i;
      return this;
    }
  }
  /*-------------------------------------------------------
    Point&lt;T&gt;
    - same as BasicPoint&lt;T&gt; with additions:
      - implements ICollection&lt;T&gt; and IList&lt;T&gt; interfaces
      - single inheritance of BasicPoint&lt;T&gt;'s implementation
      - Deriving from ICollecton&lt;T&gt; and IList&lt;T&gt; supports using
        generic functions for analysis and display.
  */
  public class Point&lt;T&gt; :
    BasicPoint&lt;T&gt;, ICollection&lt;T&gt;, IList&lt;T&gt;
  {
    public Point(int N) : base(N) { }
    public Point() : base() {}
    public void Clear() {
      base.coor.Clear();
    }
    public bool Contains(T item) {
      return base.coor.Contains(item);
    }
    public void CopyTo(T[] array, int i) {
      base.coor.CopyTo(array, i);
    }
    public bool Remove(T item) {
      return base.coor.Remove(item);
    }
    public int Count {
      get { return base.coor.Count; }
    }
    public bool IsReadOnly {
      get { return false; }
    }
    public int IndexOf(T item) {
      return base.coor.IndexOf(item);
    }
    public void Insert(int i, T item) {
      base.coor.Insert(i, item);
    }
    public void RemoveAt(int index) {
      base.coor.RemoveAt(index);
    }
  }
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="pointdef-seperator"></splitter-bar>
            <second-item id="pointdef-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('pointdef-first')">
              <div class="textwrap noflow">
                <h3>BasicPoint&lt;T&gt; and Point&lt;T&gt;</h3>
                Reference types parameterized on <c-s>T</c-s>, the type of<br />
                their coordinate members.
                <div style="height:5em;"></div>

                <span style="font-size:1.75em; font-weight:bold;">&lArr;</span>
                <strong>Import</strong> Analysis and Display classes.
                <div style="height:20em;"></div>

                <span style="font-size:1.75em; font-weight:bold;">&lArr;</span>
                <c-s>BasicPoint&lt;T&gt;</c-s> implements<br />
                <c-s>IEnumerable&lt;T&gt;</c-s> and <c-s>IShow</c-s> interfaces.<br />
                Compilation will fail if the class does<br />
                not implement all of the methods declared<br />
                with these interfaces.
                <div style="height:1em;"></div>

                <t-b>
                  <span style="font-size:1.75em; font-weight:bold;">&lArr;</span> <strong>Constructor:</strong> <c-s>BasicPoint(int n)</c-s><br />
                  Unlike C++ and Rust, C# cannot use integral<br />
                  types as generic parameters, so the number of<br />
                  coordinates is passed as a constructor argument.<br />
                  <div style="height:21em;"></div>

                  <span style="font-size:1.75em; font-weight:bold;">&lArr;</span> <strong>Initialized Constructor:</strong><br />
                  <c-s>BasicPoint&lt;int&gt; { 1, 2, 3, 4, 5 }</c-s><br />
                  implicitly uses <c-s>Add(T t)</c-s> to add elements<br />
                  to <c-s>coor</c-s>.
                  <div style="height:39em;"></div>

                  <span style="font-size:1.75em; font-weight:bold;">&lArr;</span> <strong>Indexer:</strong><br />
                  <c-s>BasicPoint&lt;int&gt; { 1, 2, 3, 4, 5 }</c-s><br />
                  implicitly uses <c-s>Add(T t)</c-s> to add elements<br />
                  to <c-s>coor</c-s>.
                </t-b>
                <div style="height:26em"></div>

                <span style="font-size:1.75em; font-weight:bold;">&lArr;</span> <strong>Display format:</strong><br />
                <c-s>Width</c-s> sets number of elements per row<br />
                <c-s>Left</c-s> sets left margin<br />
                <c-s>Indent</c-s> sets offset of data within delimiters<br />
                <div style="height:31em;"></div>

                <span style="font-size:1.75em; font-weight:bold;">&lArr;</span>
                <c-s>Point&lt;T&gt;</c-s> inherits from BasicPoint&lt;T&gt;<br />
                and implements <c-s>ICollection&lt;T&gt;</c-s> and<br />
                <c-s>IList&lt;T&gt;</c-s> interfaces.<br />
                <br />
                With these additional interfaces, <c-s>Point&lt;T&gt;</c-s><br />
                instances will be accepted by generic functions<br />
                that expect standard collections.


              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>

        <h3 id="pointdemo">2.2.2 BasicPoint&lt;T&gt; and Point&lt;T&gt; Demonstration</h3>
        <t-b class="indents">
          For this demonstration either <c-s>BasicPoint&lt;T&gt;</c-s> or <c-s>Point&lt;T&gt;</c-s>
          can be used interchangeably; all we need is to satisfy the <c-s>IEnumeration&lt;T&gt;</c-s>
          interface.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="pointdemo-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('pointdemo-first')">
                <pre style="width:200em;"><code class="language-csharp">/*-----------------------------------------------------
  Enumerate Point&lt;T&gt;
  - all of the examples here work with either
    BasicPoint&lt;T&gt; or Point&lt;T&gt;
*/
static void EnumPoint() {

  Display.ShowNote(&quot;  Enumerate Point types&quot;, &quot;&#92;n&quot;);

  Display.ShowOp(&quot;BasicPoint - indexing&quot;);
  BasicPoint&lt;int&gt; bpi = new BasicPoint&lt;int&gt;() { 0, 1, 2, 3, 4 };
  Console.Write(&quot;  {0}&quot;, bpi[0]);
  for (int i = 1; i &lt; bpi.Length; i++) {
    Console.Write(&quot;, {0}&quot;, bpi[i]);
  };
  Console.WriteLine(&quot;&#92;n&quot;);

  Display.ShowOp(&quot;BasicPoint - basic enumeration&quot;);
  // BasicPoint&lt;int&gt; bpi = new BasicPoint&lt;int&gt;() { 0, 1, 2, 3, 4 };
  var enm = bpi.GetEnumerator();
  enm.MoveNext();
  Console.Write(&quot;  {0}&quot;, enm.Current);
  while (enm.MoveNext()) {
    Console.Write(&quot;, {0}&quot;, enm.Current);
  }
  Console.WriteLine(&quot;&#92;n&quot;);

  Display.ShowOp(&quot;Point enumeration with foreach&quot;);
  Point&lt;double&gt; pd = new Point&lt;double&gt;() { 0.0, -1.5, 3.0, -4.5, 6.0 };
  bool first = true;
  foreach (var item in pd) {
    if (first) {
      Console.Write(&quot;  {0:0.0}&quot;, item);
      first = false;
    }
    else {
      Console.Write(&quot;, {0:0.0}&quot;, item);
    }
  }
  Console.WriteLine(&quot;&#92;n&quot;);
}</code></pre>
              </div>
            </first-item>
            <splitter-bar id="pointdemo-seperator"></splitter-bar>
            <second-item id="pointdemo-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('pointdemo-first')">
                <pre style="width:200em;"><code class="language-term">





--------------------------------------------------
  Enumerate Point types
--------------------------------------------------

--- BasicPoint - indexing ---
  0, 1, 2, 3, 4





--- BasicPoint - basic enumeration ---
  0, 1, 2, 3, 4








--- Point enumeration with foreach ---
  0.0, -1.5, 3.0, -4.5, 6.0

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="genfunc">2.3 Generic Functions Definition</h3>
        <t-b>
          Generic functions need to bound their generic parameters with constraints ensuring
          that all methods called on any of them are actually implemented by the argument&apos;s
          types. If that isn&apos;t done, compilation will fail.
        </t-b>
        <t-b>
          The demonstrations below show how that is done for a variety of useful cases. Each
          example starts with the definition of a generic function that does some form
          of enumeration, followed by an executor function that shows how the demonstration function can be
          used.
        </t-b>
        <h3 id="indexer">2.3.1 Generic Indexer</h3>
        <t-b>
          This first demonstration displays elements of a collection using indexing.  That
          requires only the <c-s>ICollection&lt;T&gt;</c-s> and <c-s>IList&lt;T&gt;</c-s>
          interfaces.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="indexer-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('indexer-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------------
  void GenericIndexer&lt;T&gt;(List&lt;T&gt;)
  - Display list items with indexing
  - works for all sequential indexable containers
*/
static void GenericIndexer&lt;C, T&gt;(C coll)
    where C:ICollection&lt;T&gt;, IList&lt;T&gt;
{
  Console.Write(&quot;  {0}&quot;, coll[0]);
  for(int i=1; i &lt; coll.Count(); ++i) {
    Console.Write(&quot;, {0}&quot;, coll[i]);
  }
  Display.Println(&quot;&quot;);
}
static void executeGenericIndexer() {
  Display.ShowNote(&quot;  GenericIndexer&lt;C, T&gt;(C coll)&quot;, nl);

  Display.ShowOp(&quot;index over int[]&quot;);
  int[] ai = new int[] {1, 2, 3, 4, 5};
  GenericIndexer&lt;int[], int&gt;(ai);
  Console.WriteLine();

  Display.ShowOp(&quot;index over List&lt;int&gt;&quot;);
  List&lt;int&gt; li = new List&lt;int&gt;{1, 2, 3, 2, 1};
  GenericIndexer&lt;List&lt;int&gt;, int&gt;(li);
  Console.WriteLine();
  /*
    This demo cannot use BasicPoint&lt;T&gt; because it does not
    implement ICollection&lt;T&gt; and IList&lt;T&gt;.

  */
  Display.ShowOp(&quot;index over Point&lt;int&gt;&quot;);
  Point&lt;int&gt; pi = new Point&lt;int&gt;{1, 2, 3, 2, 1};
  GenericIndexer&lt;Point&lt;int&gt;, int&gt;(pi);
  Console.WriteLine();
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="indexer-seperator"></splitter-bar>
            <second-item id="indexer-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('indexer-first')">
                <pre style="width:200em;"><code class="language-shell">












--------------------------------------------------
  GenericIndexer&lt;C, T&gt;(C coll)
--------------------------------------------------

 --- index over int[] ---
  1, 2, 3, 4, 5



 --- index over List<int> ---
  1, 2, 3, 2, 1







 --- index over Point<int> ---
  1, 2, 3, 2, 1

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="enumer">2.3.2 Generic Enumeration</h3>
        <t-b>
          The function <c-s>GenericEnumerator&lt;T&gt;(IEnumerable&lt;T&gt; enm)</c-s> accepts only
          enumerables and so needs no additional constraints.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="enumer-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('enumer-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------------
  void GenericEnumerator&lt;T&gt;(IEnumerable&lt;T&gt; enm)
  - Display list items with enumerator
*/
static void GenericEnumerator&lt;T&gt;(IEnumerable&lt;T&gt; enm) {
  var lenum = enm.GetEnumerator();
  lenum.MoveNext();
  Console.Write(&quot;  {0}&quot;, lenum.Current);
  while(lenum.MoveNext()) {
    var item = lenum.Current;
    Console.Write(&quot;, {0}&quot;, item);
  }
  Display.Println(&quot;&quot;);
}
static void executeGenericEnumerator() {
  Display.ShowNote(
    &quot;  GenericEnumerator&lt;T&gt;(IEnumerable&lt;T&gt; enm)&quot;
  );
  Console.WriteLine();

  Display.ShowOp(&quot;enumerate over int[]&quot;);
  int[] ai = new int[] {1, 2, 3, 4, 5};
  GenericEnumerator&lt;int&gt;(ai);
  Console.WriteLine();

  Display.ShowOp(&quot;enumerate over String&quot;);
  String s = &quot;a string&quot;;
  GenericEnumerator&lt;char&gt;(s);
  Console.WriteLine();

  Display.ShowOp(&quot;enumerate over List&lt;double&gt;&quot;);
  List&lt;double&gt; ld = new List&lt;double&gt;{1.0, 2.25, 3.5, 2.75, 1.0};
  GenericEnumerator&lt;double&gt;(ld);
  Console.WriteLine();

  Display.ShowOp(&quot;enumerate over Dictionary&lt;String, int&gt;&quot;);
  Dictionary&lt;String, int&gt; d = new Dictionary&lt;String, int&gt; {
    {&quot;zero&quot;, 0}, {&quot;one&quot;, 1}, {&quot;two&quot;, 2}
  };
  GenericEnumerator&lt;KeyValuePair&lt;String,int&gt;&gt;(d);
  Console.WriteLine();

  Display.ShowOp(&quot;enumerate over BasicPoint&lt;int&gt;&quot;);
  BasicPoint&lt;int&gt; pb = new BasicPoint&lt;int&gt;{ 1, 2, 3, 2, 1 };
  GenericEnumerator&lt;int&gt;(pb);
  Console.WriteLine();

  Display.ShowOp(&quot;enumerate over Point&lt;int&gt;&quot;);
  Point&lt;int&gt; p = new Point&lt;int&gt;{ 1, 2, 3, 2, 1 };
  GenericEnumerator&lt;int&gt;(p);
  Console.WriteLine();
}</code></pre>
              </div>
            </first-item>
            <splitter-bar id="enumer-seperator"></splitter-bar>
            <second-item id="enumer-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('enumer-first')">
                <pre style="width:200em;"><code class="language-shell">














--------------------------------------------------
  GenericEnumerator<T>(IEnumerable<T> enm)
--------------------------------------------------


--- enumerate over int[] ---
  1, 2, 3, 4, 5



--- enumerate over String ---
  a,  , s, t, r, i, n, g



--- enumerate over List&lt;double&gt; ---
  1, 2.25, 3.5, 2.75, 1



--- enumerate over Dictionary&lt;String, int&gt; ---
  [zero, 0], [one, 1], [two, 2]





--- enumerate over BasicPoint&lt;int&gt; ---
  1, 2, 3, 2, 1



--- enumerate over Point&lt;int&gt; ---
  1, 2, 3, 2, 1

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="foreach">2.3.3 Generic ForEach</h3>
        <t-b>
          The example below uses a <c-s>foreach</c-s> loop that applies a lambda to each element of its input
          enumerable. The lambda has the type <c-s>Action&lt;T&gt;</c-s> which is a standard delegate
          taking a single argument and has no return value.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="foreach-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('foreach-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------------
  void GenericForEach&lt;T&gt;(IEnumerable&lt;T&gt; enm)
  - Display list items with foreach
*/
static void GenericForEach&lt;T&gt;(
  IEnumerable&lt;T&gt; enm, Action&lt;T&gt; lambda
) {
  foreach (T item in enm) {
    lambda(item);
  }
}
static void ExecuteGenericForEach() {

  Display.ShowNote(
    &quot;  GenericForEach&lt;T&gt;(<br />
    &nbsp;&nbsp;&nbsp;&nbsp;IEnumerable&lt;T&gt; enm, Action&lt;T&gt; lambda
    )&quot;
  );
  Console.WriteLine();

  Display.ShowOp(&quot;Add 1.0 to items of List&lt;double&gt;&quot;);
  List&lt;double&gt; ld = 
    &nbsp;&nbsp;&nbsp;&nbsp;new List&lt;double&gt;{1.0, 2.25, 3.5, 2.25, 1.0};
  Console.Write(&quot;  &quot;);
  /*
    delegates pass their arguments by value, e.g., make a copy,
    so plus_one will not modify the original enumerable element.
    The next demo shows how to do that.
  */
  Action&lt;double&gt; plus_one = x =&gt; Console.Write(&quot;{0} &quot;,x += 1.0);
  /* Action&lt;T&gt; is delegate with no return and input T */
  GenericForEach&lt;double&gt;(ld, plus_one);
  Console.WriteLine(&quot;&#92;n&quot;);
  /*
    verify that the list was not modified by uncommenting
    the lines below
  */
  // GenericEnumerator&lt;double&gt;(ld);
  // Console.WriteLine(&quot;&#92;n&quot;);
  /*
    Lambdas can capture local variables, and those can be
    modified, as shown below.
  */
  List&lt;double&gt; modLd = new List&lt;double&gt;();
  /* using captured variable modLd */
  Action&lt;double&gt; add_one = item =&gt; { modLd.Add(item + 1.0); };
  /*
    using ld defined earlier, add_one adds ld item + 1 to modLd
    with function call below
  */
  GenericForEach&lt;double&gt;(ld, add_one);
  /* modLd now modified */
  Display.ShowOp(&quot;original list&quot;);
  GenericEnumerator&lt;double&gt;(ld);
  Console.WriteLine();
  Display.ShowOp(&quot;modified list using lambda capture&quot;);
  GenericEnumerator&lt;double&gt;(modLd);
  Console.WriteLine();

  /* repeat same demonstration with BasicPoint */
  Display.ShowOp(&quot;original BasicPoint&quot;);
  var pb = new BasicPoint&lt;double&gt;{ 1.0, 2.5, 4.0 };
  GenericEnumerator&lt;double&gt;(pb);
  Console.WriteLine();
  /*
    we need a new lambda because we are capturing a BasicPoint,
    not a List
  */
  var mpb = new BasicPoint&lt;double&gt;();
  Action&lt;double&gt; add_one_point = item =&gt; { mpb.Add(item + 1.0); };
  GenericForEach&lt;double&gt;(pb, add_one_point);
  Display.ShowOp(&quot;modified BasicPoint using lambda capture&quot;);
  GenericEnumerator&lt;double&gt;(mpb);
  Console.WriteLine();
  Display.ShowOp(&quot;modified BasicPoint Show(name)&quot;);
  mpb.Show(&quot;mpb&quot;);
}</code></pre>
              </div>
            </first-item>
            <splitter-bar id="foreach-seperator"></splitter-bar>
            <second-item id="foreach-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('foreach-first')">
                <pre style="width:200em;"><code class="language-shell">












--------------------------------------------------
  GenericForEach<T>(
    IEnumerable<T> enm, Action<T> lambda
  )
--------------------------------------------------


--- Add 1.0 to items of List<double> ---
  2 3.25 4.5 3.25 2






























--- original list ---
  1, 2.25, 3.5, 2.25, 1

--- modified list using lambda capture ---
  2, 3.25, 4.5, 3.25, 2



--- original BasicPoint ---
  1, 2.5, 4









--- modified BasicPoint using lambda capture ---
  2, 3.5, 5

--- modified BasicPoint Show(name) ---
  mpb {
    2, 3.5, 5
    7/16/2024 3:21:16 PM
  }

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="genmod">2.3.4 Generic Modifier</h3>
        <t-b>

        </t-b>
        <t-b>
          The right panel is also pre styling with terminal colors, intended for output display.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="genmod-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('genmod-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------------
  IEnumerable&lt;T&gt; 
  GenericModifier&lt;T&gt;(IEnumerable&lt;T&gt; enm, Func&lt;T,T&gt; lambda)
  - return modified IEnumerable&lt;T&gt; transformed by 
    lambda Func&lt;T,T&gt;
  - uses Linq Select
*/
static IEnumerable&lt;T&gt; GenericModifier&lt;T&gt;(
  &nbsp;&nbsp;IEnumerable&lt;T&gt; enm, Func&lt;T,T&gt; lambda) 
{
  /*
    lambda makes copies of input enumerable&apos;s elements,
    so lambda&apos;s modifications don&apos;t affect input.
    Instead we make new modified collection using
    Linq Select method.
  */
  return enm.Select(lambda);
}
static void ExecuteGenericModifier() {

  Display.ShowNote(
    &quot;  IEnumerable&lt;T&gt; 
    &nbsp;&nbsp;&nbsp;GenericModifier&lt;T&gt;(&#92;n    Ienumerable&lt;T&gt; enm, Func&lt;T,T&gt; lambda&#92;n  )&quot;
  );
  Console.WriteLine();

  Display.ShowOp(&quot;GenericModifier for List&lt;int&gt; with plus_one&quot;);
  /*-- original --*/
  List&lt;int&gt; li = new List&lt;int&gt;{1, 2, 3, 4, 3, 2};
  Console.WriteLine(&quot;Original:&quot;);
  GenericEnumerator&lt;int&gt;(li);
  /*-- modified --*/
  Func&lt;int, int&gt; plus_one = x =&gt; x+1;
  /* Func&lt;U,V&gt; is a delegate with input U and output V */
  var coll = GenericModifier&lt;int&gt;(li, plus_one);  // modify
  Console.WriteLine(&quot;Modified:&quot;);
  GenericEnumerator&lt;int&gt;(coll);                   // display
  Console.WriteLine();

  Display.ShowOp(&quot;GenericModifier for array&lt;double&gt; with square&quot;);
  /*-- original --*/
  double[] da = new double[]{ 1.0, 2.5, 3.0, 4.5 };
  Console.WriteLine(&quot;Original:&quot;);
  GenericEnumerator&lt;double&gt;(da);
  /*-- modified --*/
  Func&lt;double,double&gt; square = x =&gt; x*x;
  var coll2 = GenericModifier&lt;double&gt;(da, square);  // modify
  Console.WriteLine(&quot;Modified:&quot;);
  GenericEnumerator&lt;double&gt;(coll2);                 // display
  Console.WriteLine();

  Display.ShowOp(&quot;GenericModifier for BasicPoint&lt;double&gt; with square&quot;);
  /*-- original --*/
  var pm = new BasicPoint&lt;double&gt; { 1.0, 2.5, -5.0, 7.5 };
  Console.WriteLine(&quot;Original:&quot;);
  GenericEnumerator&lt;double&gt;(pm);
  /*-- modified --*/
  Console.WriteLine(&quot;Modified:&quot;);
  var pm2 = GenericModifier&lt;double&gt;(pm, square);  // modify
  GenericEnumerator&lt;double&gt;(pm2);                 // display
  Console.WriteLine();
}</code></pre>
              </div>
            </first-item>
            <splitter-bar id="genmod-seperator"></splitter-bar>
            <second-item id="genmod-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('genmod-first')">
                <pre style="width:200em;"><code class="language-shell">



















--------------------------------------------------
  IEnumerable<T> GenericModifier<T>(
    Ienumerable<T> enm, Func<T,T> lambda
  )
--------------------------------------------------

--- GenericModifier for List&lt;int&gt; with plus_one ---
Original:
  1, 2, 3, 4, 3, 2
Modified:
  2, 3, 4, 5, 4, 3








--- GenericModifier for array&lt;double&gt; with square ---
Original:
  1, 2.5, 3, 4.5
Modified:
  1, 6.25, 9, 20.25







--- GenericModifier for BasicPoint&lt;double&gt; with square ---
Original:
  1, 2.5, -5, 7.5
Modified:
  1, 6.25, 25, 56.25

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>


        <h3 id="analysis">2.4 Analysis Library</h3>
        <t-b>
          A number of analysis and display methods have been used throughout the examples above.
          All of them have been discussed in earlier Bits in this sequence, so we do not show
          them by default.
        </t-b>
        <t-b>
          They are here so that you can easily find their definitions if you need that information
          to understand example code.
        </t-b>
        <details>
          <summary style="border:2px solid var(--dark);">Analysis and Display Functions</summary>
          <t-b>
            The Analysis library provides 14 methods, of which 9 are generic. They illustrate
            the power of generics to provide reusable, configurable code.
          </t-b>
          <div class="blockSingle" style="padding:0em;">
            <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
            <splitter-container id="container">
              <first-item id="analysis-first" style="width:60%;">
                <div class="codewrap" onclick="cbubbleup('analysis-first')">
                  <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  Analysis.cs
  - provides several type analysis and display methods in the
    class Display
*/
using System;
using System.Collections;
using System.Collections.Generic;     // IEnumerable&lt;T&gt;, List&lt;T&gt;
using System.Linq;                    // IEnumerable&lt;T&gt;.ToArray
using System.Text;                    // StringBuilder
using System.Reflection;
using System.Reflection.Emit;         // managed size
using System.Runtime.InteropServices; // GCHandle

namespace Analysis {
  /*----------------------------------------------------------
    IShow interface allows analysis functions to operate on
    instances of any class that implements it.
    - See ShowTypeShowable&lt;T&gt;(T t, ...), below.
  */
  public interface IShow {
    void Show(string name, int Width = 5, int Left = 2);   // show instance state as rows of elements
    int Length { get; }       // total number of elements
    int Width { get; set; }   // number of elements per row
    int Left { get; set; }    // offset from terminal Left
    int Indent {get; set; }   // element indent from braces
  }
  /*-----------------------------------------------------------------------
    Collection of static functions that present information about types
    and data values on the terminal line.
  */
  public class Display {
    public static String Spaces(int i) {
      return new String(' ', i);
    }
    public static bool IsAssociativeColl(IEnumerable coll) {
      return coll is IDictionary;
    }
    /*-------------------------------------------------
      Show static type with some formatting adjustments
      and name at callsite.
    */
    public static void ShowType&lt;T&gt;(T t, string nm) {
      Type tt = t!.GetType();
      string tnm = tt.Name;
      if(tt.IsGenericType) {
        if(tnm.Length &gt; 1) {
          tnm = tnm.Remove(tnm.Length - 2) + &quot;&lt;T&gt;&quot;;
        }
      }
      Console.Write(&quot;{0}: {1}, &quot;, nm, tnm);
      int size = GetManagedSize(tt);
      Console.Write(&quot;size: {0}, &quot;, size);
      if (tt.IsValueType) {
        Console.WriteLine(&quot;value type&quot;);
      }
      else {
        Console.WriteLine(&quot;reference type&quot;);
      }
    }
    /*-------------------------------------------------
      Display information about the type of any scalar type.
      - scalar types are those with a single value like:
          int, double, string, ...
      - This function directly uses only simple reflection
    */
    public static void ShowTypeScalar&lt;T&gt;(
      T t, string nm, string suffix = &quot;&quot;
    )
    {
      ShowType(t, nm);
      Console.WriteLine(&quot;value: &#92;&quot;{0}&#92;&quot;{1}&quot;, t, suffix);
    }
    /*-------------------------------------------------
      Show type information for any type that implements
      IEnumerable&lt;T&gt; interface.
    */
    public static void ShowTypeEnum&lt;T&gt; (
    IEnumerable&lt;T&gt; t, string nm, int w = 5, string suffix = &quot;&quot;
    )
    {
      Type tt = t!.GetType();
      string tnm = tt.Name;
      if(tt.IsGenericType) {
        if(tnm.Length &gt; 1) {
          tnm = tnm.Remove(tnm.Length - 2);
          if(IsAssociativeColl(t)) {
            tnm += &quot;&lt;K,V&gt;&quot;;
          }
          else {
            tnm += &quot;&lt;T&gt;&quot;;
          }
        }
      }
      Console.Write(&quot;{0}: {1}, &quot;, nm, tnm);
      int size = GetManagedSize(tt);
      Console.Write(&quot;size: {0}, &quot;, size);
      if (tt.IsValueType) {
        Console.WriteLine(&quot;value type&quot;);
      }
      else {
        Console.WriteLine(&quot;reference type&quot;);
      }
      Console.WriteLine(&quot;value:&#92;n{0}{1} {{&quot;, &quot;  &quot;, nm);
      /*
        beautify value list into rows of w elements
        indented by 4 spaces
      */
      string tmp = FoldArray(t.ToArray(), w, 4);
      Console.Write(tmp);
      Console.WriteLine(&quot;&#92;n  }&quot;);
      Console.Write(suffix);
    }
    /*-------------------------------------------------
      Show type information for any type that implements
      the IShow interface
    */
    public static void ShowTypeShowable&lt;T&gt;(
      T t, string nm, string suffix=&quot;&quot;
    )
    where T:IShow
    {
      ShowType(t, nm);
      Console.WriteLine(&quot;value:&quot;);
      t.Show(nm);     // guaranteed by IShow implementation
      Console.Write(suffix);
    }
    /*-------------------------------------------------
      Provides name of caller, nm, as label for IShow() information.
      - works for all Showable instances
    */
    public static void ShowLabeledObject&lt;T&gt;(
      T t, string nm
    ) where T:IShow {
      // Console.Write(nm);
      t.Show(nm);
    }
    /*-------------------------------------------------
      Provides name of caller, nm, as label for value.
      - works for all T with ToString.
    */
    public static void DisplayLabeledObject&lt;T&gt;(T t, string nm) {
      Console.WriteLine(&quot;{0}: {1}&quot;, nm, t!.ToString());
    }
    /*-------------------------------------------------
      create string of count spaces, used to offset output
    */
    public static string Indent(int count) {
      StringBuilder sb = new StringBuilder();
      sb.Append(' ', count);
      return sb.ToString();
    }
    /*-------------------------------------------------
      Truncate string to length of N, but only if
      its length is greater than N
    */
    public static string truncate(int N, string bigStr) {
      if(bigStr.Length &lt;= N) {
        return bigStr;
      }
      StringBuilder sb =  new StringBuilder();
      sb.Append(bigStr);
      sb.Length = N;  // move back pointer to desired length
      return sb.ToString();
    }
    /*-------------------------------------------------
      fold array elements into rows of w elements
    */
    public static string FoldArray&lt;T&gt;(T[] arr, int w, int Left) {
      StringBuilder tmp = new StringBuilder();
      tmp.Append(Indent(Left));
      for(int i=0; i&lt; arr.Length; ++i) {
        tmp.Append(arr[i]!.ToString());
        tmp.Append(&quot;, &quot;);
        if((i+1) % w == 0 && i != arr.Length - 1) {
          tmp.Append(&quot;&#92;n&quot;);
          tmp.Append(Indent(Left));
        }
      }
      if(tmp.Length &gt; 1) {
        tmp.Length -= 2;  // don't return last comma and space
      }
      return tmp.ToString();
    }
    /*-------------------------------------------------
      do t1 and t2 share the same address?
    */
    public static void IsSameObj&lt;T&gt;(
      T t1, String n1, T t2, String n2, string suffix = &quot;&quot;
    ) {
      if(ReferenceEquals(t1, t2)) {
        Console.WriteLine(
          &quot;{0} is same object as {1}{2}&quot;, n1, n2, suffix
        );
    }
      else {
        Console.WriteLine(
        &quot;{0} is not same object as {1}{2}&quot;, n1, n2, suffix);
      }
    }
    /*-------------------------------------------------
      Beware, two distinct objects may have same hashcode.
      - Not used in this demo for that reason.
    */
    public static void showIdent&lt;T&gt;(
      T t, String n, string suffix = &quot;&quot;
    ) {
      int id = t!.GetHashCode();
      Console.WriteLine(&quot;{0}, {1}{2}&quot;, n, id, suffix);
    }
    /*-------------------------------------------------
      Display function call or operation to help turn
      output data into information
    */
    public static void ShowOp(string op, string suffix = &quot;&quot;) {
      Console.WriteLine(&quot;--- {0} ---{1}&quot;, op, suffix);
    }
    public static void print(String s = &quot;&quot;) {
      Console.Write(s);
    }
    public static void println(String s = &quot;&quot;) {
      Console.WriteLine(s);
    }
    public static void Println(String s) {
      Console.WriteLine(s);
    }
    /*-------------------------------------------------
      Emphasize text with borders
    */
    public static void ShowNote(string s, int n=60, string suffix = &quot;&quot;) {
      string line = new string('-', n);
      Console.WriteLine(
        &quot;--------------------------------------------------&quot;
      );
      Console.WriteLine(&quot;{0}&quot;, s);
      Console.WriteLine(
        &quot;--------------------------------------------------{0}&quot;,
        suffix
      );
    }
    /*-------------------------------------------------
      Surround note with empty lines
    */
    public static void ShowLabel(string s) {
      Console.WriteLine();
      ShowNote(s);
      Console.WriteLine();
    }
  }
}
</code></pre>
                </div>
              </first-item>
              <splitter-bar id="analysis-seperator"></splitter-bar>
              <second-item id="analysis-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('analysis-first')">
                <div class="textwrap noflow">
                  <h3>Generic Methods:</h3>
                  <t-b>
                    C# does not support free functions. Instead,<br />
                    methods are defined in a class.
                  </t-b>
                  <t-b>
                    However, static methods of classes play the<br />
                    same role as free functions in other languages.
                  </t-b>
                  <div style="height:20em;"></div>
                  <span style="font-size:1.75em; font-weight:bold;">&lArr;</span> <c-s>interface IShow:</c-s><br />
                  <t-b>
                    Allows function:
                    <div class="inset">
                      <c-s>ShowTypeShowable&lt;T&gt;(T t, ...)</c-s>
                    </div>
                    to accept any type <c-s>T</c-s> that implements <c-s>IShow</c-s>.
                  </t-b>
                  <t-b>
                    Generic functions provide abstraction over<br />
                    types that improves developer productivity,<br />
                    code readability and maintainability.
                  </t-b>
                  <div style="height:72em;"></div>
                  <span style="font-size:1.75em; font-weight:bold;">&lArr;</span>
                  <c-s>ShowTypeEnum&lt;T&gt;(IEnumerable&lt;T&gt; t, ...)</c-s><br />
                  <t-b>
                    Can display any <c-s>IEnumerable&lt;T&gt;</c-s> type, e.g.<br />
                    <c-s>Array&lt;T&gt;, List&lt;T&gt;, Point&lt;T&gt;</c-s>.
                  </t-b>
                  <div style="height:56em;"></div>
                  <span style="font-size:1.75em; font-weight:bold;">&lArr;</span> <c-s>ShowTypeShowable(T t, ...)</c-s><br />
                </div>
              </second-item>
            </splitter-container>
          </div>
          <div style="height:0.75em;"></div>
        </details>
        <h3 id="complex">2.4.1 Complex Generic Methods</h3>
        <t-b>
          The dropdown below provides code for interesting generic methods, some of which use advanced
          techniques. They are useful know, but none are used in this demonstration.
        </t-b>
        <details>
          <summary style="border:2px solid var(--dark);">Complex Methods</summary>
          <div class="blockSingle" style="padding:0em;">
            <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
            <splitter-container id="container">
              <first-item id="complex-first" style="width:60%;">
                <div class="codewrap" onclick="cbubbleup('complex-first')">
                  <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------------------
  All methods below this are not part of this presentation
  - may use advanced code techniques
  - may be experimental
  - may simply be alternate designs that could be
    useful in other applications
-----------------------------------------------------------*/
/*
  Show fields and methods for either reference or value types
  using reflection
*/
// https://stackoverflow.com/questions/7613782/iterating-through-struct-members
public static void iterate&lt;T&gt;(T t) /*where T:new()*/ {
  Console.WriteLine(&quot;fields:&quot;);
  foreach(
    var field in typeof(T).GetFields(
      BindingFlags.Instance |
      BindingFlags.NonPublic |
      BindingFlags.Public
    )
  ) {
    Console.WriteLine(
      &quot;  {0} = {1}&quot;, field.Name, field.GetValue(t)
    );
  }
  Console.WriteLine(&quot;methods:&quot;);
  foreach(
    var method in typeof(T).GetMethods(
      BindingFlags.Instance | BindingFlags.Public
    )
  ) {
    Console.WriteLine(
      &quot;  {0}&quot;, method.Name
    );
  }
}
/*-----------------------------------------------------
Build string representation of array of type T
-----------------------------------------------------*/
public static string ToStringRepArray&lt;T&gt;(T[] arr) {
  StringBuilder sb = new StringBuilder();
  sb.Append(&quot;{ &quot;);
  bool first = true;
  foreach(T item in arr) {
    if(item == null) {
      break;
    }
    if(first) {
      sb.Append(item.ToString());
      first = false;
    }
    else {
      sb.AppendFormat(&quot;, {0}&quot;, item);
    }
  }
  sb.Append(&quot; }&#92;n&quot;);
  return sb.ToString();
}
/*-----------------------------------------------------
Build string representation of IEnumerable
collection T&lt;U&gt;. Works for array too.
-----------------------------------------------------*/
public static string ToStringRepIEnumerable&lt;T,U&gt;(T enu)
  where T:IEnumerable&lt;U&gt;
{
  StringBuilder sb = new StringBuilder();
  sb.Append(&quot;[ &quot;);
  bool first = true;
  foreach(U item in enu) {
    if(item == null) {
      break;
    }
    if(first) {
      sb.Append(item.ToString());
      first = false;
    }
    else {
      sb.AppendFormat(&quot;, {0}&quot;, item);
    }
  }
  sb.Append(&quot; ]&#92;n&quot;);
  return sb.ToString();
}
/*-----------------------------------------------------
Direct implementation of enumerating associative
collection.  This can also be done with
ToStringRepIEnumerable&lt;Dict,KVPair&gt;(dict).
-----------------------------------------------------*/
public static string ToStringRepAssocCont&lt;Dict,Key,Value&gt;(Dict assoc)
  where Dict:IDictionary&lt;Key,Value&gt;
{
  StringBuilder sb = new StringBuilder();
  sb.Append(&quot;{ &quot;);
  bool first = true;
  foreach(var item in assoc) {
    if(first) {
      var sf = String.Format(&quot;{{{0}, {1}}}&quot;, item.Key, item.Value);
      sb.Append(sf);
      first = false;
    }
    else {
      sb.AppendFormat(&quot;, {{{0}, {1}}}&quot;, item.Key, item.Value);
    }
  }
  sb.Append(&quot; }&#92;n&quot;);
  return sb.ToString();
}
/*-- move this to functions --*/
static void DemoPassValAndRef() {
  Display.ShowNote(&quot;Pass by value&quot;, 60, &quot;&#92;n&quot;);
  double d = 3.1415927;
  Pass_by_value&lt;double&gt;(d, &quot;d&quot;);
  TestForNullValue(d, &quot;d&quot;);

  List&lt;int&gt; li = new List&lt;int&gt;{ 1, 2, 3, 2, 1 };
  Pass_by_value&lt;List&lt;int&gt;&gt;(li, &quot;li&quot;);
  TestForNullValue(li, &quot;li&quot;);
}
public static string GetTypeString&lt;T&gt;(T t, String nm, String suffix = &quot;&quot;)
{
  /*-- t! asserts that t is not null --*/
  Type tt = t!.GetType();
  string typeInfo = String.Format(&quot;{0}: Type: {1}&#92;n&quot;, nm, tt.Name);
  int size = GetManagedSize(tt);
  string instanceInfo = String.Format(&quot;value: {0}&#92;nsize: {1}{2}&quot;, t, size, suffix);
  return typeInfo + instanceInfo;
}
static unsafe void Pass_by_value&lt;T&gt;(T? t, string nm) {
  string ts = GetTypeString(t, nm);
  Console.WriteLine(ts);
  /*
    Suppresses warning about taking address of managed type.
    The pointer is used only to show the address of ptr
    as part of analysis of copy operations.
  */
  #pragma warning disable 8500
  string addrd = ToStringAddress&lt;T&gt;(&t);
  #pragma warning restore 8500
  Console.WriteLine(&quot;{0}: {1}&quot;, nm, addrd);
  t = default(T);
  /*
    caller sees this change if and only if T is a reference type
    in which case t is null.
  */
}
#pragma warning disable 8500
public static unsafe string ToStringAddress&lt;T&gt;(T* ptr) {
  if(ptr == null) {
    return &quot;&quot;;
  }
  IntPtr addr = (IntPtr)ptr;
  string addrstr = string.Format(&quot;address: 0x&quot; + addr.ToString(&quot;x&quot;));
  return addrstr;
}
#pragma warning restore 8500
/*-- extract address of reference instance in managed heap --*/
public static string ToStringAddressFromHandle&lt;T&gt;(T t) {
  string addrstr = &quot;for handle&#92;n&quot;;
  try {
    GCHandle handle = GCHandle.Alloc(t, GCHandleType.Pinned);
    IntPtr address = handle.AddrOfPinnedObject();
    addrstr = &quot;address: &quot; + String.Format(&quot;0x&quot; + address.ToString(&quot;x&quot;));
    handle.Free();
    return addrstr + &quot;&#92;n&quot;;
  }
  catch {
    Console.WriteLine(&quot;GCHandle exception thrown&quot;);
  }
  return addrstr;
}
static void TestForNullValue&lt;T&gt;(T? t, string nm) {
  if(t == null) {
    Console.WriteLine(nm + &quot; is null&quot;);
  }
  else {
    Console.WriteLine(nm + &quot; is {0}&quot;, t);
  }
}
static void DemoPrimitives() {
  Display.ShowNote(
    &quot;Examples of creation and display of Primitive Types&quot;,
    60
  );
  short s = 123;
  Display.ShowTypeScalar(s, &quot;s&quot;, &quot;&#92;n&quot;);
  long l = 12345;
  Display.ShowTypeScalar(l, &quot;l&quot;, &quot;&#92;n&quot;);
  float f = 3.1415927f;
  Display.ShowTypeScalar(f, &quot;f&quot;, &quot;&#92;n&quot;);
  double d = 3.1415927;
  Display.ShowTypeScalar(d, &quot;d&quot;, &quot;&#92;n&quot;);
  int[] arr = new int[]{ 4, 3, 2, 1, 0, -1};
  Display.ShowTypeScalar(arr, &quot;arr&quot;);
}
/*-------------------------------------------------
  Build string of comma separated values from
  Enumerable collection
  - no longer used here, but will be useful so kept
*/
// https://stackoverflow.com/questions/330493/join-collection-of-objects-into-comma-separated-string
public static string ToCSV&lt;T&gt;(IEnumerable&lt;T&gt; coll) {
  StringBuilder sb = new StringBuilder();
  foreach(T elem in coll) {
    sb.Append(elem!.ToString()).Append(&quot;, &quot;);
  }
  return sb.ToString(0, sb.Length - 2);
}
/*-------------------------------------------------
  Returns value of T for IEnumerable&lt;T&gt; at runtime.
  Needed for some functions that operate on generic
  collections.
  - at this time, not used in this demo
*/
// https://www.codeproject.com/Tips/5267157/How-To-Get-A-Collection-Element-Type-Using-Reflect
public static Type? GetTypeOfCollection(Object coll) {
  Type type = (coll).GetType();
  var etype = typeof(IEnumerable&lt;&gt;);
  foreach (var bt in type.GetInterfaces()) {
    if (bt.IsGenericType && bt.GetGenericTypeDefinition() == etype) {
      return (bt.GetGenericArguments()[0]);
    }
  }
  return null;
}
/*----------------------------------------------------------------
  This method uses advanced relection

  - GetMangedSize(Type type) is function that returns the size of
  value types and handles, used to help discover how things work.
  It is placed here because it uses advanced techniques that
  will eventually be covered elsewhere in this site.  Knowing
  how it works is not essential for the things we are examining
  in this demo.
*/
// https://stackoverflow.com/questions/8173239/c-getting-size-of-a-value-type-variable-at-runtime/8173293#8173293
public static int GetManagedSize(Type type)
{
  // all this just to invoke one opcode with no arguments!
  var method = new DynamicMethod(
    &quot;GetManagedSizeImpl&quot;, typeof(uint), new Type[0],
    typeof(TypeExtensions), false
  );

  ILGenerator gen = method.GetILGenerator();
  gen.Emit(OpCodes.Sizeof, type);
  gen.Emit(OpCodes.Ret);

  var func = (Func&lt;uint&gt;)method.CreateDelegate(typeof(Func&lt;uint&gt;));
  return checked((int)func());
}
</code></pre>
                </div>
              </first-item>
              <splitter-bar id="complex-seperator"></splitter-bar>
              <second-item id="complex-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('complex-first')">
                <div class="textwrap noflow">
                  <t-b class="indents">
                    These functions provide additional functionality<br />
                    that will be useful in other programs, but are<br />
                    not used in this demonstration.
                  </t-b>
                  <t-b>
                    Some of them use advanced reflection tech-<br />
                    niques or other designs that are interesting.
                  </t-b>
                </div>
              </second-item>
            </splitter-container>
          </div>
        </details>
        <div style="height:0.75em;"></div>

        <h3 id="structure">2.5 Program Structure</h3>
        <t-b class="indents">
          The code below, Program.cs, imports libraries: Points and Analysis.
          Using those facilities it orchestrates all the demonstrations shown here
          by calling in <c-s>Main</c-s> methods developed above <c-s>Main</c-s>.
        </t-b>
        <t-b>
          Details
          of those methods have been elided to show the structure of this program.
          All of the elided code has already been shown in the code blocks above.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="structure-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('structure-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  Cs_Iter::Program.cs
  - Demonstrates IEnumerable interface and iteration
*/
using System;
using System.Collections;
using System.Collections.Generic;   // IEnumerable&lt;T&gt;, List&lt;T&gt;
using System.Linq;                  // IEnumerable&lt;T&gt;.ToArray, select
using System.Text;                  // StringBuilder
using Points;                       // defined in Points.cs
using Analysis;                     // defined in Analysis.cs

/*-----------------------------------------------
  Note:
  Find all Bits code, including this in
  https://github.com/JimFawcett/Bits
  You can clone the repo from this link.
-----------------------------------------------*/
/*
  This demo uses Indexing and Enumerator to iterate
  through std collections:
  - String, List&lt;T&gt;, Dictionary&lt;K,V&gt;
  and through user-defined type:
  - BasicPoint&lt;T&gt;
*/
namespace CSharpIter
{
  using Analysis;

  class Program
  {
    /*-----------------------------------------------------
      Enumerate standard library types
    */
    static void EnumStdTypes() {
      /* code elided */
    }
    /*-----------------------------------------------------
      Enumerate Point&lt;T&gt;
      - all of the examples here work with either
        BasicPoint&lt;T&gt; or Point&lt;T&gt;
    */
    static void EnumPoint() {
      /* code elided */
    }
    /*-----------------------------------------------------
      void GenericIndexer&lt;T&gt;(List&lt;T&gt;)
      - Display list items with indexing
      - works for all sequential indexable containers
    */
    static void GenericIndexer&lt;C, T&gt;(C coll)
       where C:IEnumerable, ICollection&lt;T&gt;, IList&lt;T&gt;
    {
      /* code elided */
    }
    static void executeGenericIndexer() {
      /* code elided */
    }
    /*-----------------------------------------------------
      void GenericEnumerator&lt;T&gt;(IEnumerable&lt;T&gt; enm)
      - Display list items with enumerator
    */
    static void GenericEnumerator&lt;T&gt;(IEnumerable&lt;T&gt; enm) {
      /* code elided */
    }
    static void executeGenericEnumerator() {
      /* code elided */
    }
    /*-----------------------------------------------------
      void GenericForEach&lt;T&gt;(IEnumerable&lt;T&gt; enm)
      - Display list items with foreach
    */
    static void GenericForEach&lt;T&gt;(IEnumerable&lt;T&gt; enm, Action&lt;T&gt; lambda) {
      /* code elided */
    }
    static void ExecuteGenericForEach() {
      /* code elided */
    }
    /*-----------------------------------------------------
      IEnumerable&lt;T&gt; GenericModifier&lt;T&gt;(IEnumerable&lt;T&gt; enm, Func&lt;T,T&gt; lambda)
      - return modified IEnumerable&lt;T&gt; transformed by lambda Func&lt;T,T&gt;
      - uses Linq Select
    */
    static IEnumerable&lt;T&gt; GenericModifier&lt;T&gt;(IEnumerable&lt;T&gt; enm, Func&lt;T,T&gt; lambda) {
      /* code elided */
    }
    static void ExecuteGenericModifier() {
      /* code elided */
    }
    /*-----------------------------------------------------
      Begin demonstration
    */
    static void Main(string[] args)
    {
      Display.ShowLabel(&quot; Demonstrate C# iteration&quot;);

      EnumStdTypes();
      EnumPoint();
      executeListIndexer();
      executeGenericIndexer();
      executeGenericEnumerator();
      ExecuteGenericForEach();
      ExecuteGenericModifier();

      Console.WriteLine(&quot;&#92;nThat's all Folks!&#92;n&quot;);
    }
  }
}</code></pre>
              </div>
            </first-item>
            <splitter-bar id="structure-seperator"></splitter-bar>
            <second-item id="structure-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('structure-first')">
              <div class="textwrap noflow">
                <h3>Program</h3>
                <t-b class="indents">
                  This code block shows how Program.cs imple-<br />
                  ments all of the demonstrations in this<br />
                  Generic C# Bit.
                </t-b>
                <t-b>
                  Code details, shown elsewhere, have been<br />
                  elided to show clearly the structure of<br />
                  this demonstration.
                </t-b>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>


        <div style="height:0.25em;"></div>
        <h3 id="build">3.0 Build</h3>
        <div style="border:2px solid var(--dark); padding: 0em 0.25em; width:max-content; max-width:100%;">
          <pre style="width:max-content;"><code class="language-term">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Generic
&gt; dotnet build
MSBuild version 17.5.1+f6fdcf537 for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
  Cs_Objects -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Generic&#92;bin&#92;Debug&#92;net7.0&#92;Cs_Ob  
  jects.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.79
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Generic
          </code></pre>
        </div>
        <h3 id="ide">4.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for CSharp\Cs_Generic.
        </t-b>
        <photosizer-block src="pictures/CSharp_Generic_Debug.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - C# Generics</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/LaunchJSON_CSharp_Objects.JPG" width="800" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 2. C# Launch.JSON</span>
  </photosizer-block>
  <photosizer-block src="pictures/VS_Code_Debugging_CSharp_Objects.JPG" width="800" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 3. Debugging C# Objects</span>
  </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">4.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://www.tutorialspoint.com/csharp/csharp_generics.htm">C# Generics - tutorialspoint</a>
            </td>
            <td>
              Basic syntax with examples
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://www.w3schools.com/cs/index.php">C# Tutorial - w3schools</a>
            </td>
            <td>
              Interactive examples
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/">C# Reference - Microsoft</a>
            </td>
            <td>
              Relatively complete informal language reference
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <!-- <page-TOC id="pages" style="display:none;">
      </page-TOC> -->
</content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#syn">synopsis</a>
        <a href="#notes">notes</a>
        <a href="#enumeration">enumeration</a>
        <a href="#relatedinterf">related interfaces</a>
        <a href="#lambdas">lambdas</a>
        <a href="#delegates">delegates</a>
        <a href="#stddel">std delegates</a>
        <a href="#code">src code</a>
        <a href="#stdlib">stdlib types</a>
        <a href="#userdef">user-defined types</a>
        <a href="#pointdef">point def</a>
        <a href="#pointdemo">point demo</a>
        <a href="#genfunc">generic functions</a>
        <a href="#indexer">generic indexer</a>
        <a href="#enumer">generic enumeration</a>
        <a href="#foreach">generic foreach</a>
        <a href="#genmod">generic modifier</a>
        <a href="#analysis">analysis</a>
        <a href="#complex">complex generic funcs</a>
        <a href="#structure">structure</a>
        <a href="#build">build</a>
        <a href="#ide">VS Code view</a>
        <a href="#refs">references</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/CSharpBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 6, 10);
  </script>
  <script>
    onLoadSplitter("stdlib");
    onLoadSplitter("pointdef");
    onLoadSplitter("pointdemo");
    onLoadSplitter("indexer");
    onLoadSplitter("enumer");
    onLoadSplitter("foreach");
    onLoadSplitter("genmod");
    onLoadSplitter("analysis");
    onLoadSplitter("complex");
    onLoadSplitter("structure");
  </script>
</body>
</html>
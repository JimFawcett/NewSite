<!DOCTYPE html>
<html id="top">
<!--
  RustBites_Enums.html
-->
<head>
  <title>Rust Enums</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    td {
      font-size: 0.9rem;
      vertical-align: top;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_Enums.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/10/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Enums</h2>
        <h4 id="subtitle" class="indent">
          Option&lt;T&gt;, Result&lt;T,E&gt;, custom        
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>
    </header>
        <a id="intro"></a>
        <h3>1.0 - Introduction</h2>
        <t-b>
          Rust error handling is based on two things: enumerations and matching. Rust&apos;s enumerations are more
          powerful than those of C++ and C#.  Each element of the enumeration may wrap some type, as shown below.
          <inset>
            <c-s>enum Option&lt;T&gt; { Some(T), None, }</c-s><br />
          </inset>
          Option is used when a value cannot be initialized at compile-time or a function that returns a value for
          some paths but may have nothing to return for another path, e.g. return the first occurence of ...
        </t-b>
        <t-b>
          For cases where that indeterminacy is caused by possible errors, Rust provides the Result type:
          <inset>
            <c-s>enum Result&lt;T, E&gt; { Ok(T), Err(E), }</c-s>
          </inset>
          Result returns one of either of two types of values, a valid return value or a specific error value, perhaps
          a string or error code.  <c-s>Option</c-s>s and <c-s>Return</c-s>s are discussed in detail, with examples, in
          the two following <a target="_blank" href="RustBites_ErrHnd.html">Error Handling</a> and <a target="_blank" href="RustBites_Options.html">Options</a>
          Rust Bites.
        </t-b>
        <a id="custom"></a>
        <h3>2.0 - Custom Enumerations</h2>
        <t-b>
          Often in code we use enums defined in the standard libraries.  However, it can be quite useful to develop
          custom enumerations like the one shown below.
        </t-b>
        <t-b>
          This example shows an
          Event&lt;T&gt; enumeration that represents different levels of events, and wraps information
          about the event inside the event item except for the NoEvent item. This example shows how to
          write code to wrap and unwrap values from enumeration items.
        </t-b>
        <div style="height:0.25rem;"></div>
        <t-b>
          <div>
            <defn-OuterBlock>
              <defn-block>
                <defn-head>Custom Enumeration Example</defn-head>
                <defn-code>
#![allow(unused_variables)]

/*-----------------------------------------------------
  The generic parameter T represents some value
  associated with events, perhaps a name String
  or id number.
*/
#[derive(Debug, Clone)]
enum Event&lt;T&gt; {
  Normal(T), Warning(T), Critical(T), NoEvent
}
impl&lt;T&gt; Event&lt;T&gt; {
  fn unwrap(&amp;self) -&gt; &amp;T {
    if let Event::Normal(ev) = self{ ev }
    else if let Event::Warning(ev) = self{ev}
    else if let Event::Critical(ev) = self{ev}
    else { panic!() }
  }
}

use Event::*;

fn main() {
  /*-- numbers are event ids --*/
  let e1: Event&lt;u8&gt; = Event::&lt;u8&gt;::Normal(1);
  let e2 = Warning(2);
  let e3 = Critical(3);
  let e4: Event&lt;u8&gt; = NoEvent;

  /*-- match works like switch stmt on steriods --*/

  match e3 {
    Normal(ev) =&gt;
      print!("\n  event {} is Normal", ev),
    Warning(ev) =&gt;
      print!("\n  event {} is Warning", ev),
    Critical(ev) =&gt;
      print!("\n  event {} is Critical!", ev),
    NoEvent =&gt; print!("\n  no events occurred"),
  }

  /*-------------------------------------------------
    without the clone() operation below e2 would
    move into e and become invalid for future
    operations.
  */
  let e = e2.clone();

  /*-------------------------------------------------
    if let statements use "=" as match operator
  */

  if let Warning(ev) = e {
    print!("\n  event {} is Warning", ev);
  }

  /*-- next stmt panics if event is NoEvent type --*/

  let v = e3.unwrap();
  print!("\n  inner value of {:?} is {}", e3, v);

  /*-- will panic if you unwrap() e4 --*/
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output</defn-head>
                <defn-code>
event 3 is Critical!
event 2 is Warning
inner value of Critical(3) is 3

                </defn-code>
                <defn-head class="defnBorderTop">Comments</defn-head>
                <defn-body>
                  Enumerations can have methods defined<br />
                  in the same way we define methods for<br />
                  structs.  That let&apos;s us acess and use their<br />
                  inner values.
                  <div style="height:0.75rem;"></div>
                  Match statements require us to handle all of<br />
                  the enum items.
                  <div style="height:0.75rem;"></div>
                  Sometimes we don&apos;t need to do that.<br />
                  Then, we can use the if let statement to<br />
                  test for a single enum item type.
                  <div style="height:0.75rem;"></div>
                  Here,
                  the &quot;=&quot; operator is not assignment.<br />
                  It is a matching operator that selects on a<br />
                  single enum item type.
                  <div style="height:1.75rem;"></div>
                  How cool is Rust?  Very cool!
                  <div style="height:0.75rem;"></div>
                </defn-body>
                <defn-head class="defnBorderTop">Example:</defn-head>
                <defn-body>
                  <div style="height:0.75rem;"></div>
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=400f48cff6f4682db6eb93a8beae317f">
                    playground example
                  </a>
                </defn-body>
              </defn-block>
            </defn-OuterBlock>
          </div>
        </t-b>
        <div style="height:0.75rem;"></div>
        <a id="matching"></a>
        <h3>3.0 - Matching</h2>
        <t-b>
          Matching is Rust&apos;s model for alternates selection - more powerful than switch-case operations, as
          shown by the example, above.
          Matching works for more than just enum items.  The example below shows matching on char ranges.
        </t-b>
        <t-b>
          <div>
            <defn-OuterBlock>
              <defn-block>
                <defn-head>Matching Ordinary Data</defn-head>
                <defn-code>
fn do_match(c: char) {
  match c {
    ('0'..='9') =>
      print!("\n  {} is a digit", c),
    ('a'..='z') =>
      print!("\n  {} is lower case ascii char", c),
    ('A'..='Z') =>
      print!("\n  {} is upper case ascii char", c),
    _ => print!("\n  {} is some other char type", c)
  }
}

fn main() {
  let x = 'a';
  do_match(x);
  do_match('Q');
  do_match('7');
  do_match('@');
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output</defn-head>
                <defn-code>
a is lower case ascii character
Q is upper case ascii character
7 is a digit
@ is some other char type

                </defn-code>
                <defn-head class="defnBorderTop">Comments</defn-head>
                <defn-body>

                  Lexer here we come!
                  <div style="height:0.75rem;"></div>
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=63a5e4c1b5b3a1f4ff1d3a986b540d4b">
                    playground example
                  </a>
                </defn-body>
              </defn-block>
            </defn-OuterBlock>
          </div>
        </t-b>
        <div style="height:0.25Rem;"></div>
        <a id="refs"></a>
        <h3>4.0 - References</h2>
        <div style="height:0.75rem;"></div>
        <div class="indent">
          <table>
            <tr>
              <th>Link</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><a target="_blank" href="https://doc.rust-lang.org/book/ch06-00-enums.html">the rust book</a></td>
              <td>Easy to use examples, illustrated with std::fs</td>
            </tr>
            <tr>
              <td><a target="_blank" href="https://doc.rust-lang.org/rust-by-example/custom_types/enum.html">rust-by-example</a></td>
              <td>Easy to use examples that have sufficient detail for project coding</td>
            </tr>
          </table>
        </div>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#custom">custom</a>
        <a href="#matching">matching</a>
        <a href="#refs">refs</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
      <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 23, 10);
  </script>
</body>
</html>
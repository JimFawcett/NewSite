<!DOCTYPE html>
<html id="top">
<!--
  BasicBites_UDB.html
-->
<head>
  <title>Rust Bites Objects</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="../css/Styles_BitsContent.css" />
  <script src="../js/Scripts_BitsContent.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    /* #github table {
      width: calc(100vw - 14.5em);
      border: 1px solid black;
    }

      #github table.invis {
        width: 90%;
        border: none;
      }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr.invis {
          border: none;
        }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

          #github table tr th.invis {
            border: none;
          }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

          #github table tr td.invis {
            border: none;
          }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      } */

    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }

    /* table {
      margin-right: 0.75em;
    } */
  </style>
</head>
<body id="github" onload="load()">

  <!-- <a id="Next" href="RustBites_FlashCards.html">Next</a>
  <a id="Prev" href="RustBites_Safety.html">Prev</a> -->

  <div>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main>
      <div id="about" class="hidden" onclick="toggleAbout()">
        RustBites_Objects.html<br />
        copyright &copy; James Fawcett<br />
        Revised: 02/01/2025
      </div>
      <content-block>
        <header>
          <!-- <a target="_blank" class="repoLink" style="margin:2.0em 1.0em; font-size:0.9em;" href="https://github.com/JimFawcett/Consuming_Rust_bite_by_byte">Rust Bites</a> -->
          <div id="pagetitle" class="header">
            <h2>Rust Bites: Objects</h2>
            <h4 id="subtitle" class="indent">
              library and user-defined structs and objects
            </h4>
          </div>
          <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.05em; border:2px solid var(--dark);">
            <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
            <a class="repoLinks" target="_self" href="RustHome.html" style="margin-left:1.25em; color:var(--light); ">Rust Track</a>
          </div>
        </header>
        <!--<hr class="spread" />-->
        <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates uses of Rust User-Defined types and their objects.
          The purpose is to quickly acquire some familiarity with user-defined types
          and their implementations.
          <hr class="spread" />
          <ul>
            <li>
              Syntactically, Rust uses the keyword &quot;struct&quot; instead of &quot;class&quot; to do
              the same things the other languages do, within the constraints of its language design.
            </li>
            <li>
              Unlike C++, Rust does not define special class methods. Rust types are either
              <a target="_blank" href="../RustBites/RustBites_Data.html#copy_borrow">copy or move</a>,
              and most user-defined types are move, so it has no need for them. This eliminates one source
              of implementation complexity.
            </li>
            <li>
              The compiler will, if asked with an attribute, auto-generate some operations like clone.
            </li>
            <li>
              Also, this is the first set of examples to partition code into several files.
              That supports readability, may improve translation times, and makes maintenance
              significantly easier.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <div style="height:0.75em;"></div>
        <details id="aggrtypes">
          <summary class="darkItem">Rust Aggregate Type Structure&nbsp;&nbsp;</summary>
          <div style="padding:0em 1em 1em 1em; width:max-content; border:1px solid var(--dark);">
            <t-b>
              Aggregates are types whose instances hold instances of, or handles to, other types, i.e., an array can hold
              instances of an arbitrary type. Structs and classes can hold named instances or handles to arbitrary other types.
            </t-b>
            <t-b>
              There are three ways that happens:
              <ul>
                <li>
                  <strong>Inheritance</strong>
                  <t-b>
                    A Rust struct can inherit only trait declarations. The memory footprint of the struct
                    is not affected by trait inheritances.  Unlike C++ and C#, Rust does not support
                    inheritance of implementation.
                  </t-b>
                </li>
                <li>
                  <h5>Composition</h5>
                  <t-b>
                    When an instance of a Rust type holds one or more instances of other types, the memory footprint of each composed type
                    lies entirely within the memory footprint of its parent instance.  We say the parent
                    composes its child elements.
                  </t-b>
                </li>
                <li>
                  <h5>Aggregation</h5>
                  <t-b>
                    Rust types can hold smart pointer handles to instances of types stored in the
                    native heap, e.g., Box, Rc, and Arc.
                  </t-b>
                  <t-b>
                    When an instance of a  type holds a handle to instances of other types,
                    the parent&apos;s memory footprint holds only the handle, not the entire child
                    instance.  We say the parent aggregates the type referenced by the handle.
                  </t-b>
                  <t-b>
                    It is possible for a Rust type to hold references to other types, but that is
                    very rare, because Rust&apos;s safety invariants make that difficult to
                    accomplish, and that is usually not very useful.
                  </t-b>
                </li>
              </ul>
            </t-b>
          </div>
        </details>
        <div style="height:0.75rem;"></div>
        <details id="notes">
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            All of the languages covered in this demonstration support classes.  Each class provides
            a pattern for laying out a memory footprint and defines how data within are accessed.
          </t-b>
          <t-b>
            Unlike all the other languages, Rust uses the struct type to create patterns for object
            creation.  This is simply a syntactical change. Everything that the other languages do with
            classes Rust does with structs, within the constraints of its language design model.
          </t-b>
          <t-b>
            Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
            is a pattern for defining functions and classes of a specific type.  Thus a generic is a
            pattern for making patterns.
          </t-b>
          <t-b>
            The other two, Python and JavaScript, are dynamically typed and already support defining
            functions and classes for multiple types, e.g., no need for generics.
          </t-b>
          <t-b>
            This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
            are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
            stored in managed heaps.
          </t-b>
          <t-b><hr /></t-b>
        </details>
        <t-b>
          The examples below show how to create user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <!-- <div style="height:0.25em;"></div> -->
        <h3 id="code">1.0 Source Code</h3>
        <t-b>
          Source code is presented in this page using a series of code blocks:
          <ul>
            <li>
              Demonstration of standard <c-s>String</c-s> creation and uses
            </li>
            <li>
              Demonstration of standard <c-s>Vec&lt;i32&gt;</c-s> creation and uses
            </li>
            <li>
              Definition of user-defined <c-s>Point4D</c-s> type with 3 floating point coordinates and one time coordinate.
              <ul style="list-style-type:none; position:relative; top:-0.25em; margin-left:1em; line-height:0.75em;">
                <li>Relatively simple type to introduce Rust user-defined type syntax</li>
              </ul>
              <ul style="list-style-type:none; position:relative; top:-0.25em; margin-left:1em; line-height:0.75em;">
                <li>
                  <a target="_blank" href="../RustBites/RustBites_Data.html#copy_borrow">Copy type</a>
                  with copy construction and copy assignment
                </li>
              </ul>
            </li>
            <li>
              Demonstration of copy type <c-s>Point4D</c-s> creation and uses
            </li>
            <li>
              Definition of move type <c-s>PointN</c-s> with N floating point coordinates
              <ul style="list-style-type:none; position:relative; top:-0.25em; margin-left:1em; line-height:0.75em;">
                <li>Prototype for N-dimensional point type</li>
              </ul>
              <ul style="list-style-type:none; position:relative; top:-0.25em; margin-left:1em; line-height:0.75em;">
                <li>
                  <a target="_blank" href="../RustBites/RustBites_Data.html#copy_borrow">Move type</a>
                  with move construction and move assignment
                </li>
              </ul>
            </li>
            <li>
              Demonstration of move type <c-s>PointN</c-s> creation and uses
            </li>
            <li>
              Presentation and discussion of analysis and display functions
            </li>
            <li>
              Program structure
            </li>
          </ul>
        </t-b>
        <!-- <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" /> -->
        <h3 id="stdlib">1.1 Rust std::library Objects</h3>
        <t-b>
          The next few blocks illustrate creation and use of instances of types defined by the
          <a target="_blank" href="https://doc.rust-lang.org/std/">Rust std::lib</a>.
        </t-b>
        <div style="height:0.05em;"></div>
        <h3 id="demostr">1.1.1 Standard String Objects</h3>
        <t-b>
          This Bit demonstration starts by creating and using operations of instances of
          <c-s>String</c-s> defined as part of the
          <a target="_blank" href="https://doc.rust-lang.org/std/">standard library</a>.
          The code consists of a single function <c-s>demo_string_objects()</c-s>.
        </t-b>
        <div class="right">
          <photosizer-block src="pictures/String.jpg" width="250" class="photoSizerBlock">
            <span style="font-family:'Comic Sans MS';">Figure 1. String Layout</span>
          </photosizer-block>
        </div>
        <t-b>
          Rust strings, unlike those in many other languages, do not necessarily consist of characters
          all of the same size. Instead, characters are utf-8 which may have sizes from 1 to 4 bytes.
        </t-b>
        <t-b>
          That means that Rust strings have built-in support for characters used in other languages 
          like Kanji, Arabic, Hindi, and french that use diacritics like &acirc; and other non-ASCII
          symbols.
        </t-b>
        <t-b>
          This power comes at the cost of more complex iteration. Indexing returns bytes, which may
          not be complete characters. For that reason Rust provides the string iterator chars() which
          uses a bit encoding scheme to find character boundaries.
        </t-b>
        <t-b>
          We won&apos;t dig into that iteration scheme in this Bit, but you can find a complete
          description in the Rust Bite for 
          <a target="_blank" href="../RustBites/RustBites_Strings.html#iteration">Strings</a>.
        </t-b>
        <t-b class="clear">
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div style="height:0.25em;"></div>
        <t-b style="border:1px solid var(--dark); padding:0.25em 0.5em;">
          The two panels below are separated by a &quot;splitter bar&quot;.  You can drag the
          bar horizontally to view hidden code or click in either panel to increase
          its width.
        </t-b>
        <div class="blockSingle">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <!-- <input type="button" value="Copy" class="remotebutton" onclick="copy1()" /> -->
          <splitter-container id="container">
            <first-item id="fig1-first" style="width:55%; position:relative">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig1-first')" style="width:200em;">
<code class="language-rust">fn demo_string_objects() {
/*--------------------------------------------------------                                                
  demo standard String:
  - create and initialize instances
  - move construction
  - move assignment
  - selected operations
*/
  show_note(&quot;demo std String&quot;, 40);
  let mut s:String = &quot;a string&quot;.to_string();
  println!(&quot;  s: {:?}&#92;n&quot;, s);

  show_op(&quot;let s1 = s : move construction&quot;);
  let mut s1 = s;  // move construction
  println!(&quot;s1: {:?}&#92;n&quot;, s1);
  // s now invalid, been moved : uncomment to see error msg
  // println!(&quot;{:?}&quot;, s);

  show_op(&quot;s1 += &#92;&quot; and more&#92;&quot; : one of many operations&quot;);
  s1 += &quot; and more&quot;;
  println!(&quot;s1: {:?}&#92;n&quot;, s1);

  show_op(&quot;s = s1.clone : move assignment of clone&quot;);
  s = s1.clone();
  // clone copies s1's resources so s1 is still valid
  println!(&quot;s: {:?}&quot;, s);
  println!(&quot;s1: {:?}&#92;n&quot;, s1);

  show_op(&quot;s1 = s1 + &#92;&quot; words&#92;&quot;&quot;);
  s1 += &quot; words&quot;;
  show_op(&quot;s = s1 : move assignment&quot;);
  s = s1;
  println!(&quot;s: {:?}&#92;n&quot;, s);
  // s1 now invalid, been moved

  // String stored in heap
  show_op(&quot;let mut h_str = Box::new(&#92;&quot;...&#92;&quot;)&quot;);
  let mut h_str = Box::new(&quot;heap string&quot;.to_string());
  println!(&quot;h_str: {:?}&quot;, h_str);

  *h_str += &quot; and some more&quot;;
  println!(&quot;h_str: {:?}&quot;, h_str);

}</code>
              </pre>
              </div>
            </first-item>
            <splitter-bar id="fig1-seperator"></splitter-bar>
            <second-item id="fig1-second" style="width:45%;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig1-first')" style="width:200em;">
<code class="language-rust">
  
  
  
  
  
----------------------------------------                                                  
  demo std String
----------------------------------------
  s: &quot;a string&quot;

--- &quot;let s1 = s : move construction&quot; ---
s1: &quot;a string&quot;

--- &quot;s1 += &#92;&quot; and more&#92;&quot; : one of many operations&quot; ---
s1: &quot;a string and more&quot;

--- &quot;s = s1.clone : move assignment of clone&quot; ---
s: &quot;a string and more&quot;
s1: &quot;a string and more&quot;

--- &quot;s1 = s1 + &#92;&quot; words&#92;&quot;&quot; ---
--- &quot;s = s1 : move assignment&quot; ---
s: &quot;a string and more words&quot;

--- &quot;let mut h_str = Box::new(&#92;&quot;...&#92;&quot;)&quot; ---
h_str: &quot;heap string&quot;
h_str: &quot;heap string and some more&quot;

















</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="demovec">1.1.2 Standard Vec Objects</h3>
        <t-b>
          This Bit demonstration starts by creating and using operations of instances of
          <c-s>String</c-s> and <c-s>Vector&lt;T&gt;</c-s>, both defined as part of the
          <a target="_blank" href="https://doc.rust-lang.org/std/">standard library</a>.
          The code consists of a single function <c-s>demo_standard_objects()</c-s>.
        </t-b>
        <t-b>
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div class="blockSingle">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote2()" />
          <!-- <input type="button" value="Copy" class="remotebutton" onclick="copy2()" /> -->
          <splitter-container id="container">
            <first-item id="fig2-first" style="width:55%;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig2-first')" style="width:200em;">
<code class="language-rust">/*-----------------------------------------------------------------------------------------------------------
  demo standard Vector
  - create and initialize instances
  - move construction
  - move assignment
  - selected operations
*/
fn demo_vector_objects() {
  show_note(&quot;demo std vector&quot;, 40);
  let mut v: Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];
  println!(&quot;  v: {:?}&#92;n&quot;, v);

  show_op(&quot;let v1 = v : move construction&quot;);
  let mut v1 = v;  // move construction
  println!(&quot;  v1: {:?}&#92;n&quot;, v1);
  // v now invalid, been moved : uncomment to see error msg
  // println!(&quot;{:?}&quot;, v);

  show_op(&quot;v1[1] = -2 : one of many operations&quot;);
  v1[1] = -2;
  println!(&quot;  v1: {:?}&#92;n&quot;, v1);

  show_op(&quot;v = v1.clone : move assignment of clone&quot;);
  v = v1.clone();
  // clone copies v1's resources so v1 is still valid
  println!(&quot;  v: {:?}&quot;, v);
  println!(&quot;  v1: {:?}&#92;n&quot;, v1);

  show_op(&quot;a = &v[1..3]&quot;);
  // create array from vector slice
  let a: &[i32] = &v[1..3];
  println!(&quot;  a: {:?}&#92;n&quot;, a);

  show_op(&quot;v2 is collect from slice &v[1..3]&quot;);
  let v2 = (1..3).map(|i| v1[i]).collect::&lt;Vec&lt;i32&gt;&gt;();
  println!(&quot;  v2: {:?}&#92;n&quot;, v2);

  show_op(&quot;v = v2 : move assignment&quot;);
  v = v2;
  println!(&quot;  v: {:?}&#92;n&quot;, v);
  // v2 now invalid, been moved

  // Vec stored in heap
  show_op(&quot;let mut h_vec = Box::new(&#92;&quot;...&#92;&quot;)&quot;);
  let mut h_vec = Box::new(vec![1, 2, 3, 4, 5]);
  println!(&quot;  h_vec: {:?}&#92;n&quot;, h_vec);

  show_op(&quot;(*h_vec)[2] += 2&quot;);
  (*h_vec)[2] += 2;
  println!(&quot;  h_vec: {:?}&quot;, h_vec);

  show_op(&quot;h_vec[2] += 2, uses auto deref&quot;);
  h_vec[2] += 2;
  println!(&quot;  h_vec: {:?}&#92;n&quot;, h_vec);

}</code>
              </pre>
              </div>
            </first-item>
            <splitter-bar id="fig2-seperator"></splitter-bar>
            <second-item id="fig2-second" style="width:45%;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig2-first')" style="width:200em;">
<code class="language-rust">





----------------------------------------                                                  
  demo std vector
----------------------------------------
  v: [1, 2, 3, 2, 1]

--- &quot;let v1 = v : move construction&quot; ---
  v1: [1, 2, 3, 2, 1]

--- &quot;v1[1] = -2 : one of many operations&quot; ---
  v1: [1, -2, 3, 2, 1]

--- &quot;v = v1.clone : move assignment of clone&quot; ---
  v: [1, -2, 3, 2, 1]
  v1: [1, -2, 3, 2, 1]

--- &quot;a = &v[1..3]&quot; ---
  a: [-2, 3]

--- &quot;v2 is collect from slice &v[1..3]&quot; ---
  v2: [-2, 3]

--- &quot;v = v2 : move assignment&quot; ---
  v: [-2, 3]

--- &quot;let mut h_vec = Box::new(&#92;&quot;...&#92;&quot;)&quot; ---
  h_vec: [1, 2, 3, 4, 5]

--- &quot;(*h_vec)[2] += 2&quot; ---
  h_vec: [1, 2, 5, 4, 5]
--- &quot;h_vec[2] += 2, uses auto deref&quot; ---
  h_vec: [1, 2, 7, 4, 5]




















</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="points">1.2 Source Code - Points.rs</h3>
        <t-b>
          A Rust struct is a pattern for laying out a type&apos;s data in memory with member functions,
          called methods, for all of its operations.  Making data members private ensures
          that struct methods have valid data for their operations. A type designer may
          choose to selectively allow user data modification.
        </t-b>
        <h3 id="point4d">1.2.1 Define Type Point4D</h3>
        <t-b style="margin-bottom:1em;">
          <c-s>Point4D</c-s> is a user-defined type representing a point in 4-dimensional space-time. It declares the
          data held by instances of the type: three floating point coordinates and
          a <c-s>DateTime&lt;Local&gt;</c-s> variable, and defines methods to create and modify
          instances.
        </t-b>
        <t-b>
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="point4d-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('point4d-first')">
                <pre style="width:200em;"><code class="language-cpp">use std::fmt::*;
use chrono::prelude::*;

/*---------------------------------------------------------
  Declare Point4D struct
  - similar in function to a C++ class
  - Request compiler to implement traits: Debug, Copy & Clone
  - Can be Copy since all members are copy
  - So, construction and assignment are copy operations
  - Demos two types of member access, only one needed
*/
#[derive(Debug, Copy, Clone)]
pub struct Point4D {
  x: f64,
  y: f64,
  z: f64,
  t: DateTime&lt;Local&gt;,
}
/*-- implement constructor function new --*/
impl Point4D {
  pub fn new() -&gt; Point4D {
    Point4D { x: 0.0, y: 0.0, z: 0.0, t: Local::now() }
  }
  /*------------------------------------------------
    These methods can be used to set or retrieve
    values of Point4D instance coordinates, as they
    return a mutable reference. Note similarity with
    C++ code.
  */
  pub fn coor_x(&mut self) -&gt; &mut f64 {
    &mut self.x
  }
  pub fn coor_y(&mut self) -&gt; &mut f64 {
    &mut self.y
  }
  pub fn coor_z(&mut self) -&gt; &mut f64 {
    &mut self.z
  }
  pub fn time(&self) -&gt; String {
    self.t.format(&quot;%a %b %e %Y, %T&quot;).to_string()
  }
  pub fn update_time(&mut self) {
    self.t = Utc::now().with_timezone(&Local);
  }
  /*------------------------------------------------
    An alternate design for mutating coordinates.
    This set has twice as many methods, but may
    make access and mutation more obvious when
    reading source code.
  */
    pub fn get_x(&self) -&gt; &f64 {
      &self.x
    }
    pub fn get_y(&self) -&gt; &f64 {
      &self.y
    }
    pub fn get_z(&self) -&gt; &f64 {
      &self.z
    }
    pub fn set_x(&mut self, x: f64) {
      self.x = x
    }
    pub fn set_y(&mut self, y: f64) {
      self.y = y
    }
    pub fn set_z(&mut self, z: f64) {
      self.z = z
    }
  /*
    For simple types like this it would be reasonable to
    make x, y, z public and remove the getter and setter
    functions.
  */
  /*-----------------------------------------------------
    show method displays instance values
    - uses helper function indent
  */
  pub fn indent(ch:char, n:usize) -&gt; String {
    (0..n).map(|_i| ch).collect::&lt;String&gt;()
    // equivalent to:
    //   let ind = (0..n).map(|_i| ch).collect::&lt;String&gt;();
    //   ind
    // - (0..n) is an iterator yielding values 0 through n-1
    // - map sets each iterator item to same char ch
    // - collect appends each char to temporary String
    // ind defines return value, the collected String
  }
  pub fn show(&self, nm:&str, ind:usize) {
    let indstr = Point4D::indent(' ', ind);
    print!(&quot;{indstr}{nm} : Point4D {{&#92;n  &quot;);
    print!(&quot;{indstr}{0}, &quot;, self.x);
    print!(&quot;{indstr}{0}, &quot;, self.y);
    println!(&quot;{indstr}{0},&quot;, self.z);
    println!(&quot;{indstr}  {}&quot;, Local::now().format(&quot;%a %b %e %Y, %T&quot;));
    println!(&quot;{indstr}}}&quot;);
  }
}</code></pre>
              </div>
            </first-item>
            <splitter-bar id="point4d-seperator"></splitter-bar>
            <second-item id="point4d-second" style="width:40em;">
              <div class="codewrap noflow commentary" onclick="obubbleup('point4d-first')">
                <h3>Concept:</h3>
Point4D holds data for a point in 3 dimensional space<br />
and a time when something was at that point.<br />
<br />
These points could be collected into a vector to<br />
represent a trajectory of an aircraft or a machine<br />
tool cutting edge.<br />
<br /><br /><br /><br />

<strong><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> Rust struct syntax:</strong><br />

Rust uses structs as patterns for laying out objects<br />
in memory, much like C++ uses classes.<br />
<br />
Methods are not declared within the struct body.<br />
Instead, they are defined in a seperate &quot;impl&quot; scope.<br />
<br />
Unlike C++, the input reference to self must be supp-<br />
lied explicitly, where C++ passes that implicitly, i.e.,<br />
for C++ it doesn&apos;t appear in user code.<br />
<br />
Mutability must be explicit.  If not declared, any<br />
attempt to change value will fail to compile.<br />
<br />
Return types are declared explicitly, as shown here<br />
for return of a string representation of Point4D&apos;s<br />
value of local time.<br />
<br />
<c-s>t:DateTime&lt;Local&gt;</c-s> is converted to a string using<br />
its format method.<br />
<br />
<strong>Special struct methods:</strong><br />
<br />
Unlike C++, Rust does not provide, nor require special<br />
methods, like overloaded constructors and destructor.<br />
<br />
Note that the <c-s>#[derive(Debug, Copy, Clone)]</c-s> just<br />
above the Point4D declaration requires the Rust<br />
compiler to generate <c-s>Debug</c-s>, <c-s>Copy</c-s> and <c-s>Clone</c-s> traits.<br />
<br />
A trait is very similar to a C# interface, declaring<br />
methods like <c-s>clone()</c-s> for the <c-s>Clone</c-s> trait.<br />
<br />
Rust types are either <c-s><a target="_blank" href="../RustBites/RustBites_Data.html#copy_borrow">Copy or Move</a></c-s> (!<c-s>Copy</c-s>). A type<br />
can be <c-s>Copy</c-s> if, and only if, all its members are <c-s>Copy</c-s><br />
and the struct implements the <c-s>Copy</c-s> trait.<br />
<br />
The <c-s>Copy</c-s> trait declares no methods.  It is simply a<br />
marker that tells the compiler to copy the memory<br />
footprint of an instance for construction and assign-<br />
ment.<br />
<br />
Since it implements <c-s>Copy</c-s>, <c-s>Point4D</c-s> is a copy type.<br />
Implementing Copy fails to compile if the struct<br />
contains any non-copy members.<br />
<br />
Rust construction and assignment are always either<br />
<c-s>Copy</c-s> or <c-s>Move</c-s> operations, so there are either copy<br />
construction and assignment or move construction and<br />
assignment, but not both. Moves are transfers of<br />
ownership of the source&apos;s resources.<br />
<br />
A clone operation copies resources from the cloned<br />
instance to the new clone.  It is not an ownership<br />
transfer of those resources.<br />
<br />
For purposes of performance, idiomatic Rust code<br />
avoids expensive copy operations wherever possible, <br />
and when used, makes that use explicit with a call <br />
to <c-s>clone()</c-s>.<br />
<br />
<c-s>Point4D</c-s> is relatively cheap to copy because its<br />
members are relatively small, so this code is <br />
idiomatic.<br />
<br />
The <c-s><a target="_blank" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a></c-s> trait declares the <c-s>fmt</c-s> method and is used<br />
to deplay a simple, debug friendly, representation of<br />
its argument. In this case the argument will be an<br />
instance of Point4D.<br />
<br />
<strong>Design Note:</strong><br />
<br />
<c-s>Point4D</c-s> implements two distinct sets of accessor<br />
methods: the coors methods and getter and setter <br />
methods. At most only one of these is needed.<br />
<br />
For simple types like <c-s>Point4D</c-s> it would be very reason-<br />
able to simply make the data x, y, and z public.  That <br />
would not be appropriate for t because the t data<br />
member must be of type <c-s>DateTime&lt;Local&gt;</c-s> and can&apos;t<br />
accept arbitrary data.<br />
<br />
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="demopt4d">1.2.2 Demo user-defined type Point4D</h3>
        <t-b>
          Code in this block demonstrates creation and use of instances of the
          user-defined type <c-s>Point4D</c-s>.  All the code is presented as part
          of a single function: <c-s>demo_user_defined_point4d()</c-s>.
        </t-b>
        <t-b>
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div class="blockSingle">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote3()" />
          <!-- <input type="button" value="Copy" class="remotebutton" onclick="copy3()" /> -->
          <splitter-container id="container">
            <first-item id="fig3-first" style="width:55%;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig3-first')" style="width:200em;">
<code class="language-rust">/*---------------------------------------------------------------------------------------------------------------------
  demo user-defined type Point4D
  - create and initialize instances
  - copy construction
  - copy assignment
  - selected operations
*/
fn demo_user_defined_point4d() {

  show_note(&quot;instances of user-defined type Point4D&quot;, 35);
  println!();

  /*-- create instance of Point4D ---*/
  show_op(&quot;let mut p1 = Point4D::new()&quot;);
  let mut p1 = Point4D::new();
  p1.show(&quot;p1&quot;, 2);
  p1.set_x(42.0);
  p1.set_y(-3.0);
  p1.set_z(2.0);
  p1.show(&quot;p1&quot;, 2);
  /*-- show p1's type ---------------*/
  p1.show(&quot;p1&quot;, 2);
  println!();

  show_op(&quot;using Debug trait with println!&quot;);
  println!(&quot;p1: {:?}&#92;n&quot;, p1);

  /*-- show one of its operations ---*/
  show_op(&quot;let p1a = p1.clone()&quot;);
  let p1a = p1.clone();
  p1a.show(&quot;p1.clone()&quot;, 2);

  println!(&quot;&#92;n  using PointN&lt;f64&gt;::coor_x function:&quot;);
  *(p1.coor_x()) = 84.0;
  p1.show(&quot;p1&quot;, 2);

  println!(&quot;&#92;n  using PointN&lt;f64&gt;::coor_y function:&quot;);
  *p1.coor_y() = 84.0;
  p1.show(&quot;p1&quot;, 2);

  println!(&quot;&#92;n  using PointN&lt;f64&gt;::coor_z function:&quot;);
  let rz = p1.coor_z();
  *rz = 84.0;
  p1.show(&quot;p1&quot;, 2);

  println!(&quot;&#92;n  updating time value:&quot;);
  /*-- delay 5 secs for update_time demo --*/
  println!(&quot;  delaying 5 seconds before time update&quot;);
  use std::time::Duration;
  let dur:Duration = Duration::from_secs(5);
  std::thread::sleep(dur);

  p1.update_time();
  p1.show(&quot;p1&quot;, 2);
  println!();

  show_op(&quot;let p2 = p1 : copy construction&quot;);
  let mut p2 = p1;
  p2.show(&quot;p2&quot;, 2);
  p1.show(&quot;p1&quot;, 2);

  show_op(&quot;*p2.coor_x() = 42.0&quot;);
  *p2.coor_x() = 42.0;
  p2.show(&quot;p2&quot;, 2);

  show_op(&quot;p1 = p2 : copy assignment&quot;);
  p1 = p2;
  p1.show(&quot;p1&quot;, 2);
  p2.show(&quot;p2&quot;, 2);
  println!();

  show_note(&quot;Point4D objects in heap&quot;, 40);
  let mut h_point = Box::new(Point4D::new());
  // show_type(&h_point, &quot;h_point&quot;);
  /*
    Point4D does not implement trait DerefMut, so code has to
    explicitly deref, as shown here.
  */
  *h_point.coor_x() = 2.0;
  *h_point.coor_y() = 1.0;
  *h_point.coor_z() = 0.0;
  (*h_point).show(&quot;h_point&quot;, 2);
  println!();

  show_op(&quot;let h_point1 = h_point.clone()&quot;);
  let h_point1 = h_point.clone();
  (*h_point1).show(&quot;h_point1&quot;, 2);
  println!();

}

</code>
              </pre>
              </div>
            </first-item>
            <splitter-bar id="fig3-seperator"></splitter-bar>
            <second-item id="fig3-second" style="width:45%;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig3-first')" style="width:200em;">
                <code class="language-rust">

---------------------------------------------
  instances of user-defined type Point4D
---------------------------------------------

--- &quot;let mut p1 = Point4D::new()&quot; ---
  p1 : Point4D {
    0,   0,   0,
    Wed Dec 20 2023, 12:02:27
  }
  p1 : Point4D {
    42,   -3,   2,
    Wed Dec 20 2023, 12:02:27
  }
  p1 : Point4D {
    42,   -3,   2,
    Wed Dec 20 2023, 12:02:27
  }

--- &quot;using Debug trait with println!&quot; ---
p1: Point4D { x: 42.0, y: -3.0, z: 2.0, t: 2023-12-20T12:02:27.848829800-06:00 }          

--- &quot;let p1a = p1.clone()&quot; ---
  p1.clone() : Point4D {
    42,   -3,   2,
    Wed Dec 20 2023, 12:02:27
  }

  using PointN&lt;f64&gt;::coor_x function:
  p1 : Point4D {
    84,   -3,   2,
    Wed Dec 20 2023, 12:02:27
  }

  using PointN&lt;f64&gt;::coor_y function:
  p1 : Point4D {
    84,   84,   2,
    Wed Dec 20 2023, 12:02:27
  }

  using PointN&lt;f64&gt;::coor_z function:
  p1 : Point4D {
    84,   84,   84,
    Wed Dec 20 2023, 12:02:27
  }

  updating time value:
  delaying 5 seconds before time update
  p1 : Point4D {
    84,   84,   84,
    Wed Dec 20 2023, 12:02:32
  }

--- &quot;let p2 = p1 : copy construction&quot; ---
  p2 : Point4D {
    84,   84,   84,
    Wed Dec 20 2023, 12:02:32
  }
  p1 : Point4D {
    84,   84,   84,
    Wed Dec 20 2023, 12:02:32
  }
--- &quot;*p2.coor_x() = 42.0&quot; ---
  p2 : Point4D {
    42,   84,   84,
    Wed Dec 20 2023, 12:02:32
  }
--- &quot;p1 = p2 : copy assignment&quot; ---
  p1 : Point4D {
    42,   84,   84,
    Wed Dec 20 2023, 12:02:32
  }
  p2 : Point4D {
    42,   84,   84,
    Wed Dec 20 2023, 12:02:32
  }

----------------------------------------
  Point4D objects in heap
----------------------------------------
  h_point : Point4D {
    2,   1,   0,
    Wed Dec 20 2023, 12:02:32
  }

--- &quot;let h_point1 = h_point.clone()&quot; ---
  h_point1 : Point4D {
    2,   1,   0,
    Wed Dec 20 2023, 12:02:32
  }
</code>
              </pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="movept">1.3 Point as Move Type</h3>
        <t-b>
          This section extends Point4D to an N-dimensional point storing its coordinate data in
          a std::Vec&lt;T&gt;.
        </t-b>
        <h3 id="pointnp">1.3.1 Define Type PointNPrototype</h3>
        <t-b style="margin-bottom:1em;">
          <c-s>PointNPrototype</c-s> is a prototype for an N-dimensional point.
          It declares data held by instances of the type as a vector of floats,
          and defines methods to create and modify instances. This type will be
          completed in the next, Generic, Bit.
        </t-b>
        <t-b>
          <c-s>PointNPrototype</c-s> is a Move type.  Construction and assignment are move operations that
          are created by the compiler, as is the drop operation, similar to a C++
          destructor. That means that Rust developers do not create special class methods
          for them.
        </t-b>
        <t-b>
          <c-s>PointNPrototype</c-s> requests the compiler to implement the Debug and Clone traits using
          <c-s>#[derive(Debug,&nbsp;Clone)]</c-s>. Attempting to make it a copy type by including the
          <c-s>Copy</c-s> trait would result in compile failure because its struct contains a non-copy member.
        </t-b>
        <t-b>
          So, both construction and assignment are move operations,
          which transfers ownership of the source&apos;s resources to the destination.  That usually
          entails copying a pointer and two counters.
        </t-b>
        <t-b>
          That is fast, but leaves the source in an invalid state. Attempting to use the source
          again results in compile failure.
        </t-b>
        <t-b>
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="pointproto-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('pointproto-first')">
                <pre style="width:200em;"><code class="language-cpp">/*
PointNPrototype
  - Request compiler implement traits Debug & Clone
  - Can't be Copy since members are not copy
  - So, construction and assignment are move operations
  - This demo will be expanded into useful type in
    next Bit: Rust_GenericBit
*/
#[derive(Debug, Clone)]   // can't make Copy type
pub struct PointNPrototype {
  coords: Vec&lt;f64&gt;        // not copy type
}
impl PointNPrototype {
  pub fn new() -&gt; PointNPrototype {
    PointNPrototype {
      coords: vec![]
    }
  }
  /*-- initialize from elements of array slice --*/
  pub fn init(&mut self, arr: &[f64]) -&gt; &mut PointNPrototype {
    self.coords = (0..arr.len()).map(|i| arr[i]).collect::&lt;Vec&lt;f64&gt;&gt;();
    // arr is an array slice, e.g., a view into an array
    // (0..arr.len()) is iterator returning integers from 0 to arr.len() - 1
    // map(|i| arr[i]) returns arr[i] for each iterator item i
    // collect::&lt;Vec&lt;f64&gt;&gt;() collects Vec of those arr values.
    self
  }
  /*-- make coordinates accessible for reading and writing --*/
  pub fn coors(&mut self) -&gt; &mut Vec&lt;f64&gt; {
    &mut self.coords
  }
}

</code></pre>
              </div>
            </first-item>
            <splitter-bar id="pointproto-seperator"></splitter-bar>
            <second-item id="pointproto-second" style="width:40em;">
              <div class="textwrap noflow commentary" onclick="obubbleup('pointproto-first')">
                <h3>Concept:</h3>
                <c-s>PointNPrototype</c-s> holds data for a point in N dimen-<br />
                sional space. These points could represent the state of<br />
                an electomechanical control system or chemical process.<br />
                <br />
                Unlike <c-s>Point4d</c-s> this class cannot support copy operations<br />
                because its <c-s>Vec&lt;f64&gt;</c-s> data member is not a copy<br />
                type.<br />
                <br />
                <strong><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> Prototype syntax:</strong><br />

PointNPrototype is a prototype for a type we will<br /> 
implement completely in the next Bit: Bits_GenericRust.<br /> 
It is included here to illustrate the distinction between <br />
Copy and Move types.<br />
<br />
It includes two methods, <c-s>new()</c-s> and<br />
<c-s>init(&amp;mut&nbsp;self,&nbsp;arr:&nbsp;&amp[f64])</c-s> to create and initialize<br />
instances, and a method, <c-s>coors(&mut&nbsp;self)</c-s> to provide <br />
access to their internal states.<br />
<br />
<strong>Special struct methods:</strong><br />
<br />
Unlike <c-s>Point4D</c-s>, <c-s>PointNPrototype</c-s> is a <c-s>Move</c-s> type. It<br />
cannot be made <c-s>Copy</c-s> because it has a <c-s>Vec&lt;f64&gt;</c-s><br />
member which is a <c-s>Move</c-s> type.<br />
<br />
Because of this, a declaration <c-s>#[derive(Copy, ...)]</c-s><br />
would fail to compile.  So <c-s>PointNPrototype</c-s> leaves the<br />
<c-s>Copy</c-s> trait out of that declaration.<br />
<br />
Construction and assignment for <c-s>PointNPrototype</c-s><br />
are move operations. There are no corresponding copy<br />
operations.<br />
<br />
Note that it does support making clones so code can<br />
move clones into the destination instances, ensuring<br />
that the original cloned instance remains valid.<br />
<br />
A clone operation copies resources from the cloned <br />
instance to the new clone.  It is not an ownership <br />
transfer of those resources.<br />
<br />
For purposes of performance, idomatic Rust code avoids<br />
copy operations wherever possible, and when used, <br />
makes that use explicit with a call to <c-s>clone()</c-s>.<br />
<br />
              </div>
            </second-item>
          </splitter-container>
        </div>

        <div style="height:1em;"></div>
        <h3 id="demoptnp">1.3.2 Demo user-defined type PointNPrototype</h3>
        <t-b>
          Code in this block demonstrates creation and use of instances of the
          user-defined type <c-s>PointNPrototype</c-s>.  All the code is created as part
          of a single function: <c-s>demo_user_defined_pointnprototype()</c-s>.
        </t-b>
        <t-b>
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div class="blockSingle">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote4()" />
          <!-- <input type="button" value="Copy" class="remotebutton" onclick="copy4()" /> -->
          <splitter-container id="container">
            <first-item id="fig4-first" style="width:55%;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig4-first')" style="width:200em;">
<code class="language-rust">/*-----------------------------------------------------------------------------------------------------------
  demo user-defined type PointNPrototype
  - create and initialize instances
  - move construction
  - move assignment
  - selected operations
*/
fn demo_user_defined_pointnprototype() {

  show_note(
    &quot;instances of user-defined type PointNPrototype&quot;,
    35
  );
  println!();

  /*-- create instance of PointNPrototype ---*/
  show_op(&quot;create PointNPrototype, print using Debug trait&quot;);
  let mut q = PointNPrototype::new();
  q.init(&[1.0, 2.0, 3.0]);
  println!(&quot;  q: {:?}&quot;, q);

  show_op(&quot;let q1 = q: move construction&quot;);
  let mut q1 = q;
  println!(&quot;  q1: {:?}&quot;, q1);
  // code below will fail to compile, q was moved
  // println!(&quot;  q: {:?}&quot;, q);

  q1.coors()[1] = -2.0;
  show_op(&quot;q = q1: move assignment&quot;);
  q = q1;  // q owns resources given by q1 so valid
  println!(&quot;  q: {:?}&quot;, q);
  // q1 has been move so no longer valid

  show_op(&quot;let q2 = q.clone()&quot;);
  let q2 = q.clone();
  println!(&quot;  q2: {:?}&#92;n&quot;, q2);

  show_note(&quot;PointNPrototype objects in heap&quot;, 40);
  let mut h_point_prototype =
    Box::new(PointNPrototype::new());
  h_point_prototype.init(&[3.0, 2.5, 2.0]);
  println!(&quot;  h_point_prototype: {:?}&quot;, h_point_prototype);

  show_op(&quot;  h_point_prototype.coors()[0] = -3.0;&quot;);
  h_point_prototype.coors()[0] = -3.0;
  println!(&quot;  h_point_prototype: {:?}&quot;, h_point_prototype);

  show_op(&quot;let h_point_prototype1 = h_point_prototype.clone()&quot;);
  let h_point_prototype1 =
    h_point_prototype.clone();
  println!(&quot;  h_point_prototype1: {:?}&quot;, h_point_prototype1);

}</code>
              </pre>
              </div>
            </first-item>
            <splitter-bar id="fig4-seperator"></splitter-bar>
            <second-item id="fig4-second" style="width:45%;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig4-first')" style="width:200em;">
                <code class="language-rust">








-------------------------------------------------------
  instances of user-defined type PointNPrototype
-------------------------------------------------------

--- &quot;create PointNPrototype, print using Debug trait&quot; ---
  q: PointNPrototype { coords: [1.0, 2.0, 3.0] }
--- &quot;let q1 = q: move construction&quot; ---
  q1: PointNPrototype { coords: [1.0, 2.0, 3.0] }
--- &quot;q = q1: move assignment&quot; ---
  q: PointNPrototype { coords: [1.0, -2.0, 3.0] }
--- &quot;let q2 = q.clone()&quot; ---
  q2: PointNPrototype { coords: [1.0, -2.0, 3.0] }

----------------------------------------
  PointNPrototype objects in heap
----------------------------------------
  h_point_prototype: PointNPrototype { coords: [3.0, 2.5, 2.0] }
--- &quot;  h_point_prototype.coors()[0] = -3.0;&quot; ---
  h_point_prototype: PointNPrototype { coords: [-3.0, 2.5, 2.0] }
--- &quot;let h_point_prototype1 = h_point_prototype.clone()&quot; ---
  h_point_prototype1: PointNPrototype { coords: [-3.0, 2.5, 2.0] }                                        






















</code>
              </pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>

        <div style="height:1em;"></div>
        <h3 id="funcs">1.4 Source Code - Analysis.rs</h3>
        <t-b>
          Code in this block provides analysis and display functions used in the
          other code blocks.
        </t-b>
        <t-b>
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="anal-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('anal-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  analysis.rs
  - provides analysis and display functions for Objects demo.
-------------------------------------------------------------------*/

use std::fmt::*;

pub fn show_note(s:&str, n:usize) {
  let border = (0..n).map(|_| &quot;-&quot;).collect::&lt;String&gt;();
  println!(&quot;{}&quot;, &border);
  println!(&quot;  {}&quot;, s);
  println!(&quot;{}&quot;, &border);
}

pub fn show_op(s:&str) {
  println!(&quot;--- {:?} ---&quot;, s);
}

/*---------------------------------------------------------
  Show input's call name and type
  - doesn't consume input
  - show_type is generic function with Debug bound.
    Using format &quot;{:?}&quot; requires Debug.
  - used in show_type_scalar
*/
pub fn show_type&lt;T:Debug&gt;(_t: &T, nm: &str) {
    let typename = std::any::type_name::&lt;T&gt;();
    println!(&quot;{nm:?}, type: {typename:?}&quot;);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="anal-seperator"></splitter-bar>
            <second-item id="anal-second" style="width:40em;">
              <div class="textwrap noflow commentary" onclick="obubbleup('anal-first')">
                <h3>Analysis and Display Functions:</h3>
                This code block contains definitions of three functions:<br />
                &nbsp;&nbsp;&nbsp;- two non-generic display functions<br />
                &nbsp;&nbsp;&nbsp;- one generic analysis function<br />
                <br />
                <strong><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> </strong>
                <strong>Non-generic functions:</strong><br />
                <br />
                <c-s>show_note(s:&str, n:usize)</c-s> displays text between<br />
                long dotted lines, used to make output headings.<br />
                <br />
                <c-s>show_op(s:&str)</c-s> displays text inserted between<br />
                short dotted lines, used to show an operation that results<br />
                in a specific output.<br />
                <br /><br /><br /><br /><br /><br />
                <strong><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> </strong>
                <strong>Generic function:</strong><br />
                <br />
                <c-s>show_type&lt;T&gt;</c-s>&apos;s arguments are passed by reference.<br />
                So, references are copied; the arguments are not moved.<br />
                <br />
                That means that the instance being analyzed, <c-s>_t</c-s>, will<br />
                still be valid after the call.<br />
                <br />
                Note that using a leading underscore, as in <c-s>_t</c-s>, tells<br />
                the compiler not to warn about no use of that variable.<br />

              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="demo">1.5 Demos Execution - main.rs</h3>
        <t-b>
          All code in this section is used to conduct demonstrations, e.g., it is
          the contents of <c-s>main()</c-s> and the functions it invokes. That is broken up into
          sections for library types <c-s>String</c-s> and <c-s>Vec&lt;T&gt;</c-s>, and user-defined
          types <c-s>Point4D</c-s> and <c-s>PointNPrototype</c-s>.
        </t-b>
        <h3 id="demodclr">1.5.1 Structure</h3>
        <t-b>
          The code block, below, demonstrates program structure for main.rs.  It uses four functions
          to demonstrate <c-s>String</c-s>s, <c-s>Vec&lt;T&gt;</c-s>s, and two user-defined types <c-s>Point4D</c-s> and
          <c-s>PointNPrototype</c-s>.
        </t-b>
        <t-b>
          The program imports two modules, one that defines the point types, and one that
          supplies a set of functions used for analysis and display of these types.
        </t-b>
        <t-b>
          This partitioning makes the program code easier to understand and to maintain.
        </t-b>
        <t-b>
          You can find all the code for this demo
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust/rust_objects/src">here</a>
          and code for the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">here</a>.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="structure-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('structure-first')">
                <pre style="width:200em;"><code class="language-cpp">#![allow(dead_code)]
#![allow(clippy::approx_constant)]

/*---------------------------------------------------------
  rust_objects::main.rs
  - Demonstrates creation and use of Rust objects
  - Rust uses struct instead of class to create objects
*/
/*-----------------------------------------------
Note:
Find all Bits code, including this in
https://github.com/JimFawcett/Bits
You can clone the repo from this link.
-----------------------------------------------*/

mod analysis_objects;     // identify module source file
use analysis_objects::*;  // import public functs and types
mod points_objects;       // identify module source file
use points_objects::*;    // import public functs and types

fn demo_string_objects() {
  /*-- code elided --*/
}
fn demo_vector_objects() {
  /*-- code elided --*/
}
fn demo_user_defined_point4d() {
  /*-- code elided --*/
}
fn demo_user_defined_pointnprototype() {
  /*-- code elided --*/
}

/*---------------------------------------------------------
  Demo object instances in action
*/
fn main() {
    show_note(&quot;demonstrate object creation and use&quot;, 50);

    demo_string_objects();
    demo_vector_objects();
    demo_user_defined_point4d();
    demo_user_defined_pointnprototype();

    print!(&quot;&#92;nThat's all Folks!&#92;n&#92;n&quot;);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="structure-seperator"></splitter-bar>
            <second-item id="structure-second" style="width:40em;">
              <div class="textwrap noflow commentary" onclick="obubbleup('structure-first')">
<h3>Structure:</h3>
This is the first Rust demonstration that partitions its<br />
code into more than one file.<br />
<br />
<strong>Modules:</strong><br />
<br />
Rust defines modules to support partitioning. Here we<br />
have two of them, &quot;analysis_objects&quot; and 
&quot;points_objects&quot;.<br />
<br />
A Rust module is simply a file that implements program <br />
functionality focused in a single area, but has no main <br />
function, as only one main is allowed per program.<br />
<br />
Both module files, analysis_objects.rs and<br /> 
points_objects.rs are placed in the src directory along<br /> 
with main.rs. That makes it simple to import them, e.g.,<br />
no path required.<br />
<br />
That also means that a module can depend on code in <br />
another module.<br />
<br />
<strong>Functions:</strong><br />
<br />
All of the demonstration code is divided into functions <br />
for library types and user-defined types. Each function <br />
creates an instance of a type, illustrates access to <br />
values of the type and shows how to modify them.<br />
<br />
These demos do not cover type behaviors exhaustively.  <br />
They are intended to be relatively simple discussions <br />
that are easy to digest and remember.<br />
<br />
<br /><br /><br /><br /><br /><br />

<strong><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> Execution:</strong><br />
<br />
Execution starts with an entry to the function main().<br />
Each demonstraton is implemented with a type specific<br />
demo function.<br />
              </div>
            </second-item>
          </splitter-container>
        </div>

        <div style="height:1em;"></div>
        <h4 id="build">2.0 Build</h4>
        <t-b>
          The left panel shows a build using cargo in a terminal. Using VS Code, you can
          also initiate a build from the Run menu, selecting either debug or run without
          debugging. What happens in that run process is governed by the launch.json file
          in the .vscode folder. A view of that is shown in Fig 2., below.
        </t-b>
        <t-b>
          The right panel shows the
          Cargo.toml file contents that defines dependencies. Note that specified dependencies
          are likely to have their own dependencies and building on Windows induces a
          dependency.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <!-- <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" /> -->
          <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Terminal</strong></div>
          <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>cargo.toml</strong></div>
          <splitter-container id="container" class="clear">
            <first-item id="build-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('build-first')">
                <pre style="width:200em;"><code class="language-cpp">C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_objects
&gt; cargo build
   Compiling autocfg v1.1.0
   Compiling winapi v0.3.9
   Compiling libc v0.2.144
   Compiling num-traits v0.2.15
   Compiling num-integer v0.1.45
   Compiling time v0.1.45
   Compiling chrono v0.4.24
   Compiling rust_objects v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_objects)
    Finished dev [unoptimized + debuginfo] target(s) in 3.36s
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_objects
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="build-seperator"></splitter-bar>
            <second-item id="build-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('build-first')">
                <pre style="width:200em;"><code class="language-shell">[package]
name = "rust_objects"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
chrono = "0.4.24"
num-traits = "0.2.15"

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="vscode">3.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Rust\rust_hello_objects.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Rust_Objects.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - Rust Objects</span>
        </photosizer-block>
        <photosizer-block src="pictures/LaunchJSON_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 2. Rust Launch.JSON</span>
        </photosizer-block>
        <photosizer-block src="pictures/VS_Code_Debugging_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Rust Objects</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../RustStoryRepo.html">Rust Story</a>
            </td>
            <td>
              E-book with seven chapters covering most of intermediate Rust
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Intro.html">Rust Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Collects.html">Rust&nbsp;Collections</a>
            </td>
            <td>
              Table of Rust collections with each row containing a type declaration, description, and a diagram.
              Contains rows for array, tuple, Struct, Vec, VecDeque, HashMap, String, and str.
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content-block>
      <a id="bottom"></a>
      <div id="keys" class="hidden"></div>
      <div id="pages" class="hidden"></div>
      <div id="url" class="hidden">url</div>
      <div id="sections" class="hidden">
        <div class="darkItem listheader" onclick="hideElement('sections')">Sections</div>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <menu-elem class="secElem"><a href="#syn">synopsis</a></menu-elem>
        <menu-elem class="secElem"><a href="#aggtypes">aggr types</a></menu-elem>
        <menu-elem class="secElem"><a href="#notes">notes</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">code</a></menu-elem>
        <menu-elem class="secElem"><a href="#stdlib">stdlib</a></menu-elem>
        <menu-elem class="secElem"><a href="#demostr">strings</a></menu-elem>
        <menu-elem class="secElem"><a href="#demovec">vectors</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">points</a></menu-elem>
        <menu-elem class="secElem"><a href="#point4d">point4d</a></menu-elem>
        <menu-elem class="secElem"><a href="#movept">move point</a></menu-elem>
        <menu-elem class="secElem"><a href="#pointnp">pointN proto</a></menu-elem>
        <menu-elem class="secElem"><a href="#demoptnp">demo pointN proto</a></menu-elem>
        <menu-elem class="secElem"><a href="#funcs">analysis</a></menu-elem>
        <menu-elem class="secElem"><a href="#demo">execution</a></menu-elem>
        <menu-elem class="secElem"><a href="#demodclr">structure</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">build</a></menu-elem>
        <menu-elem class="secElem"><a href="#vscode">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">references</a></menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
      </div>
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:1em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </div>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn + ": ";
  </script>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 6, 10);
  </script>
  <script>
    onLoadSplitter("point4d");
    onLoadSplitter("pointproto");
    onLoadSplitter("structure");
    onLoadSplitter("anal");
    onLoadSplitter("build");
    onLoadSplitter("fig1");
    onLoadSplitter("fig2");
    onLoadSplitter("fig3");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
  </script>
</body>
</html>
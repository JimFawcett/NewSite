<!DOCTYPE html>
<html id="top">
<!--
  RustBites_Synchron.html
-->
<head>
  <title>Rust Synchronization</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    #github table.flashcard th {
      background-color: var(--dark);
      color: var(--atten);
    }
    #github table.flashcard td {
      font-size: 0.9rem;
      vertical-align: top;
    }
    #github table {
      max-width: 80%;
      border: 1px solid black;
      margin-top: 1em;
      margin-bottom: 1.0em;
    }

      #github table.flashcard {
        width: 100%;
        table-layout: fixed;
        border-collapse: collapse;
        border: 4px groove #222;
      }

        #github table.flashcard td {
          padding: 0.5rem 1.5rem;
          border: 4px groove #000;
          /*min-width:50px;*/
        }

        #github table.flashcard li {
          /*width:max-content;*/
          max-width: 30rem;
        }

        #github table.flashcard td {
          overflow: auto;
        }

        #github table.flashcard th.topic {
          width: 12rem;
        }

        #github table.flashcard td.topic {
          width: 10rem;
        }

        #github table.flashcard th.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td img {
          width: 100%;
          height: auto;
          padding: 0rem;
        }

      #github table.invis {
        width: 90%;
        border: none;
      }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr.invis {
          border: none;
        }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

          #github table tr th.invis {
            border: none;
          }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

          #github table tr td.invis {
            border: none;
          }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }

    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_Synchron.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/11/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Synchronization</h2>
        <h4 id="subtitle" class="indent">
          safe sharing with Mutex, RwLock, Condvar, Atomic, Arc, Barrier 
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>
    </header>
        <a id="intro"></a>
        <h2>1.0&nbsp;&nbsp;Introduction</h2>
        <t-b>
          <strong>Note:</strong> much of the material provided in the tables, below, was taken from the Rust std
          documentation.  The Barrier example code was also extracted, with minor modification, from the std::sync::Barrier
          documentation.
        </t-b>
        <t-b>
          Synchronization is the process of ensuring that, in a multi-threaded program, each thread gets exclusive
          access to a shared resource, usually by locking with a synchronization type.  The common synchronization
          types are listed in Table 1., below.
        </t-b>
        <t-b>
          <h4>Table 1. - Common Synchronization Types</h4>
          <table>
            <tr>
              <th>Type</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex&lt;T&gt;</a>
              </td>
              <td>
                A mutual exclusion primitive useful for protecting shared data.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html">RwLock&lt;T&gt;</a>
              </td>
              <td>
                A reader-writer lock allowing multiple readers or at most one writer at any point in time.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/struct.Condvar.html">Condvar</a>
              </td>
              <td>
                A Condition Variable blocks threads waiting on an event to occur.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/atomic/">Atomic</a>
              </td>
              <td>
                Atomic types provide primitive shared-memory communication between threads.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc&lt;T&gt;</a>
              </td>
              <td>
                A thread-safe reference-counting pointer. Arc is used to enable sharing of guarded resources
                in programs with multiple threads.  It holds its data in the heap.
                <div style="height:0.25rem;"></div>
              </td>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/struct.Barrier.html">Barrier</a>
              </td>
              <td>
                A barrier enables multiple threads to synchronize the beginning of some computation.
                <div style="height:0.25rem;"></div>
              </td>
            </tr>
            <tr>
              <th></th>
              <th></th>
            </tr>
          </table>
        </t-b>
        <a id="mutex"></a>
        <h2>2.0&nbsp;&nbsp;Mutex&lt;T&gt;</h2>
        <div class="indent">
          <t-b>
            The Rust <c-s>Mutex&lt;T&gt;</c-s> is a lock designed to grant a thread acquiring the lock exclusive
            access to its contained resource, <c-s>t&epsilon;T</c-s>.  Any other thread attempting to acquire the lock
            will block until the owning thread unlocks.
          </t-b>
          <t-b>
            Note that Rust <c-s>Mutexes</c-s> protect a specified data item, not regions of code.  Guarding regions
            makes it impossible for two threads to attempt to share the data with separate locks, an error that some
            other language libraries allow.
          </t-b>
          <h3>Table 2. - Mutex Methods:</h3>
          <table>
            <tr>
              <th>Method</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>
                <c-s>pub fn new(t: T) -> Mutex<T></c-s>
              </td>
              <td>
                Creates a new mutex in an unlocked state
              </td>
            </tr>
            <tr>
              <td>
                <c-s>pub fn lock(&self) -> LockResult&lt;MutexGuard&lt;'_, T&gt;&gt;</c-s>
              </td>
              <td>
                Acquires a mutex, blocking the current thread until it is able to do so.  The returned
                <c-s>MutexGuard&lt;'_, T&gt;</c-s>, wrapped in a <c-s>LockResult</c-s>, implicitly
                dereferences to provide access to the data.  It is dropped when it goes out of scope, releasing the lock.
              </td>
            </tr>
            <tr>
              <td>
                <c-s>pub fn try_lock(&self) -> TryLockResult&lt;MutexGuard&lt;'_, T&gt;&gt;</c-s>
              </td>
              <td>
                If the lock could not be acquired at this time, then Err is returned. Otherwise,
                an RAII guard is returned. The lock will be unlocked when the guard is dropped.
              </td>
            </tr>
            <tr>
              <td>
                <c-s>pub fn into_inner(self) -> LockResult&lt;T&gt; </c-s>
              </td>
              <td>
                Consumes this mutex, returning the underlying data
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">more methods ...</a>
              </td>
              <td>
                methods, descriptions, and examples
                <div style="height:0.25rem;"></div>
              </td>
            </tr>
            <tr>
              <th></th>
              <th></th>
            </tr>
          </table>
          <div>
            <details>
              <summary class="darkItem">Mutex Example</summary>
              <defn-OuterBlock>
                <defn-block>
                  <defn-head>Mutex Example</defn-head>
                  <defn-code>
// Demonstrate threads sharing string resource
#![allow(unused_imports)]
#![allow(dead_code)]

use std::thread;
use std::sync::{Mutex, RwLock, Condvar, Arc};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;

fn test_mutex() {
  /* define shared resource */
  let s = String::new();
  let share = Arc::new(Mutex::new(s));

  /* define reader processing */
  static RID:AtomicUsize = AtomicUsize::new(0usize);

  let rd_cls = |shared:Arc&lt;Mutex&lt;String&gt;&gt;| {
    /* fetch_add returns old value */
    let my_id = RID.fetch_add(1, Ordering::SeqCst) + 1;
    let dur = Duration::from_millis(2);
    for _i in 0..10 {
      if let Ok(temp) = shared.lock() {
        print!(
          "\n  reader {} : str len = {}",
          my_id, temp.len()
        );
      }
      thread::sleep(dur);
    }
  };

  /* start readers */
  let shared = Arc::clone(&share);
  let handle1 = thread::spawn(move || { rd_cls(shared); });

  let shared = Arc::clone(&share);
  let handle2 = thread::spawn(move || { rd_cls(shared); });

  /* define writer processing */
  static WID:AtomicUsize = AtomicUsize::new(2usize);

  let wr_cls = |shared:Arc&lt;Mutex&lt;String&gt;&gt;| {
    /* fetch_add returns old value */
    let my_id = WID.fetch_add(1, Ordering::SeqCst) + 1;
    let dur = Duration::from_millis(2);
    for _i in 0..10 {
      if let Ok(mut temp) = shared.lock() {
        let digit = my_id.to_string();
        temp.push_str(digit.as_str());
        print!(
          "\n  writer {} : str len = {}",
          my_id, temp.len()
        );
      }
      thread::sleep(dur);
    }
  };

  /* start writers */
  let shared = Arc::clone(&share);
  let handle3 = thread::spawn(move || { wr_cls(shared); });

  let shared = Arc::clone(&share);
  let handle4 = thread::spawn(move || { wr_cls(shared); });

  /* main thread waits for children to finish */
  let _ = handle1.join();
  let _ = handle2.join();
  let _ = handle3.join();
  let _ = handle4.join();

  /* lock will fail if thread holding lock panics */
  if let Ok(mod_str) = share.lock() {
    print!("\n  modified string: {:?}", mod_str);
  };
  /* semicolon needed to ensure mod_str lives long enough */
}

fn main() {
  test_mutex();
}
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output</defn-head>
                  <defn-code>
reader 1 : str len = 0
reader 1 : str len = 0
reader 1 : str len = 0
reader 1 : str len = 0
writer 3 : str len = 1
reader 2 : str len = 1
writer 4 : str len = 2
reader 1 : str len = 2
writer 3 : str len = 3
reader 1 : str len = 3
writer 4 : str len = 4
reader 2 : str len = 4
writer 3 : str len = 5
reader 1 : str len = 5
writer 4 : str len = 6
reader 2 : str len = 6
writer 3 : str len = 7
reader 1 : str len = 7
writer 4 : str len = 8
reader 2 : str len = 8
reader 1 : str len = 8
writer 3 : str len = 9
writer 4 : str len = 10
reader 2 : str len = 10
reader 1 : str len = 10
writer 4 : str len = 11
reader 2 : str len = 11
writer 4 : str len = 12
reader 2 : str len = 12
writer 3 : str len = 13
writer 4 : str len = 14
reader 2 : str len = 14
writer 3 : str len = 15
writer 4 : str len = 16
reader 2 : str len = 16
writer 3 : str len = 17
writer 4 : str len = 18
reader 2 : str len = 18
writer 3 : str len = 19
writer 3 : str len = 20
modified string:
"34343434344434343433"

                  </defn-code>
                </defn-block>
              </defn-OuterBlock>
            </details>
          </div>
          <t-b>
            <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c295752fef36c089b16cc8ac0d7402fa">
              mutex demo in playground
            </a>
          </t-b>
        </div>
        <a id="rwlock"></a>
        <h2>3.0&nbsp;&nbsp;RwLock&lt;T&gt;</h2>
        <div class="indent">
          <t-b>
            <c-s>RwLock&lt;T&gt;</c-s>s held by a reader allow any number of simultaneous readers to access its protected data
            simultaneously.  However, a <c-s>RwLock&lt;T&gt;</c-s> grants exclusive access to writers.  That is, only one
            writer may own the lock, and all others attempting to acquire the lock with block.
          </t-b>
          <h3>Table 3. - RwLock&lt;T&gt; Methods:</h3>
          <table>
            <tr>
              <th>Method</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><c-s>pub fn new(t: T) -> RwLock<T></c-s></td>
              <td>
                Creates a new instance of an RwLock<T> which is unlocked.
              </td>
            </tr>
            <tr>
              <td><c-s>pub fn read(&self) -> LockResult&lt;RwLockReadGuard&lt;'_, T&gt;&gt;</c-s></td>
              <td>
                Locks rwlock with shared read access, blocking current thread until it can be acquired.
              </td>
            </tr>
            <tr>
              <td><c-s>pub fn write(&self) -> LockResult&lt;RwLockWriteGuard&lt;'_, T&gt;&gt;</c-s></td>
              <td>
                Locks rwlock with exclusive write access, blocking current thread until it can be acquired.
              </td>
            </tr>
            <tr>
              <td><c-s>pub fn into_inner(self) -> LockResult&lt;T&gt;</c-s></td>
              <td>
                Consumes RwLock, returning underlying data.
              </td>
            </tr>
            <tr>
              <td><a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html">more methods ...</a></td>
              <td>
                methods, descriptions, and examples
                <div style="height:0.25rem;"></div>
              </td>
            </tr>
            <tr>
              <th></th>
              <th></th>
            </tr>
          </table>
          <div>
            <details>
              <summary class="darkItem">RwLock Example</summary>
              <defn-OuterBlock>
                <defn-block>
                  <defn-head>RwLock Example</defn-head>
                  <defn-code>
// Demonstrate threads sharing string resource
#![allow(unused_imports)]
#![allow(dead_code)]

use std::thread;
use std::sync::{Mutex, RwLock, Condvar, Arc};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;

fn test_rwlock() {
  /* define shared resource */
  let s = String::new();
  let share = Arc::new(RwLock::new(s));

  /* define reader processing */
  static RID:AtomicUsize = AtomicUsize::new(0usize);

  let rd_cls = |shared:Arc&lt;RwLock&lt;String&gt;&gt;| {
    let my_id = RID.fetch_add(1, Ordering::SeqCst) + 1;
    let dur = Duration::from_millis(2);
    for _i in 0..10 {
        if let Ok(temp) = shared.read() {
            print!(
                "\n  reader {} : str len = {}",
                my_id, temp.len()
            );
        }
        thread::sleep(dur);
    }
  };

  /* start readers */
  let shared = Arc::clone(&share);
  let handle1 = thread::spawn(move || { rd_cls(shared); });

  let shared = Arc::clone(&share);
  let handle2 = thread::spawn(move || { rd_cls(shared); });

  let shared = Arc::clone(&share);
  let handle3 = thread::spawn(move || { rd_cls(shared); });

  let shared = Arc::clone(&share);
  let handle4 = thread::spawn(move || { rd_cls(shared); });

  /* define writer processing */
  static WID:AtomicUsize = AtomicUsize::new(4usize);

  let wr_cls = |shared:Arc&lt;RwLock&lt;String&gt;&gt;| {
      let my_id = WID.fetch_add(1, Ordering::SeqCst) + 1;
      let dur = Duration::from_millis(2);
      for _i in 0..10 {
          if let Ok(mut temp) = shared.write() {
              let digit = my_id.to_string();
              temp.push_str(digit.as_str());
              print!(
                  "\n  writer {} : str len = {}",
                  my_id, temp.len()
              );
          }
          thread::sleep(dur);
      }
  };

  /* start writers */
  let shared = Arc::clone(&share);
  let handle5 = thread::spawn(move || { wr_cls(shared); });

  let shared = Arc::clone(&share);
  let handle6 = thread::spawn(move || { wr_cls(shared); });

  /* main thread waits for children to finish */
  let _ = handle1.join();
  let _ = handle2.join();
  let _ = handle3.join();
  let _ = handle4.join();
  let _ = handle5.join();
  let _ = handle6.join();

  /* lock will fail if thread holding lock panics */
  if let Ok(mod_str) = share.read() {
      print!("\n  modified string: {:?}", *mod_str);
  };
  /*
      semicolon needed here to ensure mod_str lives
      long enough
  */
}

fn main() {
    test_rwlock();
}

                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output</defn-head>
                  <defn-code>
reader 1 : str len = 0
reader 1 : str len = 0
writer 5 : str len = 1
writer 6 : str len = 2
reader 2 : str len = 2
reader 3 : str len = 2
reader 4 : str len = 2
writer 5 : str len = 3
writer 6 : str len = 4
reader 2 : str len = 4
reader 3 : str len = 4
reader 1 : str len = 4
reader 4 : str len = 4
writer 5 : str len = 5
writer 6 : str len = 6
reader 2 : str len = 6
reader 3 : str len = 6
reader 4 : str len = 6
reader 1 : str len = 6
writer 5 : str len = 7
writer 6 : str len = 8
reader 2 : str len = 8
reader 3 : str len = 8
reader 4 : str len = 8
reader 1 : str len = 8
writer 5 : str len = 9
writer 6 : str len = 10
reader 2 : str len = 10
reader 3 : str len = 10
reader 4 : str len = 10
reader 1 : str len = 10
writer 5 : str len = 11
writer 6 : str len = 12
reader 2 : str len = 12
reader 3 : str len = 12
reader 4 : str len = 12
reader 1 : str len = 12
writer 5 : str len = 13
writer 6 : str len = 14
reader 2 : str len = 14
reader 3 : str len = 14
reader 4 : str len = 14
reader 1 : str len = 14
writer 5 : str len = 15
writer 6 : str len = 16
reader 2 : str len = 16
reader 3 : str len = 16
reader 4 : str len = 16
reader 1 : str len = 16
writer 5 : str len = 17
writer 6 : str len = 18
reader 2 : str len = 18
reader 3 : str len = 18
reader 4 : str len = 18
reader 1 : str len = 18
writer 5 : str len = 19
writer 6 : str len = 20
reader 2 : str len = 20
reader 3 : str len = 20
reader 4 : str len = 20
modified string: "56565656565656565656"
                  </defn-code>
                </defn-block>
              </defn-OuterBlock>
            </details>
          </div>
          <t-b>
            <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=eb258e20ac00ee505d54786364e33f87">
              rwlock demo in playground
            </a>
          </t-b>
        </div>
        <a id="condvar"></a>
        <h2>4.0&nbsp;&nbsp;Condvar</h2>
        <div class="indent">
          <t-b>
            <c-s>Condvar</c-s> supports one thread sending notifications to other waiting threads.  Threads that need
            a result from the notifying thread block by calling <c-s>wait</c-s> method on the <c-s>Condvar</c-s> instance.
          </t-b>
          <t-b>
            Condvar instances are associated with a <c-s>Mutex</c-s> that guards information about the event.  A notifier
            locks the <c-s>Mutex</c-s>, sets the information state, and then calls <c-s>notify_one</c-s> or <c-s>notify_all</c-s>
            on the <c-s>Condvar</c-s>.
          </t-b>
          <t-b>
            Threads that subscribe to the notification lock the <c-s>Mutex</c-s> and then call <c-s>wait</c-s> on the
            <c-s>Condvar</c-s> instance. <c-s>Condvars</c-s> do a special dance to avoid deadlocking by blocking the
            notifier.  When <c-s>wait</c-s> is called the <c-s>Condvar</c-s> library code puts the subscribing thead to sleep
            and releases the lock so that notifiers can gain access.  When a notification is called the library code acquires
            the lock, wakes the waiting thread, and locks.
          </t-b>
          <h3>Table 4. - Condvar Methods:</h3>
          <table>
            <tr>
              <th>Methods</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><c-s>pub fn new() -> Condvar</c-s></td>
              <td>
                Creates new condition variable ready to be waited on and notified.
              </td>
            </tr>
            <tr>
              <td>
                <c-s>
                  pub&nbsp;fn&nbsp;wait<'a,&nbsp;T>(&self,&nbsp;guard:&nbsp;MutexGuard<'a,&nbsp;T>)<br />
                  -> LockResult&lt;MutexGuard&lt;'a, T&gt;&gt;
                </c-s>
              </td>
              <td>
                Blocks current thread until condition variable receives a notification.
              </td>
            </tr>
            <tr>
              <td><c-s>pub fn notify_one(&self)</c-s></td>
              <td>
                Wakes up one blocked thread on this condvar.
              </td>
            </tr>
            <tr>
              <td><c-s>pub fn notify_all(&self)</c-s></td>
              <td>
                Wakes up all blocked threads on this condvar.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://doc.rust-lang.org/std/sync/struct.Condvar.html">more methods ...</a>
              </td>
              <td>
                methods, descriptions, and examples
                <div style="height:0.25rem;"></div>
              </td>
            </tr>
            <tr>
              <th></th>
              <th></th>
            </tr>
          </table>
          <t-b>
            The following example, repeated from the thread Bite, uses a <c-s>Condvar</c-s> to implement a &quot;Future&quot;
            construct that is useful for returning results from threads.
          </t-b>
          <div>
            <details>
              <summary class="darkItem">Condvar Example</summary>
              <defn-OuterBlock>
                <defn-block>
                  <defn-head>ThreadResult&lt;T&gt;</defn-head>
                  <defn-code>
////////////////////////////////////////////////
// thread_result::lib.rs                      //
//     - Wait for thread to complete          //
//                                            //
// Jim Fawcett, https://JimFawcett.github.io  //
////////////////////////////////////////////////

#![allow(clippy::mutex_atomic)]
#![allow(dead_code)]
use std::sync::*;
use std::fmt::Debug;

#[derive(Debug, Default)]
pub struct ThreadResult&lt;T&gt; {
  pub result: Mutex&lt;T&gt;,
  cv: Condvar,
  ready: Mutex&lt;bool&gt;
}

impl&lt;T: Debug + Default + Clone&gt; ThreadResult&lt;T&gt; {
  pub fn new() -&gt; Self {
    Self {
        result: Mutex::new(T::default()),
        cv: Condvar::new(),
        ready: Mutex::new(false),
      }
    }
  /*--------------------------------------------
    Unwrapping is appropriate here.  The
    operation fails if the Mutex becomes
    poisoned, due to panic on a thread
    holding the lock.  But then you can't
    do much except quit, which the unwrap
    does for you.
  --------------------------------------------*/
  pub fn set(&self, t:T) {
    let mut lr = self.ready.lock().unwrap();
    *lr = true;
    let mut lrslt = self.result.lock().unwrap();
    *lrslt = t;
    self.cv.notify_all();
  }
  pub fn get(&self) -&gt; T {
    let mut rdy = self.ready.lock().unwrap();
    while !*rdy {
      rdy = self.cv.wait(rdy).unwrap();
    }
    let rslt = self.result.lock().unwrap();
    rslt.clone()
  }
  pub fn ready(&self) -&gt; bool {
    *self.ready.lock().unwrap()
  }
}
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Using Code</defn-head>
                  <defn-code>
////////////////////////////////////////////////
// thread_result::test1.rs                    //
//     - basic ThreadResult test              //
//                                            //
// Jim Fawcett, https://JimFawcett.github.io  //
////////////////////////////////////////////////

use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant};

fn test() {
  let thrd_rslt
    = Arc::new(ThreadResult::&lt;i32&gt;::new());
  let thrd_rslt1 = Arc::clone(&thrd_rslt);
  let thrd_rslt2 = Arc::clone(&thrd_rslt);

  let cls = |share:Arc&lt;ThreadResult&lt;i32&gt;&gt;| {
    print!("\n  starting thread");
    let dur = Duration::from_millis(100u64);
    thread::sleep(dur);
    share.set(42);
  };
  let handle1 = thread::spawn(
    move || {cls(thrd_rslt1).clone()}
  );

  print!("\n  -- poll for result --");
  let dur = Duration::from_millis(20);
  loop {
    print!("\n  main polling");
    if !thrd_rslt2.ready() {
      thread::sleep(dur);
    }
    else {
      print!(
        "\n  thread result is {}\n",
        thrd_rslt2.get()
      );
      break;
    }
  }
  print!("\n  -- wait for result --");
  let thrd_rslt
    = Arc::new(ThreadResult::&lt;i32&gt;::new());
  let thrd_rslt1 = Arc::clone(&thrd_rslt);
  let thrd_rslt2 = Arc::clone(&thrd_rslt);

  let dur = Duration::from_millis(50);
  let now = Instant::now();
  let handle2 = thread::spawn(
    move || {cls(thrd_rslt1).clone()}
  );
  thread::sleep(dur);
  let elapsed = now.elapsed().as_millis();
  print!(
    "\n  after {:?} millis calling get()",
    elapsed
  );
  let rslt = thrd_rslt2.get();
  let elapsed = now.elapsed().as_millis();
  print!(
    "\n  at {:?} millis, thread result is {}",
    elapsed, rslt
  );

  let _ = handle1.join();
  let _ = handle2.join();
  println!();
}

fn main() {
  test();
}
                  </defn-code>
                  <defn-head class="defnBorderTop">Output</defn-head>
                  <defn-code>
-- poll for result --
main polling
starting thread
main polling
main polling
main polling
main polling
main polling
thread result is 42

-- wait for result --
starting thread
after 50 millis calling get()
at 100 millis, thread result is 42
                  </defn-code>
                </defn-block>
              </defn-OuterBlock>
            </details>
          </div>
          <t-b>
            <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=56d47eafa4d2859a81b6cecdf40b68b2">
              Condvar example in playground
            </a>
          </t-b>
        </div>
        <a id="atomics"></a>
        <h2>5.0&nbsp;&nbsp;Atomics</h2>
        <div class="indent">
          <t-b>
            Atomics are a group of thread-safe constructs including: <c-s>AtomicBool</c-s>, <c-s>AtomicI32</c-s>,
            <c-s>AtomicU8</c-s>, <c-s>AtomicUsize</c-s>, ...
          </t-b>
          <div>
            <h3>Table 5. - AtomicBool and AtomicUsize Methods</h3>
            <table>
              <tr>
                <th>Method</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <c-s>AtomicBool</c-s>
                </td>
                <td>Ordering: Acquire, Relaxed, SeqCst</td>
              </tr>
              <tr>
                <td><c-s>pub const fn new(v: bool) -> AtomicBool</c-s></td>
                <td>
                  Creates a new AtomicBool.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn load(&self, order: Ordering) -> bool</c-s></td>
                <td>
                  Loads a value from the bool.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn store(&self, val: bool, order: Ordering)</c-s></td>
                <td>
                  Stores a value into its bool.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn swap(&self, val: bool, order: Ordering) -> bool</c-s></td>
                <td>
                  Stores value into its bool, returning previous value.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn into_inner(self) -> bool</c-s></td>
                <td>
                  Consumes atomic and returns contained value.
                </td>
              </tr>
              <tr>
                <td><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html">more methods ...</a></td>
                <td>
                  methods, descriptions, and examples
                  <div style="height:0.25rem;"></div>
                </td>
              </tr>
              <tr>
                <th colspan="2"></th>
              </tr>
              <tr>
                <td>AtomicUsize</td>
                <td>Ordering: Acquire, Relaxed, SeqCst</td>
              </tr>
              <tr>
                <td><c-s>pub const fn new(v: usize) -> AtomicUsize</c-s></td>
                <td>
                  Creates a new atomic integer.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn load(&self, order: Ordering) -> usize</c-s></td>
                <td>
                  Loads value from atomic integer.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn store(&self, val: usize, order: Ordering)</c-s></td>
                <td>
                  Stores value into atomic integer.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn fetch_add(&self, val: usize, order: Ordering) -> usize</c-s></td>
                <td>
                  Adds to the current value, returning the previous value.
                </td>
              </tr>
              <tr>
                <td><c-s>pub fn into_inner(self) -> usize</c-s></td>
                <td>
                  Consumes atomic and returns contained value.
                </td>
              </tr>
              <tr>
                <td><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html">more methods ...</a></td>
                <td>
                  methods, descriptions, and examples
                  <div style="height:0.25rem;"></div>
                </td>
              </tr>
              <tr>
                <th colspan="2"></th>
              </tr>
              <tr>
                <td><a href="https://doc.rust-lang.org/std/sync/atomic/index.html">more types ...</a></td>
                <td>
                  AtomicI8, ...
                  <div style="height:0.25rem;"></div>
                </td>
              </tr>
              <tr>
                <th colspan="2"></th>
              </tr>
            </table>
          </div>
          <t-b>
            The following example, repeated from the thread Bite, uses an <c-s>AtomicUsize</c-s> to count child thread operations and
            share count value with main thread.
          </t-b>
          <div>
            <details>
              <summary class="darkItem">AtomicUsize Example</summary>
              <defn-OuterBlock>
                <defn-block>
                  <defn-head>Basic Thread Demo</defn-head>
                  <defn-code>
// Basic Threads
// sharing std::output and AtomicUsize - both thread safe

use std::thread;
use std::time::Duration;
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNT: AtomicUsize = AtomicUsize::new(0usize);

fn test() {
  // child thread processing
  let dur = Duration::from_millis(2);
  let handle = thread::spawn(
    move || {
      for _i in 0..10 {
        print!("\n  child thread printing");
        let _ = COUNT.fetch_add(1, Ordering::SeqCst);
        thread::sleep(dur);
      }
    }
  );
  // main thread processing
  let dur = Duration::from_millis(3);
  for _i in 0..10 {
    print!("\n   main thread printing");
    let _ = COUNT.fetch_add(1, Ordering::SeqCst);
    thread::sleep(dur);
  }
  // wait for thread to complete
  let _ = handle.join();
  print!("\n\n  number of prints = {:?}", COUNT);
}

fn main() {
  print!("\n  -- Basic Threads --\n");
  test();
  print!("\n\n  That's all Folks!\n\n");
}
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output</defn-head>
                  <defn-code>
-- Basic Threads --

main thread printing
child thread printing
child thread printing
child thread printing
main thread printing
child thread printing
main thread printing
child thread printing
main thread printing
child thread printing
child thread printing
main thread printing
child thread printing
main thread printing
child thread printing
child thread printing
main thread printing
main thread printing
main thread printing
main thread printing

number of prints = 20

That's all Folks!
                  </defn-code>
                </defn-block>
              </defn-OuterBlock>
            </details>
          </div>
          <t-b>
            <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c792e1f6af676048cbe51fce925085d5">
              code in playground
            </a>
          </t-b>
        </div>
        <a id="barrier"></a>
        <h2>6.0&nbsp;&nbsp;Barrier</h2>
        <div class="indent">
          <t-b>
            Barriers enable multiple threads to synchronize beginning of their computations.  All waiting threads start at
            essentially the same time.  This avoids a thread, collaborating with several other threads, from starting before
            the others are ready.
          </t-b>
          <h3>Table 6. - Barrier Methods</h3>
          <table>
            <tr>
              <th>Method</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><c-s>pub fn new(n: usize) -> Barrier</c-s></td>
              <td>
                Creates a new barrier that can block a given number of threads.
              </td>
            </tr>
            <tr>
              <td><c-s>pub fn wait(&self) -> BarrierWaitResult</c-s></td>
              <td>
                Blocks the current thread until all threads have rendezvoused here.
                <div style="height:0.25rem"></div>
              </td>
            </tr>
            <tr>
              <th></th>
              <th></th>
            </tr>
          </table>
          <details>
            <summary class="darkItem">Barrier Example</summary>
            <defn-OuterBlock>
              <defn-block>
                <defn-head>Barrier Example</defn-head>
                <defn-code>
////////////////////////////////////////////////
// Barrier Demos                              //
//     - Wait for all threads to start        //
//                                            //
// Jim Fawcett, https://JimFawcett.github.io  //
////////////////////////////////////////////////

use std::sync::{Arc, Barrier};
use std::thread;
use std::thread::JoinHandle;


fn main() {

  let mut handles:Vec&lt;JoinHandle&lt;()&gt;&gt; =
    Vec::with_capacity(5);
  let barrier = Arc::new(Barrier::new(5));

  for i in 0..5 {
    let c:Arc&lt;Barrier&gt; = barrier.clone();
    handles.push(thread::spawn(move|| {
      println!(
        "Thread {} paused...awaiting other threads",
        i
      );
      c.wait();
      println!("Thread {} processing done", i);
    }));
  }

  // Wait for all threads to complete execution
  for handle in handles {
    handle.join().unwrap();
  }
}

                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output</defn-head>
                <defn-code>
Thread 0 paused...awaiting other threads
Thread 1 paused...awaiting other threads
Thread 2 paused...awaiting other threads
Thread 3 paused...awaiting other threads
Thread 4 paused...awaiting other threads
Thread 0 processing done
Thread 4 processing done
Thread 1 processing done
Thread 3 processing done
Thread 2 processing done

                </defn-code>
              </defn-block>
            </defn-OuterBlock>
          </details>
          <t-b>
            <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=cc34984ce28f678605637670410e1a87">
              Barrier example in playground
            </a>
          </t-b>
        </div>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#mutex">mutex</a>
        <a href="#rwlock">rwlock</a>
        <a href="#condvar">convar</a>
        <a href="#atomics">atomics</a>
        <a href="#barrier">barrier</a>
        <!-- <a href="#refs">refs</a> -->
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 32, 10);
  </script>
</body>
</html>
<!DOCTYPE html>
<html id="top">
<!--
  RustBites_TipsAndTricks.html
-->
<head>
  <title>Rust Hacks &amp; Helpers</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    #github table.flashcard th {
      background-color: var(--dark);
      color: var(--atten);
    }
    #github table.flashcard td {
      font-size: 0.9rem;
      vertical-align: top;
    }
    #github table {
      max-width: 80%;
      border: 1px solid black;
      margin-top: 1em;
      margin-bottom: 1.0em;
    }

      #github table.flashcard {
        width: 100%;
        table-layout: fixed;
        border-collapse: collapse;
        border: 4px groove #222;
      }

        #github table.flashcard td {
          padding: 0.5rem 1.5rem;
          border: 4px groove #000;
          /*min-width:50px;*/
        }

        #github table.flashcard li {
          /*width:max-content;*/
          max-width: 30rem;
        }

        #github table.flashcard td {
          overflow: auto;
        }

        #github table.flashcard th.topic {
          width: 12rem;
        }

        #github table.flashcard td.topic {
          width: 10rem;
        }

        #github table.flashcard th.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td img {
          width: 100%;
          height: auto;
          padding: 0rem;
        }

      #github table.invis {
        width: 90%;
        border: none;
      }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr.invis {
          border: none;
        }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

          #github table tr th.invis {
            border: none;
          }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

          #github table tr td.invis {
            border: none;
          }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }

    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_TipsAndTricks.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/11/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Tips and Tricks</h2>
        <h4 id="subtitle" class="indent">
          ironing out wrinkles in tricky code - tricky, of course, is in the eye of the beholder
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>
    </header>
        <t-b>
          This Bite presents techniques for solving code problems that I encountered or which
          appear often in QA forums.  Of course there are many of those.  I've selected ones that I
          thought were interesting.
        </t-b>
        <t-b>
          I expect to add to this page continuously as I work on Rust-based projects.
        </t-b>
        <a id="member-thread"></a>
        <h2>1.0&nbsp;&nbsp;Struct with method hosting thread</h2>
        <t-b>
          Asynchronous processing often needs to share some mutable data with the thread host.
          For a method, that usually means sharing member data of a host object.  But that needs to
          be constructed carefully so that:
          <ol class="tight mtz" style="padding-top:0px; margin-left:2em;">
            <li>
              Both read and write access needs to be serialized to satisfy the Rust ownership
              policies.  We do that with a Mutex.
            </li>
            <li>
              The construction needs to guarantee that the thread&apos;s reference won&apos;t
              become invalid if the thread outlives the host object.  We do that by using an
              Arc, a thread-safe reference-counted pointer.  The Arc stores its content
              on the heap, returning a reference to that.  Any other code that needs access
              to the Arc&apos;s data calls Arc::clone(&original).  Now, the content will live
              until every reference to it has been dropped.
            </li>
          </ol>
        </t-b>
        <t-b>
          Compiler error messages give a lot of help: lifetime errors are usually problems
          handling the Arc correctly. Move errors are often attempting to use a value instead
          of a reference in the thread.
        </t-b>
        <t-b>
          You will find code for all examples below in
          <a href="https://github.com/JimFawcett/Consuming_Rust_bite_by_byte">
            RustBiteByByte/hacks_and_helps/methods_with_threads
          </a>
        </t-b>
        <div style="height:0.1em;"></div>
        <a id="start"></a>
        <h3>1.1 - User-defined Type with thread start() method</h3>
        <t-b>
          This example is a simple demo that sums a loop index in its thread closure.  This
          same technique was used in the <a href="../../RustComm.html">RustComm</a> library
          that does something much more useful; it uses message passing to communicate between
          two endpoints using std::net::TcpStream and std::net::TcpListener.
        </t-b>
        <div>
          <defn-outerBlock style="width:calc(100vw - 6rem);">
            <defn-block>
              <defn-head>Test1 - User-defined type with thread start()</defn-head>
              <defn-code>
use std::thread::{JoinHandle};
use std::sync::{Arc, Mutex};

struct Test1 {
  count: Arc&lt;Mutex&lt;i32&gt;&gt;,
}
impl Test1 {
  fn new() -&gt; Test1 {
    Test1 {
      count: Arc::new(Mutex::new(0)),
    }
  }
  fn start(&amp;mut self) -&gt; JoinHandle&lt;()&gt; {
    /* get a shared pointer */
    let local_count = self.count.clone();
    std::thread::spawn(move || {
      for i in 0..5 {
        let mut data = local_count.lock().unwrap();
        *data += i;
        print!("\n  {:?}", data);
      }
    })
  }
  fn show_count(&amp;self) {
    print!(
      "\n\n  t1 result = {:?}",
      self.count.lock().unwrap()
    );
  }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
fn main() {

  print!("\n  -- demo Test1 --");
  let mut t1 = Test1::new();
  let handle = t1.start();

  /* do some useful work here */

  let _ = handle.join();
  t1.show_count();
  println!();
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo Test1 --
0
1
3
6
10

t1 result = 10
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </div>
        <s-halfEm></s-halfEm>
        <t-b>
          <div style="height:0.1em;"></div>
          <a id="new"></a>
          <h3>1.2&nbsp;&nbsp;User-defined Type with thread starting in constructor new()</h3>
        </t-b>
        <t-b>
          The code below illustrates how to start a thread in the type&apos;s
          constructor, new().  That would be appropriate if an instance&apos;s functionality
          depended on the thread running.
        </t-b>
        <div>
          <defn-outerBlock style="width:calc(100vw - 6rem);">
            <defn-block>
              <defn-head>Test3 - thread starting in new()</defn-head>
              <defn-code>
struct Test3 {
  counter: Arc&lt;Mutex&lt;i32&gt;&gt;,
}
impl Test3 {
  /*-----------------------------------------------------
    This example uses the same technique as Test1, but
    moves the thread into new(), the Test3 constructor.
    That would be a good idea for any type whose instances
    need the running thread to operate as expected.

    Note that new() now returns a tuple with the newly
    constructed Test2 instance and the thread handle.
    Look at main to see how that is used.
  */
  fn new() -&gt; (Test3, JoinHandle&lt;()&gt;) {

    /* create mutex guarded i32 in heap memory */
    let scount = Arc::new(Mutex::new(0));

    /* create shared reference to that value */
    let share = Arc::clone(&amp;scount);

    /* scount is moved into thread&apos;s closure */

    let handle = std::thread::spawn(move || {
      for i in 0..5 {
        let mut data = scount.lock().unwrap();
        *data += i;
        print!("\n  {:?}", data);
      }
    });
    /* share holds a valid ref to guarded i32 in heap */
    (
      Test3 { counter: share, },
      handle
    )
  }
  fn show_count(&amp;self) {
    print!(
      "\n\n  t3 result = {:?}",
      self.counter.lock().unwrap()
    );
  }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
fn main() {

  print!("\n  -- demo Test3 --");
  let (t3, handle) = Test3::new();

  /* do some useful work here */

  let _ = handle.join();
  t3.show_count();
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo Test3 --
0
1
3
6
10

t3 result = 10
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </div>
        <t-b>
          <div style="height:0.1em;"></div>
          <a id="stop"></a>
          <h3>1.3 - User-defined Type with stop() method</h3>
        </t-b>
        <t-b>
          This example illustrates how to stop an asynchrounous method with a user command.
          The Test4 type provides an AtomicBool to record the user&apos;s intent to stop,
          and a method, stop(), to reset it.
        </t-b>
        <t-b>
          The method show_count() displays the number of thread iterations before being
          stopped by the user.
        </t-b>
        <div>
          <defn-outerBlock style="width:calc(100vw - 6rem);">
            <defn-block>
              <defn-head>Test4 - graceful thread stop</defn-head>
              <defn-code>
struct Test4 {
  counter: Arc&lt;Mutex&lt;i32&gt;&gt;,
  do_run : Arc&lt;AtomicBool&gt;,
}
impl Test4 {
  /*-----------------------------------------------------
    This example demonstrates graceful thread shutdown
    using an AtomicBool, set by the user and tested in
    the thread loop.
  */
  fn new() -&gt; (Test4, JoinHandle&lt;()&gt;) {
    let scount = Arc::new(Mutex::new(0));
    let share = Arc::clone(&amp;scount);
    let run = Arc::new(AtomicBool::new(true));
    let run_clone = Arc::clone(&amp;run);
    let handle = std::thread::spawn(move || {
      for i in 0..5000 {
        if !run.load(Ordering::Relaxed) {
          break;
        }
        /* slow down loop for display */
        std::thread::sleep(
          Duration::from_micros(200)
        );
        let mut data = scount.lock().unwrap();
        *data = i;
        print!("\n  {:?}", data);
      }
    });
    (
      Test4 {
        counter: share, do_run: run_clone
      },
      handle
    )
  }
  fn stop(&amp;self) {
    self.do_run.store(false, Ordering::Relaxed);
  }
  fn show_count(&amp;self) {
    print!(
      "\n\n  t4 result = {:?}",
      self.counter.lock().unwrap()
    );
  }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
fn main() {

  print!(
    "\n  -- demo Test4 - graceful stop --"
  );
  let (t4, handle) = Test4::new();
  std::thread::sleep(
    Duration::from_millis(100)
  );
  t4.stop();
  let _ = handle.join();
  t4.show_count();
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo Test4 - graceful stop --
0
1
2
3
4
5
6
7

t4 result = 7
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </div>
        <t-b>
        </t-b>
        <a id="date-time"></a>
        <h2>2.0 - Dates and Times</h2>
        <t-b>
          This section presents date and time tools for testing and logging.
        </t-b>
        <div style="height:0.1em;"></div>
        <a id="stopwatch"></a>
        <h3>2.1 - StopWatch</h3>
        <t-b>
          StopWatch is a user-defined type that measures time that elapses
          between calls to StopWatch::start() and StopWatch::stop().
        </t-b>
        <t-b>
          I&apos;ve used it to test the performance and throughtput of
          <a href="../../RustComm.html">RustComm</a>.
        </t-b>
        <div>
          <defn-outerBlock style="width:calc(100vw - 6rem);">
            <defn-block>
              <defn-head>StopWatch</defn-head>
              <defn-code>
extern crate chrono;

/*-----------------------------------------------
  StopWatch type measures elapsed times
*/
use std::time::*;
use std::{thread};
use std::thread::{JoinHandle};
use std::fmt::*;

#[derive(Debug, Clone, Copy)]
pub struct StopWatch {
  start: Instant,
  elapsed: Duration,
}
impl StopWatch {
  pub fn new() -&gt; StopWatch {
    StopWatch {
      start: Instant::now(),
      elapsed: Duration::new(0,0),
    }
  }
  pub fn start(&amp;mut self) {
    self.start = Instant::now();
  }
  pub fn stop(&amp;mut self) -&gt; Duration {
    self.elapsed = self.start.elapsed();
    self.elapsed
  }
  pub fn elapsed_micros(&amp;self) -&gt; u128  {
    self.elapsed.as_micros()
  }
  pub fn elapsed_millis(&amp;self) -&gt; u128 {
    self.elapsed.as_millis()
  }
  pub fn elapsed_secs(&amp;self) -&gt; u64 {
    self.elapsed.as_secs()
  }
}

fn sleep(millisec:u64) {
  let secs = Duration::from_millis(millisec);
  thread::sleep(secs);
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
/*-----------------------------------------------
  stop_watch displays thread sleep time
  - expect small variations from run to run
    due to uncertainty in sleep interval
*/
fn stop_watch(millisec: u64) {
  let mut sw = StopWatch::new();
  sleep(millisec);
  let time = sw.stop().as_millis();
  print!("\n  elapsed time = {:?}",time);
}

fn main() {
  print!("\n  -- demo StopWatch --");
  stop_watch(25);
  println!();
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo StopWatch --
elapsed time = 26
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </div>
        <t-b>

          <a id="callback"></a>
          <div style="height:0.1em;"></div>
        </t-b>
        <h3>2.2&nbsp;&nbsp;Timer emits callback</h3>
        <t-b>
          Timer start accepts a time in milliseconds and a closure to run at the end of that time.
        </t-b>
        <div>
          <defn-outerBlock style="width:calc(100vw - 6rem);">
            <defn-block>
              <defn-head>Timer</defn-head>
              <defn-code>
/*-----------------------------------------------
  Timer instance invokes callback after
  specified time.
  - callback runs on Timer thread
*/
#[derive(Debug, Clone, Copy)]
struct Timer {
  start: Instant,
  elapsed: Duration,
}
impl Timer {
  pub fn new(time: u64) -&gt; Timer {
    Timer {
      start: Instant::now(),
      elapsed: Duration::new(time, 0),
    }
  }
  pub fn start&lt;F&gt;(&amp;mut self, time: u64, callback:F)
  -&gt; JoinHandle&lt;()&gt;
    where F:FnOnce() + Send + 'static {
    self.start = Instant::now();
    let handle = thread::spawn(move || {
      let ttw = Duration::from_millis(time);
      thread::sleep(ttw);
      callback();
    });
    handle
  }
}
/*-----------------------------------------------
  Demo Timer, using closure callback
*/
fn timer(millisec: u64) -&gt; JoinHandle&lt;()&gt; {
  let mut tmr = Timer::new(millisec);
  let cl = move || {
    print!(
      "\n  time's up after {:?} milliseconds",
      millisec
    )
  };
  tmr.start(millisec, cl)
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
fn main() {

  print!("\n  -- demo Timer --");
  print!("\n  starting timer(200)");
  let handle = timer(200);
  print!(
    "\n  do some work while waiting for timer"
  );
  let _ = handle.join();
  println!();
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo Timer --
starting timer(200)
do some work while waiting for timer
time's up after 200 milliseconds
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </div>
        <div style="height:0.1em;"></div>
        <a id="stamps"></a>
        <h3>2.3&nbsp;&nbsp;Date-Time Stamps</h3>
        <t-b>
          Date-time stamps are used for display, often while logging or recording
          test data.
        </t-b>
        <div>
          <defn-outerBlock style="width:calc(100vw - 6rem);">
            <defn-block>
              <defn-head>Time and Date</defn-head>
              <defn-code>
/*-----------------------------------------------
  Date-Time stamp
*/
#[allow(unused_imports)]
use chrono::{DateTime, Local, Datelike, Timelike};

pub fn date_time_stamp() -&gt; String {
  let now: DateTime&lt;Local&gt; = Local::now();
  /*---------------------------------------------
    format DateTime string using chrono formatting
  */
  let mut now_str = format!("{}", now.to_rfc2822());
  /* remove trailing -0400 */
  now_str.truncate(now_str.len() - 6);
  now_str
}

fn convert_month(m:usize) -&gt; &amp;'static str {
  let dv = vec![
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
  ];
  dv[m]
}

pub fn date_stamp() -&gt; String {
  let now: DateTime&lt;Local&gt; = Local::now();
  /* format date string */
  let (_is_common_era, year) = now.year_ce();
  let idx:usize = (now.month() - 1) as usize;
  let mon = convert_month(idx);
  let now_str = format!(
    "{:0&gt;2} {} {}",
    now.day(), mon, year
  );
  now_str
}

pub fn time_stamp() -&gt; String {
  let now: DateTime&lt;Local&gt; = Local::now();
  /* format time string */
  let now_str = format!(
    "{:0&gt;2}:{:0&gt;2}:{:0&gt;2}",
    now.hour(), now.minute(), now.second()
  );
  now_str
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
fn main() {

  print!("\n  -- demo DateTimeStamp --");
  print!("\n  now is:  {:?}", date_time_stamp());
  print!("\n  date is: {:?}", date_stamp());
  print!("\n  time is: {:?}", time_stamp());
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo DateTimeStamp --
now is:  "Sun, 26 Jul 2020 17:39:51"
date is: "26 Jul 2020"
time is: "17:39:51"
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </div>
        <div style="height:0.1em;"></div>
        <a id="soon"></a>
        <h2>3.0&nbsp;&nbsp;Coming Soon</h2>
        <div style="border:2px solid maroon; padding:0.5em 1.5em; width:fit-content;">
          <ol class="tight" style="margin-left:1em;">
            <li>
              string conversions
            </li>
            <li>
              cast only for primitives, else From and Into
            </li>
            <li>
              Traits - see donovan pain-points.html, section 10
            </li>
            <li>
              HashMap entry api (donovan again)
            </li>
            <li>
              Reading values of Move types from Arrays and Vectors
              <ul class="tight">
                <li>Clone</li>
                <li>Option::take()</li>
              </ul>
            </li>
            <li>Living well with the ownership rules - pass-by-reference functions</li>
            <li> ... </li>
          </ol>
        </div>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#member-thread">member thread</a>
        <a href="#start">start</a>
        <a href="#new">new</a>
        <a href="#stop">stop</a>
        <a href="#stopwatch">stopwatch</a>
        <a href="#callback">callback</a>
        <a href="#stamps">stamps</a>
        <a href="#soon">soon</a>
        <!-- <a href="#refs">refs</a> -->
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 34, 10);
  </script>
</body>
</html>
<!DOCTYPE html>
<html id="top">
<!--
  RustGlossary.html
-->
<head>
  <title>Rust Facts</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    td {
      font-size: 0.9rem;
      vertical-align: top;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_Facts.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/09/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Facts</h2>
        <h4 id="subtitle" class="indent">
          common terms
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>

    </header>
    <!-- <div style="height:1em;"></div> -->
        <t-b>
          The table, below, summarizes things we&apos;ve learned in the Rust Bytes so far and adds a few
          more things to come.
          Occasionally terms like &quot;object&quot; and &quot;trait&quot; are used with their
          intuitive meanings.  In later Bites we will give them, e.g., <a target="_blank" href="RustBites_Structs.html">object</a>
          and <a target="_blank" href="RustBites_Traits.html">trait</a> precise meanings.
        </t-b>
        <s-halfEm></s-halfEm>
        <table id="dopt">
          <!--<tr><td colspan="3" style="height: 1em;"><a id="dops" /></td></tr>-->
          <tr>
            <td class="darkItem">Data Operations</td>
            <!--<td class="darkItem">Examples</td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Copy type</strong> - holds no resources in the heap.<br />User-defined types must implement
              std::marker::Copy trait.
              <hr />
              Examples:<br />
              <c-s>bool, char, i32, ... u8, ... f32, ...</c-s><br />
              <c-s>[i32;N], (i32, f64), struct { i32, f64 }</c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>bool, char, i32, ... u8, ... f32, ...</c-s><br />
              <c-s>[i32;N], (i32, f64), struct { i32, f64 }</c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Move type</strong> - holds resources in the heap<br />Cannot implement copy trait.
              <hr />
              Examples:<br />
              <c-s>String, Vec&lt;T&gt;, Map&lt;K, V&gt;, ...</c-s><br />
              <c-s>[String;N], (i32, Vec&lt;f64&gt;), struct { i32, String }</c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>String, Vec&lt;T&gt;, Map&lt;K, V&gt;, ...</c-s><br />
              <c-s>[String;N], (i32, Vec&lt;f64&gt;), struct { i32, String }</c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Bind</strong> - associates an identifier with a value.<br />
              This creates a new instance.
              <hr />
              Examples:<br />
              <c-s>let i:i32 = 3;</c-s><br />
              <c-s>let j = i;</c-s><br />
              <c-s>let s = String::new();</c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>let i:i32 = 3;</c-s><br />
              <c-s>let j = i;</c-s><br />
              <c-s>let s = String::new();</c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Copy</strong> - copies value associated with an identifier.<br />
              - This applies to both binds and assignments for Copy types.<br />
              - Invoked implicitly by compiler generated code.<br />
              - Source of copy is <strong>valid</strong> after copy.
              <hr />
              Examples:<br />
              <c-s>
                let i:i32 = 3;<br />
                let j = i;<br />
                i = j;
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let i:i32 = 3;<br />
                let j = i;<br />
                i = j;
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Move</strong> - moves resources from one instance to another.<br />
              - This applies to both binds and assignments for Move types.<br />
              - Invoked implicitly by compiler generated code.<br />
              - Source of move is <strong>invalid</strong> after move.
              <hr />
              Examples:<br />
              <c-s>
                let s = String::from("a string"); &nbsp;// bind<br />
                let t = s; &nbsp;// move and bind
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let s = String::from("a string"); &nbsp;// bind<br />
                let t = s; &nbsp;// move and bind
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Clone</strong> - creates instance with copy of resources of cloned.<br />
              - Invoked explicitly by developer code.<br />
              - Source is <strong>valid</strong> after clone operation.<br />
              - Source type must implement Clone trait.
              <hr />
              Examples:<br />
              <c-s>let s = String::from("a string");<br />let t = s.clone(); &nbsp;// clone</c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>let s = String::from("a string");<br />let t = s.clone(); &nbsp;// clone</c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Drop</strong> - returns resources when owner goes out of scope.<br />
              - This applies only to Move types.<br />
              - Invoked implicitly by compiler generated code.<br />
              - Can be invoked explicitly by program code.
              <hr />
              Example:<br />
              <c-s>let s = String::from("a string");<br />std::mem::drop(s);</c-s>
              <div style="height:1em;">&nbsp;</div>
              <div style="height:1em;">&nbsp;</div>
            </td>
            <!--<td class="elem topborder">
              <c-s>let s = String::from("a string");<br />std::mem::drop(s);</c-s>
              <div style="height:1em;">&nbsp;</div>
            </td>-->
          </tr>
          <tr id="dstr">
            <td class="darkItem">Data Structures</td>
            <!--<td class="darkItem">Examples</td>-->
          </tr>
          <tr>
            <td class="elem topborder">
              <strong>Array</strong> - Contiguous set of values all of the same type.<br />
              - Indexable<br />
              - Fixed number of elements
              <hr />
              Examples:<br />
              <c-s>
                let a: [3; i32] = [1, 2, 3]; // static memory<br />
                let b = Box::new([0;3]); // heap memory
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let a: [3; i32] = [1, 2, 3]; // static memory<br />
                let b = Box::new([0;3]); // heap memory
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>String</strong> - Contiguous collection of utf-8 chars.<br />
              - Not indexable<br />
              - Iterable<br />
              - Expandable
              <hr />
              Examples:<br />
              <c-s>
                let s: String = String::new();<br />
                let t = String::from("a literal string");
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let s: String = String::new();<br />
                let t = String::from("a literal string");
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Vec&lt;T&gt;</strong> - Contiguous set of values all of the same type.<br />
              - Indexable<br />
              - Expandable number of elements<br />
              - May reallocate
              <hr />
              Examples:<br />
              <c-s>
                let v: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
                let w = Vec::&lt;i32&gt;::new();
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let v: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
                let w = Vec::&lt;i32&gt;::new();
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>HashMap&lt;K, V&gt;</strong> - Table of buckets (list of key/value pairs).<br />
              - Accessed by hash of key:K<br />
              - Each key has associated value v:V<br />
              - Add with insert, delete with remove
              <hr />
              Examples:<br />
              <c-s>
                let m = HashMap::&lt;String, Widget&gt;::new();<br />
                let v = m[k];
              </c-s>
              <div style="height:1em;">&nbsp;</div>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let m = HashMap::&lt;String, Widget&gt;::new();<br />
                let v = m[k];
              </c-s>
              <div style="height:1em;">&nbsp;</div>
            </td>-->
          </tr>
          <tr id="smtptrs">
            <td class="darkItem">Smart Pointers</td>
            <!--<td class="darkItem">Examples</td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Box</strong> - Point to data on heap.<br />
              - Drop returns resource (when leaving scope)<br />
              - Auto DeRef supports methods of referend
              <hr />
              Examples:<br />
              <c-s>
                let d = Box::&lt;String&gt;::new("a string".to_string());<br />
                let b = Box::new(Point { x:1.0, y:1.5, z:-0.5 }
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let d = Box::&lt;String&gt;::new("a string".to_string());<br />
                let b = Box::new(Point { x:1.0, y:1.5, z:-0.5 }
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>RefCell</strong> - Defer ownership checking to run-time.<br />
              - borrow() to view inner<br />
              - borrow_mut() gives mutable access to inner
              - will panic if safety invariants are not satisfied
              <hr />
              Examples:<br />
              <c-s>
                let sp = RefCell::new(String&gt;::new("a string".to_string()));<br />
                let r = sp.borrow_mut();
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let sp = RefCell::new(String&gt;::new("a string".to_string()));<br />
                let r = sp.borrow_mut();
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Rc</strong> - reference counted sharing. Not thread-safe.<br />
              - Drops resource when last reference goes out of scope<br />
              - auto DeRef supports methods of referend
              <hr />
              Examples:<br />
              <c-s>
                let sp = Rc::new(String&gt;::new("a string".to_string()));<br />
                let r1 = sp.clone();<br />
                let r2 = Rc::clone(&r1);
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let sp = Rc::new(String&gt;::new("a string".to_string()));<br />
                let r1 = sp.clone();<br />
                let r2 = Rc::clone(&r1);
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Arc</strong> - thread-safe reference counted sharing.<br />
              - Drops resource when last reference goes out of scope<br />
              - auto DeRef supports methods of referend
              <hr />
              Examples:<br />
              <c-s>
                let sp = Arc::new(String&gt;::new("a string".to_string()));<br />
                let r1 = sp.clone();<br />
                let r2 = Arc::clone(&r1);
              </c-s>
              <div style="height:1em;">&nbsp;</div>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let sp = Arc::new(String&gt;::new("a string".to_string()));<br />
                let r1 = sp.clone();<br />
                let r2 = Arc::clone(&r1);
              </c-s>
              <div style="height:1em;">&nbsp;</div>
            </td>-->
          </tr>
          <tr id="owner">
            <td class="darkItem">Ownership</td>
            <!--<td class="darkItem">Examples</td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Ownership Rules</strong><br />
              - Enforce memory and data race safety<br />
              - Only one owner of any data item<br />
              - May have any number of non-mutable references<br />
              - May have only one mutable reference with no others<br />
              - Owner may not mutate when there are references being used<br />
              - References become inactive when they go out of scope
              <hr />
              Examples:<br />
              <c-s>
                let d = 3;<br />
                let mut mr = &amp;d;<br />
                // let nmr = &amp;d;  // illegal<br />
                mr = 5;  // d now holds 5<br />
                // d = 42; // illegal
              </c-s>
              <div style="height:1em;">&nbsp;</div>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                let d = 3;<br />
                let mut mr = &amp;d;<br />
                // let nmr = &amp;d;  // illegal<br />
                mr = 5;  // d now holds 5<br />
                // d = 42; // illegal
              </c-s>
              <div style="height:1em;">&nbsp;</div>
            </td>-->
          </tr>
          <tr id="gener">
            <td class="darkItem">Generics</td>
            <!--<td class="darkItem">Examples</td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Generic Functions</strong> - code generator for functions<br />
              - creates a new function for each distinct T<br />
              - T must satisfy specified trait constraints otherwise compile failure
              <hr />
              Examples:<br />
              <c-s>
                fn gf&lt;_t:T&gt;) {<br />
                &nbsp;&nbsp;let tn = std::any::type_name::&lt;T&gt;();<br />
                &nbsp;&nbsp;print!("\n  t is type {:?}", tn);<br />
                }
              </c-s>
            </td>
            <!--<td class="elem topborder">
              <c-s>
                fn gf&lt;_t:T&gt;) {<br />
                &nbsp;&nbsp;let tn = std::any::type_name::&lt;T&gt;();<br />
                &nbsp;&nbsp;print!("\n  t is type {:?}", tn);<br />
                }
              </c-s>
            </td>-->
          </tr>
          <tr class="topborder">
            <td class="elem topborder">
              <strong>Generic Structs</strong> - code generator for user-defined types<br />
              - creates a new Struct for each distinct T<br />
              - T must satisfy trait constraints otherwise compile failure
              <hr />
              Examples:<br />
              <c-s>#[derive(Debug)]</c-s><br />
              <c-s>struct Point&lt;T&gt; { x:T, y:T, z:T }</c-s>
              <div style="height:0.5em;"></div>
            </td>
            <!--<td class="elem topborder">
              <c-s>#[derive(Debug)]</c-s><br />
              <c-s>struct Point&lt;T&gt; { x:T, y:T, z:T }</c-s>
            </td>-->
          </tr>
        </table>
        <div style="height:12em;"></div>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#dopt">data ops</a>
        <a href="#dstr">data structures</a>
        <a href="#smtptrs">smart pointers</a>
        <a href="#owner">ownership</a>
        <a href="#gener">generics</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 12, 10);
  </script>
</body>
</html>
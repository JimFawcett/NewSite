<!DOCTYPE html>
<html id="top">
<!--
  RustChanges.html
-->
<head>
  <title>Rust Status</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="../js/SitePagesForTools.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    #github td {
      vertical-align: top;
      line-height: 1rem;
    }
    #github table.flashcard {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border: 4px groove #222;
    }

      #github table.flashcard td {
        padding: 0.5rem 1.5rem;
        border: 4px groove #000;
        /*min-width:50px;*/
      }

      #github table.flashcard li {
        /*width:max-content;*/
        max-width: 30rem;
      }

      #github table.flashcard td {
        overflow: auto;
      }

      #github table.flashcard th.topic {
        width: 10rem;
      }

      #github table.flashcard td.topic {
        width: 10rem;
      }

      #github table.flashcard th.schema {
        width: 36rem;
        text-align: center;
      }

      #github table.flashcard td.schema {
        width: 36rem;
        text-align: center;
      }

      #github table.flashcard td img {
        width: 100%;
        height: auto;
        padding: 0rem;
      }
    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="CppRepos.html"></a>
  <a id="prev" class="hidden" href="CppRepos.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_FlashCards.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/09/2025
  </div>

  <content-block>
    <a id="top"></a>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Flash Cards</h2>
        <h4 id="subtitle" class="indent">
          common types for structuring and accessing data
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--atten); margin-left:1rem;">Rust Track</a>
      </div>

      <!--<div style="padding-right:25px; position:absolute; top:1.1em; right:13em; z-index:5;">-->
    </header>
    <div style="height:1em;"></div>
        <a id="flashcards"></a>
        <t-b>
          Flash cards are brief descriptions of data-related Rust types, traits, or keywords.  Each has a description with
          a small useage example and diagram.  The purpose is to provide a quick way to grasp an important
          language model or feature.
        </t-b>
        <t-b>
          This could grow to be quite large, but for now it will be relatively small, trying to help people
          to start quickly with the Rust language.  In each of the Flash Cards you will find a link to sample
          code in the <a target="_blank" href="https://play.rust-lang.org/">Rust Playground</a> for that
          particular card.  You can run the code to see what it does and change it to see what that does too.
        </t-b>
        <div id="types" style="height: 1rem;"></div>
        <table class="flashcard" style="max-width:100%">
          <colgroup>
            <col style="width:10rem;">
            <col style="width:20rem;">
            <col style="width:20rem;">
          </colgroup>
          <tr>
            <th class="darkItem topic">Topic</th>
            <th class="darkItem">Description</th>
            <th class="darkItem schema">Diagram</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/marker/trait.Copy.html">
                Copy type
              </a>
            </td>
            <td>
              Construction and assignment of copy type implicitly copies contents of source to destination.
              <ul class="tight">
                <li>contiguous memory, satisfies Copy trait</li>
                <li>
                  examples: primitive types like i8, i16, .., u8, u16, .., f32, f64, &str, immut refs, ..
                </li>
                <li>
                  constr: <c-s>let x = y;&nbsp;&nbsp;// copies</c-s><br />
                  assign: <c-s>x = y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// copies</c-s>
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c5b4da6d5bd09c8890d4cce12d08d17f">
                    Copy
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/CopyType.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/keyword.move.html">
                Move type
              </a>
            </td>
            <td>
              Construction and assignment of move type implicitly moves resources of source to destination.
              <ul class="tight">
                <li>non-contiguous memory, does not implement Copy trait</li>
                <li>move transfers ownership of resources from source to destination</li>
                <li>
                  examples:<br />
                  Vec&lt;T&gt;, String, aggregate types holding at least one move type, mut refs,
                  many user defined types
                </li>
                <li>
                  constr: <c-s>let x = y;&nbsp;&nbsp;// moves</c-s><br />
                  assign: <c-s>x = y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// moves</c-s>
                  <note-block>y invalid after operation</note-block>
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=64b2ba6e173465b567f1adde60aae74a">
                    move
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/MoveType.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/clone/trait.Clone.html">
                Clone&nbsp;type
              </a>
            </td>
            <td>
              Construction and assignment of clone type explicitly copies resources of source to destination.
              <ul class="tight">
                <li>
                  examples: Vec&lt;T&gt;, String, many user defined types
                </li>
                <li>
                  constr: <c-s>let x = y.clone();&nbsp;&nbsp;// clone</c-s><br />
                  assign: <c-s>x = y.clone();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// clone</c-s>
                  <note-block>y valid after operation</note-block>
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=860b830f0e5a6ba03ffdfa3908e929c9">
                    clone
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/CloneType.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/reference/types/pointer.html">
                Reference type
              </a>
            </td>
            <td>
              Pointer to instance of some type with special rules:
              <ul class="tight">
                <li>
                  must be initialized before use: <c-s>let r = &u</c-s>, <c-s>let mr = &mut v</c-s>
                </li>
                <li>
                  references cannot concurrently share mutation of referend
                </li>
                <li>
                  lifetime is scoped based, from the point of declaration to the end of that scope
                </li>
                <li>
                  The rules above are basis for Rust&apos;s memory safety.  There are more details
                  explained in <a target="_blank" href="../RustBites/RustBites_Safety.html">Safety</a>
                </li>
                <li>
                  All other pointer types must reside in <c-s>unsafe { ... }</c-s> to be dereferenced<sup>1</sup>
                  <div style="margin: 0.25rem 0.75rem; padding:0.25rem 0.5rem; max-width:25rem; overflow:auto; border:1px solid black;">
                    Goal: don&apos;t use unsafe blocks in code you write.  Let std library types do any
                    required unsafe processing.  They have been written by the Rust team and are
                    thoroughly vetted and wrapped in a safe interface.
                  </div>
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ca2bd3e16eec697844015a819766c05c">
                    Reference
                  </a>
                </li>
              </ul>
              <hr />
              <ol>
                <li>
                  raw pointers may be declared, initialized, and written to the console. That is safe. However, dereferencing is unsafe.
                </li>
              </ol>
            </td>
            <td class="schema">
              <img src="pictures/Reference.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/vec/struct.Vec.html">
                Vec&lt;T&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in contiguous heap memory.
              <ul class="tight">
                <li>
                  consists of control block in stack holding pointer to array of T instances in heap
                </li>
                <li>
                  reallocates heap memory to accept new instance when capacity is full
                </li>
                <li>
                  create vector:
                  <indent-block class="tight">
                    <c-s>let v = Vec::&lt;int&gt;::new();</c-s><br />
                    <c-s>let w: Vec&lt;T&gt; = vec![t1, t2, t3];</c-s>
                  </indent-block>
                </li>
                <li>
                  v and w are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=43d6fc3c2898cc1421e05cd08f4dc408">
                    create and display vectors
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/Vec.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">
                VecDeque&lt;T&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in a circular buffer in heap memory.
              <ul class="tight">
                <li>
                  consists of control block in stack holding pointer to circular buffer of T instances in heap
                </li>
                <li>
                  Control block contains references to the front and back of the VecDeque.
                </li>
                <li>
                  reallocates heap memory to accept new instance when capacity is full
                </li>
                <li>
                  create queue:
                  <indent-block class="tight">
                    <c-s>let v = VecDec::&lt;T&gt;::new();</c-s><br />
                    <c-s>v.push_back(t1); v.push_back(t2); let u = v.pop_front();</c-s>
                  </indent-block>
                </li>
                <li>
                  v and u are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0b35526b63e5dfa873724a3fdac5b27f">
                    create and display vecdeque
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/VecDeque.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">
                HashMap&lt;K,V&gt;
              </a>
            </td>
            <td>
              Collection of buckets (linked list of key-value pairs) rooted in table in heap memory.
              <ul class="tight">
                <li>
                  Consists of control block in stack holding pointer to address table of buckets in heap
                </li>
                <li>
                  Hash function used to calculate table address from key.
                </li>
                <li>
                  If hash yields address with existing bucket, key-value pair added to bucket list.
                </li>
                <li>
                  Reallocates table memory when table bucket count approaches table size.
                </li>
                <li>
                  create hashmap:
                  <indent-block class="tight">
                    <c-s>let h = HashMap::&lt;K,V&gt;::new();</c-s><br />
                    <c-s>h.insert(k,v);</c-s>
                  </indent-block>
                </li>
                <li>
                  table and all bucket elements are dropped when they go out of scope.
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f11d241deb2b45d9eef4e4aba4c22112">
                    create and display HashMap
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/HashMap.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/string/struct.String.html">String</a>
            </td>
            <td>
              Collection of utf-8 characters residing in contiguous heap memory.
              <ul class="tight">
                <li>
                  consists of control block in stack holding ptr to contiguous heap memory allocation.
                </li>
                <li>
                  a utf-8 character may occupy from 1 to 4 bytes, allowing a large collection of
                  language sets, e.g., ASCII, Unicode, Kanji, Arabic, ...
                </li>
                <li>
                  The item above means that Rust std::String instances cannot be indexed.  There is a
                  string iterator, called <c-s>chars()</c-s>, that understands byte sequences that define
                  utf-8 character boundaries.
                  <indent-block>
                    <c-s>
                      let s = String::from("a literal string");<br />
                      let c2 = s.chars().nth(4).unwrap();
                    </c-s>
                  </indent-block>
                </li>
                <li>
                  reallocates heap memory to accept new character(s) when capacity is full
                </li>
                <li>
                  create String:
                  <indent-block class="tight">
                    <c-s>let s = String::new();</c-s><br />
                    <c-s>let t = String::from("a string");</c-s>
                  </indent-block>
                </li>
                <li>
                  s and t are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b8358deb93de35248f56b3ecfe5e67ef">
                    create and manipulate String and str
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/String.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/str/index.html">str</a>
            </td>
            <td>
              str is a copy type that represents a literal string in contiguous block of memory
              <ul class="tight">
                <li>
                  converting between str and String:<br />
                  <c-s>
                    &nbsp;&nbsp;let s = "an ordered collection of utf-8 characters";<br />
                    &nbsp;&nbsp;let t = String::from(s);<br />
                    &nbsp;&nbsp;let u = &s;
                  </c-s>
                </li>
                <li>
                  Literal strings are almost always used via a reference, e.g., <c-s>&s</c-s>
                </li>
                <li>
                  Sample code in Rust Playground:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5f353d3efd95b4ee529efe22908239ed">
                    copy str demo
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/str.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/boxed/struct.Box.html">Box&lt;T&gt</a>
            </td>
            <td>
              Box is a smart pointer to an instance of type T on the heap.
              <ul class="tight">
                <li>
                  Box is the only safe way to allocate an instance in the heap
                </li>
                <li>
                  <c-s>let s = String::from("string in heap");</c-s><br />
                  <c-s>let x = Box::new(s);  // moves s into Box</c-s>
                </li>
                <li>
                  a Box is dropped to release its resource when it goes out of scope
                </li>
                <li>
                  a Box instance is implicitly dereferenced to provide the interface of its
                  inner instance
                </li>
                <li>
                  Code demo:
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=bd50880fa736c484b17ba850da45e82d">
                    store, modify, and read value in heap
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/Box.jpg" />
            </td>
          </tr>
        </table>
    <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#types">types</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 11, 10);
  </script>
</body>
</html>
<!DOCTYPE html>
<html id="top">
<!--
  RustBites_ErrHnd.html
-->
<head>
  <title>Rust Error Handling</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    td {
      font-size: 0.9rem;
      vertical-align: top;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_ErrHnd.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/10/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Error Handling</h2>
        <h4 id="subtitle" class="indent">
          Error handling, bubbling up        
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>
    </header>
        <a id="intro"></a>
        <h3>1.0 - Introduction</h2>
        <t-b>
          Rust error handling is based on two things: enumerations and matching. Rust&apos;s enumerations are more
          powerful than those of C++ and C#.  Each element of the enumeration may wrap some type, as shown in the
          example below.
        </t-b>
        <t-b>
          Error handling in Rust does not use exceptions.  Instead, it uses error returns, but those are much more
          useful than simply returning error codes.  Because Result&lt;T, E&gt; is a Rust style enumeration,
          functions can return either a result of computation or an error with a single return value.  The
          functions for testing those conditions are all part of the enum.
        </t-b>
        <t-b>
          <defn-OuterBlock>
            <defn-block>
              <defn-head>
                Result Type
              </defn-head>
              <defn-code style="font-size:1rem;">
enum Result&lt;T, E&gt; { Ok(T), Err(E), }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>References:</defn-head>
              <defn-body>
                <a target="_blank" href="https://doc.rust-lang.org/std/result/">std::result</a><br />
                <a target="_blank" href="https://doc.rust-lang.org/std/error/trait.Error.html">std::error::Error</a>
              </defn-body>
            </defn-block>
          </defn-OuterBlock>
        </t-b>
        <div style="height:0.5em;"></div>
        <t-b>
          The example below shows how Result&lt;T, E&gt; is used.
        </t-b>
        <t-b>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Functions returning Result or Option</defn-head>
              <defn-code>
use display::{*};

fn demo_result&lt;'a&gt;(p: bool) -&gt; Result&lt;&amp;'a str, &amp;'a str&gt; {
  print!("\n  value of input predicate is {}", p);
  if p {
    return Ok("it's ok");
  }
  else {
    return Err("not ok");
  }
}

fn demo_option&lt;'a&gt;(p:bool) -&gt; Option&lt;&amp;'a str&gt; {
  print!("\n  value of input predicate is {}", p);
  if p {
    return Some("something just for you!");
  }
  else {
    return None;
  }
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo Result --
-----------------------
-- using match
value of input predicate is true
result is it's ok
value of input predicate is false
result is not ok

-- using expect
value of input predicate is true
result is it's ok

-- demo Option --
-----------------------
--using match
value of input predicate is true
something just for you!
value of input predicate is false
sorry, nothing here

--using unwrap
value of input predicate is true
something just for you!

That's all folks!
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using code:</defn-head>
              <defn-code>
use display::{*};

sub_title("  -- demo Result --  ");
shows("\n-- using match");

let r = demo_result(true);
match r {
  Ok(rslt) =&gt; print!("\n  result is {}", rslt),
  Err(rslt) =&gt; print!("\n  result is {}", rslt)
}
let r = demo_result(false);
match r {
  Ok(rslt) =&gt; print!("\n  result is {}", rslt),
  Err(rslt) =&gt; print!("\n  result is {}", rslt)
}
shows("\n\n-- using expect");

let r = demo_result(true)
       .expect("predicate was false");
print!("\n    result is {}", r);
/////////////////////////////////////////////
// uncomment to see panic
// let _r = demo_result(false)
//   .expect("predicate was false");
putline();

sub_title("  -- demo Option --  ");
shows("\n--using match");

let r = demo_option(true);
match r {
  Some(rslt) =&gt; print!("\n    {}", rslt),
  None =&gt; print!("\n    sorry, nothing here")
}
let r = demo_option(false);
match r {
  Some(rslt) =&gt; print!("\n    {}", rslt),
  None =&gt; print!("\n    sorry, nothing here")
}
shows("\n\n--using unwrap");

let r = demo_option(true).unwrap();
print!("\n    {}", r);
/////////////////////////////////////////////
// uncomment to see panic
// let _r = demo_option(false).unwrap();

print!("\n\n  That's all folks!\n\n");
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </t-b>
        <div style="height:0.25rem;"></div>
        <a id="bubbling"></a>
        <h3>2.0 - Bubbling Up Errors</h3>
        <t-b>
          Rust requires Result&lt;T, E&gt;, returned from functions, to be handled, or explicitly
          ignored by binding the result to a variable with leading underscore, e.g.
          <div class="indent pad5">
            <c-s>let _ign = function_returning_result(...);</c-s>
          </div>
          Otherwise, it must match against the returned result, as shown above.  If a function calls many other
          functions that return results, the code gets cluttered with all the error handling.  One very nice way
          to avoid that is to use error bubbling.
        </t-b>
        <t-b>
          If we suffix the function call with a ?, called try operator, then if the result is not an error, ? binds
          the unwrapped <c-s>T</c-s> value from <c-s>Result&lt;T, E&gt;</c-s>.  So the expression:
          <div class="indent pad5">
            <c-s>let ret_val = function_returns_result()?</c-s>
          </div>
          Binds the result value to <c-s>ret_val</c-s>.  If, on the other hand, the function returns an error, then
          operator ? immediately returns Err(Error) to the caller.
        </t-b>
        <t-b>
          This is illustrated in the example below:
        </t-b>
        <div style="height:0.25rem;"></div>
        <t-b>
          <defn-OuterBlock>
            <defn-block>
              <defn-head>Error Bubbling</defn-head>
              <defn-code>
#[derive(Debug)]
struct Error;

#[derive(Debug)]
struct Demo;
impl Demo {
  fn do_int(&amp;self, i:i32) -&gt; &amp;Self {
    print!("\n  my argument is {}", i);
    &amp;self
  }
  fn do_float(&amp;self, f:f64) -&gt; &amp;Self {
    print!("\n  my argument is {}", f);
    &amp;self
  }
  fn do_vec(&amp;self, v:Vec&lt;i32&gt;)
  -&gt; &amp;Self {
    print!("\n  my argument is {:?}", v);
    &amp;self
  }
  fn do_err(&amp;self, p:bool)
  -&gt; Result&lt;String, Error&gt; {
    let e = Error {};
    if p {
      Ok("no error".to_string())
    } else {
      Err(e)
    }
  }
}

fn main() -&gt; Result&lt;(),Error&gt; {
  let d = Demo {};
  let rslt = d.do_int(42)
              .do_float(3.14159)
              .do_vec(vec![1,2,3])
              .do_err(true);
  print!("\n  rslt = {:?}", rslt);

  /*-------------------------------------------
    Bubbling up Errors
    If do_err returns Ok(value) then bind
    value to rslt,
    else return Err(Error).
  */
  let rslt = d.do_int(42)
              .do_float(3.1415927)
              .do_err(true)?;  // binds to rslt
  print!("\n  rslt = {:?}", rslt);
  let rslt = d.do_int(42)
              .do_float(3.1415927)
              .do_err(false)?;  // returns Err
  print!("\n  rslt = {:?}", rslt);
  Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output</defn-head>
              <defn-code>
Compiling playground v0.0.1 (/playground)
Finished dev [unoptimized + debuginfo]
target(s) in 3.83s
Running `target/debug/playground`
Error: Error

Standard Output


my argument is 42
my argument is 3.14159
my argument is [1, 2, 3]
rslt = Ok("no error")
my argument is 42
my argument is 3.1415927
rslt = "no error"
my argument is 42
my argument is 3.1415927

              </defn-code>
              <defn-head class="defnBorderTop">References:</defn-head>
              <defn-body>
                <div style="height:0.75rem;"></div>
                <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2f2e450526a86ba5424cd26270646007">
                  playground example
                </a><br />
                <a target="_blank" href="https://doc.rust-lang.org/1.29.0/book/2018-edition/ch09-02-recoverable-errors-with-result.html">
                  Error handling - The Rust Book
                </a>
              </defn-body>
            </defn-block>
          </defn-OuterBlock>
        </t-b>
        <a id="refs"></a>
        <h3>3.0 - References</h2>
        <div style="height:0.75rem;"></div>
        <div class="indent">
          <table>
            <tr>
              <th>Link</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><a target="_blank" href="file:///C:/github/JimFawcett/JimFawcett.github.io/RustStory_Operations.html#errors">Rust Story</a></td>
              <td>Provides enumeration methods and examples of use</td>
            </tr>
            <tr>
              <td><a target="_blank" href="https://doc.rust-lang.org/stable/rust-by-example/error.html">rust-by-example</a></td>
              <td>Easy to use examples that have sufficient detail for project coding</td>
            </tr>
            <tr>
              <td><a target="_blank" href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">the rust book</a></td>
              <td>Easy to use examples, illustrated with std::fs</td>
            </tr>
          </table>
        </div>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#bubbling">bubbling</a>
        <a href="#refs">refs</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 24, 10);
  </script>
</body>
</html>
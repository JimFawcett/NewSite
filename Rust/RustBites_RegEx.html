<!DOCTYPE html>
<html id="top">
<!--
  RustBites_RegEx.html
-->
<head>
  <title>Rust RegEx</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    #github table.flashcard th {
      background-color: var(--dark);
      color: var(--atten);
    }
    #github table.flashcard td {
      font-size: 0.9rem;
      vertical-align: top;
    }
    #github table {
      max-width: 80%;
      border: 1px solid black;
      margin-top: 1em;
      margin-bottom: 1.0em;
    }

      #github table.flashcard {
        width: 100%;
        table-layout: fixed;
        border-collapse: collapse;
        border: 4px groove #222;
      }

        #github table.flashcard td {
          padding: 0.5rem 1.5rem;
          border: 4px groove #000;
          /*min-width:50px;*/
        }

        #github table.flashcard li {
          /*width:max-content;*/
          max-width: 30rem;
        }

        #github table.flashcard td {
          overflow: auto;
        }

        #github table.flashcard th.topic {
          width: 12rem;
        }

        #github table.flashcard td.topic {
          width: 10rem;
        }

        #github table.flashcard th.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td img {
          width: 100%;
          height: auto;
          padding: 0rem;
        }

      #github table.invis {
        width: 90%;
        border: none;
      }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr.invis {
          border: none;
        }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

          #github table tr th.invis {
            border: none;
          }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

          #github table tr td.invis {
            border: none;
          }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }

    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_RegEx.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/11/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Regular Expressions</h2>
        <h4 id="subtitle" class="indent">
          little language for specifying text fragments with metadata
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>
    </header>
        <t-b>
          <div style="width:90%; margin-left:2em;">
            &quot;Some people, when confronted with a problem, think "I know, I'll use regular expressions."
            Now they have two problems.&quot;<br />
            - Jamie Zawinski
          </div>
        </t-b>
        <t-b><hr class="spread" /></t-b>
        <t-b>
          A regular expression is a String-based pattern that matches other Strings or parts of Strings.  Patterns are
          constructed from a little language, discussed in Section 3.  A program in that language is compiled by
          a regular expression compiler.  The result is used to search text for matches.
        </t-b>
        <t-b>
          Rust does not have a regular expression library, but the there is a widely used regex library posted on
          <a href="https://crates.io/search?q=regex">crates.io</a> that we will use in this Bite.
          The compiler, <c-s>regex::RegEx</c-s>, expects syntax similar to that used in the string processing language
          Perl.  <c-s>RegEx</c-s> has a number of methods, discussed in Section 2., that support finding matches and
          retrieving text fragments.
        </t-b>
        <a id="intro"></a>
        <h2>1.0&nbsp;&nbsp;Introduction</h2>
        <t-b>
          <div class="indent">
            <defn-OuterBlock>
              <defn-block>
                <defn-head>Example</defn-head>
                <defn-code>
fn re_check(re: &str, text: &str) -> bool {
  /* panics if re is invalid */
  let re: Regex = Regex::new(re).unwrap();
  re.is_match(text)
}

fn show_re_test(re: &str, text: &str) {
  if re_check(re, text) {
    print!(
      "\n  RegEx: {:?} matches text: {:?}",
      re, text
    )
  }
  else {
    print!(
      "\n  RegEx: {:?} does'nt match text: {:?}",
      re, text
    )
  }
}

fn main() {
  let re =
    Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
  assert!(re.is_match("2014-01-01"));

  let re = "abc";
  let text1 = "123abc987";
  show_re_test(re, text1);
  let text2 = "123000987";
  show_re_test(re, text2);

  let re = r"([a-z]+)|([A-Z][A-Z])";
  let text3 = "???abc";
  show_re_test(re, text3);
  let text4 = "???A@@@";
  show_re_test(re, text4);
  let text4 = "???AK@@@";
  show_re_test(re, text4);
  let text5 = r"123";
  show_re_test(re, text5);
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Result</defn-head>
                <defn-code>
RegEx: "abc"
matches text: "123abc987"
RegEx: "abc"
does not match text: "123000987"
RegEx: "([a-z]+)|([A-Z][A-Z])"
matches text: "???abc"
RegEx: "([a-z]+)|([A-Z][A-Z])"
does not match text: "???A@@@"
RegEx: "([a-z]+)|([A-Z][A-Z])"
matches text: "???AK@@@"
RegEx: "([a-z]+)|([A-Z][A-Z])"
does not match text: "123"
                </defn-code>
              </defn-block>
            </defn-OuterBlock>
          </div>
        </t-b>
        <t-b class="indent">
          <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=def5cce838cf257ac8b62e1dd00e94d2">
            matching in rust playground
          </a>
        </t-b>
        <t-b>
          The code used in this example will be discussed in the next two sections.
        </t-b>
        <a id="syntax"></a>
        <h2>2.0&nbsp;&nbsp;Regular Expression Syntax Summary</h2>
        <t-b>
          A short list of syntax, extracted from the regex crate, is provided in Table 1.  This should be all that
          is needed for most applications.
        </t-b>
        <t-b class="indent" style="width:calc(100vw - 6rem);">
          <div style="display:flex">
            <div>
              <h4>Table&nbsp;1.&nbsp;-&nbsp;Regular&nbsp;Expression&nbsp;Syntax</h4>
              <table>
                <tr>
                  <th>syntax</th>
                  <th>meaning</th>
                </tr>
                <tr>
                  <td>.</td>
                  <td>
                    any&nbsp;character&nbsp;except&nbsp;new&nbsp;line
                  </td>
                </tr>
                <tr>
                  <td>\d</td>
                  <td>
                    digit
                  </td>
                </tr>
                <tr>
                  <td>\D</td>
                  <td>
                    not digit
                  </td>
                </tr>
                <tr>
                  <td>\s</td>
                  <td>
                    white space
                  </td>
                </tr>
                <tr>
                  <td>\S</td>
                  <td>
                    not white space
                  </td>
                </tr>
                <tr>
                  <td>\w</td>
                  <td>
                    word character
                  </td>
                </tr>
                <tr>
                  <td>\W</td>
                  <td>
                    not word character
                  </td>
                </tr>
                <tr>
                  <td>[xyz]</td>
                  <td>
                    character class matching either x, y, or z
                  </td>
                </tr>
                <tr>
                  <td>[^xyz]</td>
                  <td>
                    character class matching any char except x, y, or z
                  </td>
                </tr>
                <tr>
                  <td>[b-q]</td>
                  <td>
                    character class matching any char in b-q range inclusive
                  </td>
                </tr>
                <tr>
                  <td>[0-7&&[^4]]</td>
                  <td>
                    matches any char in range 0-7 except 4
                  </td>
                </tr>
                <tr>
                  <td>xy</td>
                  <td>
                    concatenation - x followed by y
                  </td>
                </tr>
                <tr>
                  <td>x|y</td>
                  <td>
                    x or y
                  </td>
                </tr>
                <tr>
                  <td>x*</td>
                  <td>
                    zero or more of x
                  </td>
                </tr>
                <tr>
                  <td>x+</td>
                  <td>
                    one or more of x
                  </td>
                </tr>
                <tr>
                  <td>x?</td>
                  <td>
                    zero or one of x
                  </td>
                </tr>
                <tr>
                  <td>x{n}</td>
                  <td>
                    n repetitions of x
                  </td>
                </tr>
                <tr>
                  <td>x{m,n}</td>
                  <td>
                    at least m but no more than n repetitions of x
                  </td>
                </tr>
                <tr>
                  <td>^</td>
                  <td>
                    beginning of text
                  </td>
                </tr>
                <tr>
                  <td>$</td>
                  <td>
                    end of text
                  </td>
                </tr>
                <tr>
                  <td>(...)</td>
                  <td>
                    capture group
                  </td>
                </tr>
              </table>
            </div>
            <div style="margin-left:1em;">
              <h4>Table 2. - Examples</h4>
              <table style="width: calc(100vw-0rem);">
                <tr>
                  <th>Example</th>
                  <th>Action</th>
                </tr>
                <tr>
                  <td>
                    [A-Z]
                  </td>
                  <td>
                    matches C in "a Capital letter"
                  </td>
                </tr>
                <tr>
                  <td>
                    Rust
                  </td>
                  <td>
                    matches any string containing &quot;Rust&quot;
                  </td>
                </tr>
                <tr>
                  <td>
                    abc{3}
                  </td>
                  <td>
                    matches&nbsp;&quot;this&nbsp;is&nbsp;an&nbsp;example&nbsp;-&nbsp;abccc&nbsp;-&quot;
                  </td>
                </tr>
                <tr>
                  <td>
                    a(bc)*
                  </td>
                  <td>
                    matches a, abc, abcbc, ...
                  </td>
                </tr>
                <tr>
                  <td>
                    fn|struct
                  </td>
                  <td>
                    matches "fn funct()", "struct X {}"
                  </td>
                </tr>
                <tr>
                  <td colspan="2">
                    <a href="https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285">RE Tutorial - Factory Mind</a><br />
                    has many executable examples.
                    <div style="height:0.5em;"></div>
                  </td>
                </tr>
              </table>
            </div>
          </div>
        </t-b>
        <t-b class="indent">
          <a href="https://docs.rs/regex/1.4.5/regex/index.html#syntax">more complete list of syntax</a>
        </t-b>
        <a id="regex"></a>
        <h2>3.0&nbsp;&nbsp;Regex</h2>
        <t-b>
          The crate, regex&nbsp;ver&nbsp;1.4.5, available from <a href="https://crates.io/crates/regex">crates.io</a>
          is used exclusively in this Bite.
        </t-b>
        <t-b>
          It&apos;s primary struct, regex::Regex, is a processor for regular expressions that compiles a regular expression
          into a state machine.  Using that it can:
          <div class="pad5">
            <ul class="tight" style="margin-left:2em;">
              <li>check if a regular expression matches a given text string, as shown above</li>
              <li>return capture groups that describe possibly multiple matches in a given string</li>
              <li>split text based on capture groups</li>
              <li>replace text</li>
            </ul>
          </div>
          Searching text with a Regex instance is guaranteed to be linear in the size of the text.  Compiling
          regular expressions requires a non-trivial amount of time, so repeated invocations should not recompile
          unless the pattern changes.
        </t-b>
        <t-b>
          <div class="indent">
            <defn-OuterBlock>
              <defn-block>
                <defn-head>Partial Declarations from regex crate</defn-head>
                <defn-code>
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct Match<'t> {
  text: &'t str,
  start: usize,
  end: usize,
}

pub struct Regex(Exec);

/* compiles reg express'n, result can be used repeatedly */
pub fn new(re: &str) -> Result&lt;Regex, Error&gt;

/* cheapest way to detect a match */
pub fn is_match(&self, text: &str) -> bool

/* returns start and end of first match if it exists */
pub fn find&lt;'t&gt;(&self, text: &'t str) -> Option&lt;Match&lt;'t&gt;&gt;

/* returns iterator for successive non-overlapping matches */
pub fn find_iter&lt;'r, 't&gt;(&'r self, text: &'t str) -> Matches&lt;'r, 't&gt;

/* returns capture groups for first match in text */
pub fn captures&lt;'t&gt;(&self, text: &'t str) -> Option&lt;Captures&lt;'t&gt;&gt;

/* returns iterator over all non-overlapping capture groups */
pub fn captures_iter&lt;'r, 't&gt;(
  &'r self,
  text: &'t str,
) -> CaptureMatches&lt;'r, 't&gt;

/* returns iterator of substrings of matching text */
pub fn split&lt;'r, 't&gt;(&'r self, text: &'t str) -> Split&lt;'r, 't&gt;

/* replaces first match with replacement */
pub fn replace&lt;'t, R: Replacer&gt;(
  &self,
  text: &'t str,
  rep: R,
) -> Cow&lt;'t, str&gt;

/* replaces all non-overlapping matches in text with replacement */
pub fn replace_all&lt;'t, R: Replacer&gt;(
  &self,
  text: &'t str,
  rep: R,
) -> Cow&lt;'t, str&gt;

                </defn-code>
              </defn-block>
            </defn-OuterBlock>
            <t-b>
              Contents of the preceding block show the structure and methods of <c-s>regex::Regex</c-s>.  The
              next block gives examples of their use, and Section 3.0 discusses regular expression pattern
              syntax and semantics.
            </t-b>
            <defn-OuterBlock>
              <defn-block>
                <defn-head>Example Use</defn-head>
                <defn-code>
use regex::{Regex, Match, Captures};

fn check(pattern: &str, text: &str, pred:bool) {
  if pred {
    print!(
      "\n  pattern: {:?}  matches text: {:?}",
      pattern, text
    );
  }
  else {
    print!(
      "\n  pattern: {:?} !matches text: {:?}",
      pattern, text
    );
  }
}

fn range(pattern: &str, text: &str, mat: &Option&lt;Match&gt;
) {
  if let Some(mt) = mat {
    print!(
      "\n  find pattern {:?} in text {:?}:",
      pattern, text
    );
    print!("  match in [{}, {})", mt.start(), mt.end());
  }
  else {
    print!("\n  no match");
  }
}

fn range_iter(pattern: &str, text: &str, mat: Match) {
  print!(
    "\n  find pattern {:?} in text {:?}:",
    pattern, text
  );
  print!("  match in [{}, {})", mat.start(), mat.end());
}

fn test_match() {
  print!("\n  -- test_match --");
  let pattern = r"[a-q]{3,4}$";
  let re = Regex::new(pattern).unwrap();
  let text = "12cde";
  let pred = re.is_match(text);
  check(pattern, text, pred);

  let text = "12cdefg";
  let pred = re.is_match(text);
  check(pattern, text, pred);

  let text = "12cd";
  let pred = re.is_match(text);
  check(pattern, text, pred);

  let text = "12cd3e";
  let pred = re.is_match(text);
  check(pattern, text, pred);

  let text = "12cds";
  let pred = re.is_match(text);
  check(pattern, text, pred);
}

fn test_find() {
  print!("\n  -- test_find --");
  let pattern = r"abc";
  let re = Regex::new(pattern).unwrap();
  let text = "123abc456";
  let op: Option&lt;Match&gt; = re.find(text);
  range(pattern, text, &op);
}

fn test_find_iter() {
  print!("\n  -- test_find_iter --");
  let pattern = r"abc";
  let re = Regex::new(pattern).unwrap();
  let text = "123abc456abc789";
  let matches = re.find_iter(text);
  for mat in matches {
    range_iter(pattern, text, mat);
  }
}

fn test_captures() {
  print!("\n  -- test_captures --");
  let text = "123abc456def789";
  let pattern = "\
  ([a-z]{3}|[0-9]{3})\
  ([a-z]{3}|[0-9]{3})\
  ([a-z]{3}|[0-9]{3})\
  ([a-z]{3}|[0-9]{3})\
  ([a-z]{3}|[0-9]{3})\
  ";
  // These don't work as you might expect.
  // Capture doesn&apos;t work well with repetitions.
  // let pattern = r"([a-z]{3}|[0-9]{3}){5}";
  // let pattern = r"(([a-z]{3})([0-9]{3}))+";
  // let pattern = r"((?:\d+)+)+";

  let re = Regex::new(pattern).unwrap();
  let captures: Option&lt;Captures&gt; = re.captures(text);
  print!("\n  captures: {:?}", captures);
  let caps = captures.unwrap();
  for i in 0..caps.len() {
    print!("\n  captures[{}] = {:?}", i, &caps.get(i));
    let cap = &caps.get(i).unwrap();
    print!(
      "\n  cap = {:?}, {}, {}",
      cap.as_str(), cap.start(), cap.end()
    );
  }
}

fn main() {
  test_match();
  test_find();
  test_find_iter();
  test_captures();
}

                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output</defn-head>
                <defn-code>
-- test_match --
pattern: "[a-q]{3,4}$"  matches text: "12cde"
pattern: "[a-q]{3,4}$"  matches text: "12cdefg"
pattern: "[a-q]{3,4}$" !matches text: "12cd"
pattern: "[a-q]{3,4}$" !matches text: "12cd3e"
pattern: "[a-q]{3,4}$" !matches text: "12cds"

-- test_find --
find pattern "abc" in text "123abc456":  match in [3, 6)
-- test_find_iter --
find pattern "abc" in text "123abc456abc789":
match in [3, 6)
find pattern "abc" in text "123abc456abc789":
match in [9, 12)
-- test_captures --
captures: Some(
  Captures({
    0: Some("123abc456def"),
    1: Some("123"),
    2: Some("abc"),
    3: Some("456"),
    4: Some("def")
  })
)

captures[0] = Some(
  Match {
    text: "123abc456def789", start: 0, end: 12
  }
)
cap = "123abc456def", 0, 12

captures[1] = Some(
  Match {
    text: "123abc456def789", start: 0, end: 3
  }
)
cap = "123", 0, 3

captures[2] = Some(
  Match {
    text: "123abc456def789", start: 3, end: 6
  }
)
cap = "abc", 3, 6

captures[3] = Some(
  Match {
    text: "123abc456def789", start: 6, end: 9
  }
)
cap = "456", 6, 9

captures[4] = Some(
  Match {
    text: "123abc456def789", start: 9, end: 12
  }
)
cap = "def", 9, 12

captures[5] = Some(
  Match {
    text: "123abc456def789", start: 12, end: 15
  }
)
cap = "789", 12, 15
                </defn-code>
              </defn-block>
            </defn-OuterBlock>
          </div>
        </t-b>
        <t-b class="indent">
          <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2f071dbdfda7b4b5c13a329103f813d3">
            code in playground
          </a>
        </t-b>
        <a id="epilogue"></a>
        <h2>4.0&nbsp;&nbsp;Epilogue:</h2>
        <t-b>
          For many applications all you need is <c-s>RegEx::is_match(&self) -> bool</c-s>.  That simply returns true
          after finding the first match, or false if there are no matches.  That is efficient and flexible.
        </t-b>
        <t-b>
          Make sure that you only compile the pattern once, using <c-s>RegEx::new(pattern)</c-s>.  You should recompile
          only if the pattern changes.
        </t-b>
        <a id="refs"></a>
        <h2>5.0&nbsp;&nbsp;References:</h2>
        <t-b class="indent">
          <table style="font-size:1em;">
            <tr>
              <th>Link</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>
                <a href="https://docs.rs/regex/1.4.5/regex/index.html#syntax">Regular Expression Syntax</a>
              </td>
              <td>
                Nice organization of regular expression pattern language syntax
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://docs.rs/regex/1.4.5/regex/struct.Regex.html">regex::Regex</a>
              </td>
              <td>
                Documentation for Regex and its methods.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://docs.rs/regex/1.4.5/regex/index.html">Crate regex</a>
              </td>
              <td>
                Regex crate documentation.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/">Jeff Atwood&apos;s Blog</a>
              </td>
              <td>
                Establishes the arena, provides advice and several very good links.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://en.wikipedia.org/wiki/Regular_expression">Regular expression - Wikipedia</a>
              </td>
              <td>
                Quite extensive discussion of theory, syntax, and semantics.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://cheatography.com/davechild/cheat-sheets/regular-expressions/pdf_bw/">RE Cheat Sheet - Dave Child</a>
              </td>
              <td>
                Nice compact summary.
              </td>
            </tr>
            <tr>
              <td>
                <a href="https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285">RE Tutorial - Factory Mind</a>
              </td>
              <td>
                Clear and fairly brief.
                <div style="height:0.25em;"></div>
              </td>
            </tr>
          </table>
        </t-b>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#syntax">syntax</a>
        <a href="#regex">regex</a>
        <a href="#epilogue">epilogue</a>
        <a href="#refs">refs</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 33, 10);
  </script>
</body>
</html>
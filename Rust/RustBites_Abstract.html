<!DOCTYPE html>
<html id="top">
<!--
  RustBites_Abstract.html
-->
<head>
  <title>Rust Abstractions</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    td {
      font-size: 0.9rem;
      vertical-align: top;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_Abstract.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/10/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Abstractions</h2>
        <h4 id="subtitle" class="indent">
          Software abstractions are simplified models of code        
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>
    </header>
        <a id="intro"></a>
        <h2>1.0 Introduction</h2>
        <div class="indent">
          <t-b>
            Abstractions are simpified representations of complex entities, things that are composed of many detailed parts and processing.
          </t-b>
          <t-b>
            Large software systems may be composed of hundreds of thousands, even millions, of lines of source code.  Much more than any
            developer can understand completely.  In order to use and maintain these systems a developer needs to have some way of
            understanding their properties and expected operations.
          </t-b>
          <t-b>
            Most often we factor systems into components that are small enough to be well understood and visualize the complete system
            as couplings of these smaller components.  Often the components themselves may be decomposed into fundamental parts.
          </t-b>
          <t-b>
            An abstraction consists of a set of components with specified responsibilities and usually one or more diagrams That
            illustrate ownership and usage relationships between components.
          </t-b>
        </div>
        <a id="rustcomm"></a>
        <h2>2. RustComm Abstraction</h2>
        <div class="indent">
          <div style="width:calc(100vw - 5rem);">
            <div class="right" style="padding:0rem 1rem;">
              <photosizer-block src="pictures/CommAbstraction.jpg" width="600" class="photoSizerBlock" style="margin-top:0;">
                <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS', Tahoma;
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                  Figure 1. RustComm Abstractions
                </span>
              </photosizer-block>            
             </div>
             <div style="height:0.75rem;"></div>
             <div class="right" style="padding:0rem 1rem;">
                <photosizer-block src="pictures/RustCommTest3.jpg" width="600" class="photoSizerBlock" style="margin-top:0;">
                  <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS', Tahoma;
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
             ">
                    Figure 2. RustComm Testing
                  </span>
                </photosizer-block>
              </div>
            </div>
          </div>
          <t-b style="position:relative; top:-1.5rem;">
            We will use code from the <a target="_blank" href="../../RustComm.html">RustComm</a> repository as an Example for this discussion.
            RustComm is a message-passing communication system based on Tcp Sockets provided by the Rust std::net library.
          </t-b>
          <t-b>
            Figure 1. is a Universal Modeling Language (UML) class diagram that displays the most important types and traits used
            in the RustComm implementation.  The main players are <c-s>Connector&lt;M,P,L&gt;</c-s> and
            <c-s>Listener&lt;P,L&gt;</c-s>.
          </t-b>
          <t-b>
            <c-s>Listener&lt;P,L&gt;</c-s> listens for incoming connection requests, extablishes a connection, and processes
            received messages, returning a reply for each. P is a generic parameter representing one of a set of processing types that
            determine what the listener does with incoming messages, and how it replies. L is a generic parameter representing one of a
            set of loggers used to capture processing events.
          </t-b>
          <t-b>
            <c-s>Connector&lt;M,P,L&gt;</c-s> attempts to establish connections with a listener at a specified endpoint, ipaddress:port.
            If a connection is established it then sends messages and receives replies.  The generic arguments M, P, and L represent sets
            of message, processing, and logging types.  Each of them are constrained by traits, some of which are shown in Fig. 1.
          </t-b>
          <t-b>
            The traits <c-s>Msg</c-s>, <c-s>Sndr&lt;&gt;</c-s>, <c-s>Rcvr&lt;&gt;</c-s>, <c-s>Process&lt;M&gt;</c-s> and <c-s>Logger</c-s>
            each define method signatures that types with those
            traits are obligated to implement.  Traits say nothing about the implementation of those methods, so each trait establishes a
            bound on the types that the library uses.
            <div>
              <ul>
                <li>
                  <c-s>Msg</c-s> defines methods that messages provide for managing their contents.  The <c-s>Msg</c-s> trait was designed to support more than
                  one style of message.  RustComm uses fixed header size messages, but <c-s>Msg</c-s> supports other types as well.
                </li>
                <li>
                  <c-s>Sndr&lt;M&gt;</c-s> and <c-s>Rcvr&lt;M&gt;</c-s> define method signatures for sending and receiving messages.  They are parameterized on
                  a Message type <c-s>M</c-s>, so they can be tailored to the type of messages a library defines.
                </li>
                <li>
                  <c-s>Process&lt;M&gt;</c-s> declares methods for processing messages.  Both <c-s>Connector&lt;M,P,L&gt;</c-s> and
                  <c-s>Listener&lt;P,L&gt;</c-s> have process members which are different, but satisfy the same trait bounds.
                </li>
                <li>
                  <c-s>Logger</c-s> defines method signatures for writing to log streams in the console or files.
                </li>
                <li>
                  The generic parameters: <c-s>M</c-s>, <c-s>P</c-s>, and <c-s>L</c-s> are also bound by some of Rust&apos;s std traits,
                  e.g., <c-s>Debug</c-s>, <c-s>Clone</c-s>, <c-s>Send</c-s>, <c-s>Sync</c-s>, and in some cases <c-s>Copy</c-s>, and <c-s>'static</c-s>.
                </li>
              </ul>
            </div>
          </t-b>
          <t-b>
            <c-s>Connector&lt;M,P,L&gt;</c-s> and <c-s>Listener&lt;P,L&gt;</c-s> use the <c-s>TcpStream</c-s> and <c-s>TcpListener</c-s> types to
            provide socet-based Tcp messaging infrastructure.
          </t-b>
          <t-b>
            Each of the four layers shown in Fig 1. have a specific role to play in RustComm&apos;s implementation:
            <div>
              <ul>
                <li>
                  The top, traits, layer provides component interfaces that are implementation agnostic.  That means that
                  <c-s>Connector&lt;M,P,L&gt;</c-s> and <c-s>Listener&lt;P,L&gt;</c-s> can easily adopt different messaging and message-passing
                  designs without a lot of breakage, because most of their code uses the trait interfaces.
                </li>
                <li>
                  The second, generic parameter layer, supports compile-time substitution of specialized components that tailor RustComm behaviors
                  to meet the needs of a specific design.
                </li>
                <li>
                  The third, custom type layer, holds the connector and listener user-defined types.  They provide the framework that supports and
                  uses the first two layers.  It is this layer that using code works with to build communicating processes.
                </li>
                <li>
                  The bottom, std libary component, layer provides all of the low level system processing, greatly simplifying implementation
                  of listener and connector.
                </li>
              </ul>
            </div>
          </t-b>
          <t-b>
            You can access all of the code for RustComm in this <a target="_blank" href="https://github.com/JimFawcett/RustComm">Repository</a>.
          </t-b>
        </div>
        <a id="epilogue"></a>
        <h2>3. Epilogue</h2>
        <div class="indent">
          <t-b>
            The combination of traits and generic types provides a powerful environment for building flexible systems that can adapt to
            changing requirements and be used to explore new design ideas.  Adding selections from the well crafted Rust std libraries can lead
            to designs that are easy to use, understand and maintain, and modify for new uses.  Highly recommended.
          </t-b>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#rustcomm">rustcomm</a>
        <a href="#epilogue">epilogue</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 22, 10);
  </script>
</body>
</html>
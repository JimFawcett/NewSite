<!DOCTYPE html>
<html id="top">
<!--
  RustBasics_Code.html
-->
<head>
  <title>Rust Basics Code</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="css/ThemeRust.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="js/BasicsBitesPages.js"></script>
  <link rel="stylesheet" href="css/FigureSizer.css" />
  <script src="js/FigureSizer.js"></script>
  <link rel="stylesheet" href="css/link-nav.css" />
  <link rel="stylesheet" href="css/content-links.css" />
  <script src="js/cookies.js"></script>
  <script src="js/contentElements.js"></script>
  <script src="js/contentMessages.js"></script>
  <script src="../js/CodeViewerComponent.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      // loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
      // hideInfoMsgs();
    }
  </script>
  <style>
    html {
      position:static;
      top:0rem;
      left:0rem;
      /* height: 100vh; */
      width: 100vw;
      box-sizing: border-box;
      margin: 0rem;
      padding: 0rem;
    }
    body {
      box-sizing: border-box;
      min-height: 100vh;
      width: 100%;
      padding:1rem 2rem;
      margin: 0rem;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow-y: auto;
      overflow-x: hidden;
      border:1px solid red;
    }
    t-b {
      display: block;
      margin: 0.75rem 0rem;
      max-width: 50rem;
    }
    c-s {
      display: inline;
      font-family: consolas, 'Courier New', Courier, monospace
    }
    h3 {
      clear: both;
    }
    inset {
      display:block;
      font-size: 0.9rem;
      margin: 0.25rem 1rem;
    }
  </style>
</head>
<body id="github" onload="load()">
  <!-- <a id="top" style="height:0rem;"></a> -->

  <a id="next" class="hidden" href="RustBasics_Code.html"></a>
  <a id="prev" class="hidden" href="RustBasics_Code.html"></a>

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="toggleAbout()">
    RustBasics_Code.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 02/13/2025
  </div>

  <content-block>
    <header class="spread-down">
      <!-- <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/NewSite/tree/main/Rust">
        Rust Bites Code
      </a> -->
      <div id="pagetitle" class="header">
        <h2>RustBasics: Code</h2>
        <!-- <h4 id="subtitle" class="indent">Rust language, bites of Rust</h4> -->
      </div>
    </header>
    <t-b>
      Code views, like this, provide a series of relatively small figures with code and explanitory
      text in the left panel, and figures with output and explanitory text in the right panel. 
    </t-b>
  <t-b>
    Basics code provides code views for language primitives, simple types, and a few library
    collection types.
  </t-b>
  <h3 id="integrals">1.0 Rust Integral Types</h3>
  <div style="padding: 0rem 0rem 1rem 1rem; float: right;">
    <code-viewer style="padding:0px 10px">
        <span slot="title" style="margin-top:6px;">Figure 1a. Rust Integrals</span>
        <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 /*-----------------------------------------------
2 integrals: boolean, byte, integer
3 */
4 fn integrals() {
5   
6   show_note("integral types");
7   
8   nl();
9   show_op("booleans");
10   /*---------------------------------------*/
11   let b1 = true;
12   show_type(&b1, "b1");
13   
14   let b2 = false;
15   show_type(&b2, "b2");
16   
17   nl();
18   show_op("bytes");
19   /*-----------------------------------------
20   bytes in Rust are just u8 integers
21   - we can define an alternate name as here
22   */
23   type Byte = u8;  /* alternate type name */
24   let b:Byte = 0x41;
25   show_type(&b, "b");
26   println!("  b = 0x{b:x}");
27   
28   nl();
29   show_op("integers");
30   /*-----------------------------------------------
31   i8, i16, i32, i64, i128, isize - signed
32   u8, u16, u32, u64, u128, usize - unsigned
33   literals:
34   42 decimal, 0x2A hex, 0o52 octal,
35   0b10101 binary, b'A' byte
36   -----------------------------------------------*/
37   let i = 42u8;       /* typed literal */
38   show_type(&i, "i");
39   
40   let j:i32 = 42;     /* typed variable */
41   show_type(&j, "j");
42   
43   let k = 42;         /* inferred type */
44   show_type(&k, "k");
45   
46   nl();
47   /* types must match exactly or be cast */
48   
49   let sum1 = i as i32 + j;
50   outln_type(&sum1, "i as i32 + j");
51   
52   let sum2 = i + j as u8;
53   outln_type(&sum2, "i + j as u8");
54   
55 }</code></pre>
    </code-viewer>
  </div>
  <t-b>
    Integral types are booleans, bytes, and integers. Many implement functions that can be 
    called on their values and operators that combine their values.
  </t-b>
  <t-b>
    Figure 1.a explores declarations, initializations, and a few simple
    operations for integral types, e.g., bools, bytes, and integers.
  </t-b>
  <t-b>
    There are 12 integer types: six sizes for signed and unsigned values.
    i32 and usize are the most used integer types. The isize and usize types 
    have sizes defined by the platform, e.g., determined by the native pointer
    size.
    The default type is i32, commonly the result of type inference.
  </t-b>
  <t-b>
    Rust types can be specified on literals: 
    <inset>
      <c-s>let i = 42u8;</c-s>
    </inset>
    or on variables:
    <inset>
      <c-s>let j:i32 = 42;</c-s>
    </inset>
  </t-b>
  <t-b>
    Booleans implement:
    <inset>
      functions: <c-s>.then(f), .then_some(value), ...</c-s> <br>
      operators: <c-s>&, |, ^, !</c-s> 
    </inset>
  </t-b>
  <t-b>
    Integers implement many functions, e.g.:
    <inset>
      <c-s>to_string(), is_positive(), is_negative(), min(x,y), max(x,y), clamp(l,u), ...</c-s>
    </inset>
  </t-b>
  <div style="height:0.75rem; clear:both;"></div>
  <h3 id="floats">2.0 Floating Point Types</h3>
    <div style="padding:0rem 0rem 1rem 1rem; float: right;">
      <code-viewer style="padding:0px 10px;">
          <span slot="title" style="margin-top:6px;">Figure 2a. Floating Point Numbers</span>
          <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn floats() {
2   
3   show_note("floating point numbers");
4   
5   /*-----------------------------------------
6   types: f32, f64
7   special values:
8   NAN, INFINITY, NEG_INFINITY
9   operations:
10   +, -, *, /
11   functions:
12   floor(), ceil(), round(), sin(),
13   abs(), sqrt(), powf(), exp(), ln(),
14   sin(), cos(), tan(), log()
15   -----------------------------------------*/
16   
17   let d:f32 = 3.1415927;
18   show_type(&d, "d");
19   
20   let e:f64 = 3.1415927;
21   show_type(&e, "e");
22   
23   nl();
24   let div1 = d/(e as f32);
25   outln(&div1, "d/(e as f32)");
26   
27   let div2 = (d as f64)/e;
28   outln_type(&div2, "(d as f64)/e");
29   nl();
30   let f1 = 2.5f64;
31   outln_type(&f1, "f1");
32   let f2: f64 = f1.powf(2.0);
33   outln_type(&f2, "f1.powf(2.0)");
34   
35 }</code></pre>
        </code-viewer>
      </div>
    </div>
    <t-b>
      Rust implements the IEEE 754 standard for floating point
      arithmetic.
    </t-b>
    <t-b>
      There are two floating point types in Rust: 
      <inset>
        <c-s>f32</c-s> is single precision using 32 bits which represents
        approximately 7 significant digits.
      </inset>
      and:
      <inset>
        <c-s>f64</c-s> is double precision using 64 bits, representing
        about 15 significant digits.
      </inset>
    </t-b>
    <t-b>
      Rust floating point numbers can be combined with operators: 
      <inset>
        <c-s>+, -, *, /, %</c-s> 
      </inset>
      and provide the special values:
      <inset>
        <c-s>f64::INFINITY, f64::NEG_INFINITY, f64::NAN</c-s>
      </inset>
      </t-b>
      <t-b>
        Rust also supplies methods for floating point numbers:
        <inset>
          <c-s>x.abs(), x.floor(), x.ceil(), x.round(), x.trunc(), x.fract()</c-s>
        </inset>
      </t-b>
    <div style="height:0.75rem; clear:both;"></div>
    <h3 id="litstr">3.0 Literal Strings</h3>
    <div style="padding:0rem 0rem 1rem 1rem; float: right;">
      <code-viewer style="padding:0px 10px;">
          <span slot="title" style="margin-top:6px;">Figure 3a. Literal Strings</span>
          <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn literal_strings() {
2   show_note("literal strings");
3   /*---------------------------------------------
4   &str type represents a reference to const
5   literal strings placed in static memory
6   ---------------------------------------------*/
7   let ls = "a literal string"; /* reference to literal string */
8   show_type(&ls, "ls");
9 }</code></pre>
      </code-viewer>
  </div>
  <t-b>
    Rust&apos;s literal strings are a sequence of UTF-8 characters stored in static memory
    adjacent to the code that creates them.
  </t-b>
  <t-b>
    These are not arrays, as UTF-8 characters consist of 1 to 4 bytes that hold roman, greek,
    arabic, kanji, ... characters, numerals, and diacritics.
  </t-b>
  <t-b>
    Programs can sequence through the characters using an iterator, <code>chars()</code>,
    that uses leading bits to combine multiple bytes into a character entity.
  </t-b>
  <div style="height:0.75rem; clear:both;"></div>
  <h3 id="enums">4.0 Enumerations</h3>
  <div style="padding:0rem 0rem 1rem 1rem; float: right;">
    <code-viewer style="padding:0px 10px;">
        <span slot="title" style="margin-top:6px;">Figure 4a. Enumerations</span>
        <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn enumerations() {
2   show_note("enumerations");
3   /*---------------------------------------------
4   std enumerations:
5   Option { Some(v), None, }
6   Result { Ok(result), Err(error), }
7   Duration { secs: u64, nanos: u32, }
8   */
9   let ie = Some(42);
10   let ne: Option<i32> = None;
11   let demo = ne;
12   
13   /* handle both cases */
14   match demo {
15     Some(value) => outln(&value, "value"),
16     None => outln(&demo, "demo")
17   }
18   /* handle has value case, ignore no value case */
19   if let Some(value) = ie {
20     outln(&value, "value");
21   }
22   
23   /* custom enumeration */
24   #[derive(Debug)]
25   enum Trip {
26     Planning,
27     Going,
28     Arrived,
29     Coming,
30     Done,
31   }
32   
33   let trip_status = Trip::Planning;
34   outln(&trip_status, "trip_status");
35 }</code></pre>
    </code-viewer>
</div>
<t-b>
  Rust&apos;s enums are unique in that enumeration items may each contain values of an 
  arbitrary type.
</t-b>
<t-b>
  Examples are std::Option, Result, and Duration. Their declarations are shown in 
  comments in the code in Figure 4a. 
</t-b>
<t-b>
  The std::Option contains to items, <code>Some(v)</code> and <code>None</code>. 
  Here, <code>v</code> can be any type or generic parameter know to the compiler. 
</t-b>
<div style="height:0.75rem; clear:both;"></div>
<h4 id="arrays">5.0 Arrays</h4>
<div style="padding:0rem 0rem 1rem 1rem; float: right;">
  <code-viewer style="padding:0px 10px;">
      <span slot="title" style="margin-top:6px;">Figure 5a. Arrays</span>
      <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn arrays() {
2   
3   show_note("arrays of primitives");
4   /*---------------------------------------------*/
5   let arr1:[i32; 3] = [1, 2, 3];
6   show_type(&arr1, "arr1");
7   
8   let arr2 = [1i64, 2, 3];
9   show_type(&arr2, "arr2");
10   
11   let arr3 = [1.0, 2.0, 3.0];
12   show_type(&arr3, "arr3");
13 
14   let mut arr4:[f64; 5] = [0.0; 5];
15   arr4[0] = 0.5;
16   arr4[1] = 1.0;
17   arr4[4] = -0.5;
18   show_type(&arr4, "arr4");

</code></pre>
  </code-viewer>
</div>
<t-b>
  Arrays are fixed size allocations placed in the declaring function&apos;s stack frame 
  unless explicitly Boxed to create a heap allocation (more on Boxing later).
</t-b>
<t-b>
  Small arrays are usually intialized as part of their declaration, as shown in 
  Figure 5a. Alternately, they can be initialzed to a repeated fixed value, then 
  mutated later as needed.
</t-b>
<div style="height:0.75rem; clear:both;"></div>
<h3 id="refs">6.0 Rust References</h3>
<div style="padding:0rem 0rem 1rem 1rem; float: right;">
  <code-viewer style="padding:0px 10px;">
      <span slot="title" style="margin-top:6px;">Figure 6a. References</span>
      <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn references() {
2   show_note("references");
3   /*---------------------------------------------
4   - &t is a const pointer to the value t:T
5   - &mut t is a reference to a value that may
6   be mutated.
7   - Rust does not allow shared mutation using
8   references. More on that later.
9   */
10   let mut arr:[i32; 4] = [1, 2, 3, 4];
11   outln_type(&arr, "arr");
12   
13   show_op("let val = arr[1]");
14   let val = arr[1];
15   outln(&val, "val");
16   
17   /* take mutable reference */
18   show_op("let r1 = &mut arr");
19   let r1 = &mut arr;
20   outln_type(r1, "r1");
21   
22   show_op("r1[1] = -2");
23   r1[1] = -2;
24   outln(r1, "r1");
25   
26   /* take immutable reference */
27   show_op("let r2 = &arr");
28   let r2 = &arr;
29   outln(r2, "r2");
30   outln(&r2[1], "r2[1]");
31   /*
32   statement below fails to compile:
33   outln(r1, "r1");
34   not allowed because mutable reference must have
35   exclusive access.
36   */
37 }</code></pre>
  </code-viewer>
</div>
<t-b>
  Rust references are pointers with fixed addresses and strict rules about 
  mutation to prevent shared mutation. That is not allowed in Rust to support 
  memory safety.
</t-b>
<t-b>
  References are most frequently used to pass values by reference, as shown 
  in Figure 6a. 
</t-b>
<div style="height:0.75rem; clear:both;"></div>
<h3 id="tuples">7.0 Tuples</h3>
<div style="padding:0rem 0rem 1rem 1rem; float: right;">
  <code-viewer style="padding:0px 10px;">
      <span slot="title" style="margin-top:6px;">Figure 7a. Tuples</span>
      <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn tuples() {
2   
3   show_note("tuples");
4   /*---------------------------------------*/
5   let mut tup = (42, 3.1415927, [1, 2, 3]);
6   show_type(&tup, "tup");
7   show_op("tup.1 = 1.2");
8   tup.1 = 1.2;  /* access element by position */
9   show_type(&tup, "tup");
10 }</code></pre>
  </code-viewer>
</div>
<t-b>
  Tuples are compositions of a finite number of heterogeneous types. 
  Their values are accessed by position, as shown by <code>tup.1 = 1.2;</code>, in 
  Figure 7a.
</t-b>
<div style="height:0.75rem; clear:both;"></div>
<h3 id="structs">8.0 Structs</h3>
<div style="padding:0rem 0rem 1rem 1rem; float: right;">
  <code-viewer style="padding:0px 10px;">
      <span slot="title" style="margin-top:6px;">Figure 8a. Structs</span>
      <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn structs() {
2   show_note("structs");
3   /*---------------------------------------------*/
4   #[derive(Debug)]
5   struct Demo { i:i32, d:f64, c:char }
6   
7   /* use Demo */
8   let mut s1 = Demo { i:1, d:2.5, c:'z'};
9   show_type(&s1, "s1");
10   
11   s1.d = -2.5;  /* access element by name */
12   show_op("s1.d = -2.5");
13   show_type(&s1, "s1");
14 }</code></pre>
  </code-viewer>
</div>
<t-b>
  Structs are also compositions of heterogeneous values that are accessed by name, 
  as in <code style="white-space: nowrap;">s1.d = -2.5;</code> in Figure 8a.
</t-b>
<t-b>
  Rust uses structs to define patterns to build objects, as many other languages use 
  classes.
</t-b>
<t-b>
  We&apos;ll see an example of that in Section 10.0 User-Defined Types.
</t-b>
<div style="height:0.75rem; clear:both;"></div>
<h3 id="libtypes">9.0 Library Types</h3>
<div style="padding:0rem 0rem 1rem 1rem; float: right;">
  <code-viewer style="padding:0px 10px;">
      <span slot="title" style="margin-top:6px;">Figure 9a. std::library Types</span>
      <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 use std::collections::*;
2 
3 fn libtypes() {
4   
5   show_note("std::lib collection types");
6   
7   nl();
8   show_op("String");
9   /*---------------------------------------*/
10   let s1:String = "this is a string".to_string();
11   show_type(&s1, "s1");
12   
13   show_op("let first = s1.chars().next()");
14   let first = s1.chars().next();
15   let mut ch = first.unwrap_or(' ');
16   show_type(&ch, "ch");
17   
18   show_op("let second = s1.chars().nth(1)");
19   let second = s1.chars().nth(1);
20   ch = second.unwrap_or(' ');
21   outln_type(&ch, "ch");
22   
23   show_op("let s2 = s1.clone()");
24   let s2 = s1.clone();
25   outln_type(&s2, "s2");
26   
27   show_op("let s3 = s1 + \" and more\"");
28   let s3 = s1 + " and more";
29   outln(&s3, "s3");
30   
31   nl();
32   show_op("Vec<T>");
33   /*---------------------------------------*/
34   let mut v1:Vec<i32> = vec![1, 2, 3];
35   show_type(&v1, "v1");
36   
37   /* basic Vec<T> operations */
38   show_op("v1.push(0)");
39   v1.push(0);
40   outln(&v1, "v1");
41   
42   show_op("v1.insert(0, 42)");
43   v1.insert(0, 42);
44   outln(&v1, "v1");
45   
46   show_op("v1.pop()");
47   v1.pop();
48   outln(&v1, "v1");
49   
50   /* using mutable reference */
51   show_op("let r = &mut v1[1]; *r = -42;");
52   let r = &mut v1[1];
53   *r = -42;
54   outln(&v1, "v1");
55   
56   nl();
57   show_op("VecDeque<T>");
58   /*---------------------------------------*/
59   let mut vd1 = VecDeque::<f64>::new();
60   vd1.extend([1.0, 1.5, 2.0]);
61   show_type(&vd1, "vd1");
62   
63   show_op("vd1.push_front(0.5)");
64   vd1.push_front(0.5);
65   outln(&vd1, "vd1");
66   
67   show_op("vd1.pop_back()");
68   vd1.pop_back();
69   outln(&vd1, "vd1");
70   
71   nl();
72   show_op("HashMap<K, V>");
73   /*---------------------------------------*/
74   let mut hm1 = HashMap::<&str, i32>::new();
75   hm1.extend(
76   [
77   ("one", 1), ("two", 2), ("three", 3)
78   ]
79   );
80   show_type(&hm1, "hm1");
81   
82   show_op("hm1.insert(('zero', 0))");
83   hm1.insert("zero", 0);
84   outln(&hm1, "hm1");
85   
86   show_op("hm1.get(\"two\")");
87   let mut key = "two";
88   let value = hm1.get(key);
89   outln(&value, "Some(value)");
90   if let Some(val) = value {
91     outln(&val, "value");
92   }
93   else {
94     println!("  {key}: invalid key");
95   };
96   show_op("hm1.get(\"foo\")");
97   key = "foo";
98   let value = hm1.get(key);
99   outln(&value, "Some(value)");
100   if let Some(val) = value {
101     outln(&val, "value");
102   }
103   else {
104     println!("  {key}: invalid key");
105   };
106   
107 }</code></pre>
  </code-viewer>
</div>
<t-b>
  All of the types before library types implement the Copy trait.
  That means that assignments and pass-by-value operations implicitly copy a value.
</t-b>
<t-b>
  Collection types from std::library and many user-defined types do not implement the 
  Copy trait which makes them Move types. 
</t-b>
<t-b>
  For them, assignment and pass-by-value transfers
  ownership of their internal resources to the target, rendering the original values 
  invalid. We will have more to say about this in a later Rust Code View.
</t-b>
<div style="height:0.75rem; clear:both;"></div>
<h3 id="userdef">10.0 User-Defined Types</h3>
<div style="padding:0rem 0rem 1rem 1rem; float: right;">
  <code-viewer style="padding:0px 10px;">
      <span slot="title" style="margin-top:6px;">Figure 10a. User-defined Types</span>
      <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">1 fn usertypes() {
2   
3   show_note("user-defined types");
4   
5   nl();
6   show_op("Demo");
7   /*---------------------------------------*/
8   
9   #[derive(Debug, Clone)]
10   pub struct Demo {
11     /* pub name provides direct access to data */
12     pub name:String,
13   }
14   impl Demo {
15     /* create instance */
16     pub fn new() -> Self {
17       Self {
18         name:"no name".to_string(),
19       }
20     }
21     /* replace instance with modified version */
22     pub fn init(self, st:&str) -> Self {
23       Demo { name: st.to_string() }
24     }
25     /* retrieve name, uses method instead of direct access*/
26     pub fn get(&self) -> String {
27       self.name.clone()
28     }
29     /* modify name, uses method instead of direct access */
30     pub fn set(&mut self, st:&str) {
31       self.name = st.to_string();
32     }
33   }
34   
35   show_op("let mut d = Demo::new().init(\"Joe\")");
36   let mut d = Demo::new().init("Joe");
37   show_type(&d, "d");
38   
39   /* access through methods doesn't need public data */
40   show_op("d.set(\"Frank\")");
41   d.set("Frank");
42   outln(&d, "d");
43   
44   show_op("let name = d.get()");
45   let name = d.get();
46   outln(&name, "name");
47   
48   /* direct access to public data */
49   show_op("let d_name = d.name;");
50   let d_name = d.name;
51   outln(&d_name, "d_name");
52   
53   show_op("let d.name = Alexa;");
54   d.name = "Alexa".to_string();
55   outln(&d, "d");
56   
57   nl();
58 }</code></pre>
  </code-viewer>
</div>
<t-b>
  A user-defined type, <code>Demo</code> is defined in <span style="white-space: nowrap;">lines 9 - 33</span>, in Figure 10a.
</t-b>
<t-b>
  Line 9 requests the compiler to implement the <code>Debug</code> and <code>Clone</code> 
  traits. <code>Debug</code> supports dislay of an instance of Demo using the 
  <code>{:?}</code> format pattern. That shows all of the public structure of the 
  instance.
</t-b>
<t-b>
  <code>Clone</code> supports explicit creation of a copy of the Demo instance with a 
  call to <code>demo.clone()</code>.
</t-b>
<t-b>
  Definitions of methods occur in an <code>impl</code> block, shown starting at 
  <span style="white-space: nowrap">line 14</span>. 
</t-b>
<t-b>
  <code>Self</code>, in <span style="white-space: nowraps;">lines 16, 17, and 22</span>, is equivalent to the Demo type. 
</t-b>
<t-b>
  The variable <code>self</code> in <span style="white-space: nowraps;">lines 27 and 31</span> 
  refer to the current instance of Demo. 
</t-b>
<div style="height:0.75rem; clear:both;"></div>
<h3 id="structure">11.0 Program Structure</h3>
<div style="padding:0rem 0rem 1rem 1rem; float: right;">
  <code-viewer style="padding:0px 10px;">
      <span slot="title" style="margin-top:6px;">Figure 11. Demo Program Structure</span>
      <pre style="width:20rem;"><code class="language-rust" style="font-size:0.75rem;">  1 /*-----------------------------------------------
2 Demonstrate Basic Rust values and operations
3 */
4 #![allow(dead_code)]
5 #![allow(clippy::approx_constant)]
6 
7 use std::fmt::*;
8 
9 fn main() {
10   println!("\nRust Basics");
11   integrals();
12   floats();
13   literal_strings();
14   enumerations();
15   arrays();
16   references();
17   tuples();
18   structs();
19   libtypes();
20   usertypes();
21 }</code></pre>
  </code-viewer>
</div>
<t-b>
  Figure 11 shows the program structure, e.g., a <code>main()</code> function that 
  contains functions for each of the demonstrations above.
</t-b>
<t-b>
  Each code block, above, consists of the contents of one of these functions.
</t-b>
<div style="clear:both;"></div>
<div style="height:8em;"></div>
    <a id="bottom"></a>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleElement('sections')">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#integrals">integrals</a>
        <a href="#floats">floats</a>
        <a href="#litstr">literal string</a>
        <a href="#enums">enums</a>
        <a href="#arrays">arrays</a>
        <a href="#refs">references</a>
        <a href="#tuples">tuples</a>
        <a href="#structs">structs</a>
        <a href="#libtypes">libtypes</a>
        <a href="#userdef">usertypes</a>
        <a href="#structure">program structure</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
  </div>
  <script src="js/RustCodePages.js"></script>
  <script>buildPages()</script>
  <script src="js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 0, 10);
  </script>
  <a id="bottom"></a>
</body>
</html>
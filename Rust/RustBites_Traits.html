<!DOCTYPE html>
<html id="top">
<!--
  RustBites_Traits.html
-->
<head>
  <title>Rust Traits</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeRust.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <style>
    /* body {
      font-family: sans-serif;
      line-height: 1.6;
      margin: 2em;
      background: #f9f9f9;
      color: #222;
    } */
    /* h1 {
      text-align: center;
      color: #333;
    } */
    dt {
      font-weight: bold;
      margin-top: 0.5em;
      color: var(--dark);
    }
    dd {
      margin-left: 1em;
      margin-bottom: 0.25em;
    }
    section {
      margin-bottom: 1.5em;
    }
    /* h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.25em;
      color: #555;
    } */
    code {
      background: #eef;
      padding: 0 3px;
      border-radius: 3px;
    }
    section {
      font-size:0.9rem;
    }
    td {
      font-size: 0.9rem;
      vertical-align: top;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RustBites_Traits.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/10/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">Rust Bites: Traits</h2>
        <h4 id="subtitle" class="indent">
          generic types and traits       
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="RustHome.html" style="color:var(--light); margin-left:1.5em;">Rust Track</a>
      </div>
    </header>
        <t-b class="top">
          <s-halfEm></s-halfEm>
          <!--<div>-->
          <div>
            <a id="generics"></a>
            <h2>1. Generics:</h2>
            <t-b>
              Generics are abstract types used in functions and structs as placeholders for concrete
              types that will be supplied by an application.  This allows the functions and structs to
              be used with many different concrete types, without writing a definition for each type.
            </t-b>
            <t-b>
              Essentially, a generic function is a code generator for concrete functions and a
              generic struct is a code generator too, for a constrained set of concrete types.
              Constraints are supplied with traits.  In the illustration below, the Debug trait is
              used to limit concrete tyypes to those that can be formatted with the display specifier,
              &quot;<c-s>{:?}</c-s>&quot;.
            </t-b>
            <t-b>
              <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=e7cda53546d61025e1b79a785b34ef8f">
                Code in Rust Playground
              </a>
            </t-b>
            <t-b>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>Generic Function and Struct</defn-head>
                  <defn-code style="font-size:0.9em;">
  /////////////////////////////////////////////////////
  // generics_and_traits::main.rs - funct & struct   //
  /////////////////////////////////////////////////////

  use std::any::type_name;
  use std::fmt::*;

  /*-----------------------------------------
    Generic function gt
    - underscore in name, _t, indicates it
      will not be used in the function
    - the :Debug, below, is a trait constraint
      required by gf
    - if not satisfied, compilation fails
  */
  fn gf&lt;T: Debug&gt;(_t:T) {
    let tn = type_name::&lt;T&gt;();
    print!("\n  t is type {:?}", tn);
  }
  /*-----------------------------------------
    Generic struct
    - #[derive(Debug)] requests compiler to
    implement the Debug trait for Point
  */
  #[derive(Debug)]
  struct Point&lt;T&gt; { x:T, y:T, z:T, }

                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Using Code:</defn-head>
                  <defn-code style="font-size:0.9em;">
  /*-----------------------------------------
    First demnstration of generics and traits
  */
  fn main() {

    gf(3.14159);
    let pt = Point { x:0, y:1, z:2 };
    gf(pt);

    println!("\n\n  That's all Folks!\n\n");
  }
                  </defn-code>
                  <defn-head class="defnBorderTop">Output:</defn-head>
                  <defn-code style="font-size:0.9em;">
  cargo run -q

  t is type "f64"
  t is type "generics_and_traits::Point&lt;i32&gt;"

  That's all Folks!
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
              <s-halfEm></s-halfEm>
            </t-b>
          </div>
          <div>
            <a id="traits"></a>
            <h2>2. Traits:</h2>
            <t-b>
              A trait specifies one or more method or associated function signatures that a type with that trait is obligated
              to implement. Marker traits, like copy, are an exception, declaring no
              signature.  But they affect code generated by the compiler.

              <div class="pad10">
                <defn-outerBlock>
                  <defn-block>
                    <defn-head>Trait Expression</defn-head>
                    <defn-code style="font-size:0.9em;">
  pub trait Clone {
    fn clone(&self) -> Self;
    fn clone_from(&mut self, source: &Self) {
      ...
    }
  }
                    </defn-code>
                    <defn-body>
                      <a target="_blank" href="https://doc.rust-lang.org/std/clone/trait.Clone.html">std::clone::Clone</a>
                      from Rust crone crate documentation.
                    </defn-body>
                  </defn-block>
                  <defn-block style="max-width: 38%;">
                    <defn-head>Comments</defn-head>
                    <defn-body style="font-size:0.9em;">
                      <ol class="tight">
                        <li>
                          Traits may define methods they declare, but usually don&apos;t.
                        </li>
                        <li>
                          The &self and &mut self arguments are used for any methods bound to a struct.
                        </li>
                        <li>
                          The return type Self requires the clone method to return an instance
                          of its own type.
                        </li>
                      </ol>
                    </defn-body>
                  </defn-block>
                </defn-outerBlock>
              </div>
            </t-b>
            <t-b class="top">
              Traits are used to constrain generic parameter types and to support
              dynamic dispatching in polymorphic designs.  We will defer discussions of
              dynamic dispatch to the <a target="_blank" href="RustBites_Abstract.html">Abstraction</a> Bite.
            </t-b>
            <t-b>
              The table below lists the most commonly used traits defined in the Rust libraries.
              Custom traits are less frequently used, except for polymorphic designs.
            </t-b>
            <div style="height:0.5em">&nbsp;</div>
            <t-b>
              <h3 id="freq">Frequently Used Standard Traits:</h3>
              <table>
                <tr>
                  <th class="darkItem">Trait</th>
                  <th class="darkItem">Description</th>
                </tr>
                <tr>
                  <td class="lightItem"><a target="_blank" href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a></td>
                  <td class="lightItem">
                    Copy is a <strong>marker trait</strong>, so it has no methods for application code to call.
                    It&apos;s used by compiler to decide how to handle bindings and assignments.
                    If the data is Copy its value is copied from source to destination.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem"><a target="_blank" href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a></td>
                  <td class="lightItem">
                    Clone creates a new instance of the cloner type and copies into it the cloner&apos;s resources.
                    This is an expensive operation so Rust makes that explicit with the <c-s>fn clone(&self) -> Self method</c-s>.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem"><a target="_blank" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a></td>
                  <td class="lightItem">
                    Debug enables functions and structs to use the Debug format specifier &quot;<c-s>{:?}</c-s>&quot;.
                    That formats output in a relatively simple fashion, intended for debugging code, but useful elsewhere
                    as well. The Rust primitives and most of the Rust library types implement this Trait.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/beta/core/fmt/trait.Display.html">Display</a>
                  </td>
                  <td class="lightItem">
                    Display provides custom formatting for user-defined functions and structs with the
                    &quot;<c-s>{}</c-s>&quot; format placeholder. Some of the Rust types, like Strings,
                    implement Display.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a>
                  </td>
                  <td class="lightItem">
                    Default requires implementors to supply the associated function <c-s>fn default() -> Self</c-s>.
                    This is intended to allow users of the implementing type to set a default value for an
                    instance of the type at construction.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/string/trait.ToString.html">ToString</a>
                  </td>
                  <td class="lightItem">
                    ToString requires the method: <c-s>fn to_string(&self) -> String</c-s>.
                    This trait is automatically implemented for types that implement Display trait. The
                    Rust docs say &quot;ToString shouldn&apos;t be implemented directly: Display should
                    be implemented instead, ...&quot;
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a> and
                    <a target="_blank" href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a>
                  </td>
                  <td class="lightItem">
                    From requires the method: <c-s>fn from(T) -> Self</c-s>. That produces a value
                    conversion that consumes the original value. Into requires: <c-s>fn into(self) -> T</c-s>
                    with the same result. Implementing From automatically implements Into, but the reverse
                    is not true, so you should favor implementing From.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/str/trait.FromStr.html">FromStr</a>
                  </td>
                  <td class="lightItem">
                    FromStr requires the function <c-s>fn from_str(s: &str) -> Result&lt;Self, Self::Err&gt;</Self></c-s>
                    This function is usually used implicitly through str&apos;s parse method.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/convert/trait.AsRef.html">AsRef</a>
                  </td>
                  <td class="lightItem">
                    AsRef requires the function: <c-s>fn as_ref(&self) -> &T</c-s> and the Trait ?Sized.
                    The type of String.as_ref() is &String. AsRef allows a function accepting an &str to
                    accept any type that implements AsRef&lt;String&gt;.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/beta/std/ops/trait.Deref.html">Deref</a>
                  </td>
                  <td class="lightItem">
                    Deref specifies the function: <c-s>fn deref(&self) -> &Serlf::Target</c-s> and requires
                    the associated type: <c-s>type Target: ?Sized;</c-s>.  It is used to silently convert
                    a reference, r, into its referend, as if you invoked *r.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/beta/std/marker/trait.Sized.html">Sized</a> and
                    ?Sized
                  </td>
                  <td class="lightItem">
                    Sized is a <strong>marker trait</strong> for types with constant size known at compile time.  The ?Sized
                    trait means that the type size is not known at compile time, e.g., a heap-based array.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/io/trait.Read.html">Read</a>
                  </td>
                  <td class="lightItem">
                    Read specifies function:
                    <c-s>fn read(&mut self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>. The std::io::Read
                    provides many additional useful functions.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/io/trait.Write.html">Write</a>
                  </td>
                  <td class="lightItem">
                    Write specifies the function:
                    <c-s>fn write(&mut self, buf: &[u8]) -> Result&lt;usize&gt;</c-s>. std::io::Write
                    also specifies many additional useful functions.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a>
                  </td>
                  <td class="lightItem">
                    Iterator specifies the function: <c-s>fn next(&mut self) -> Option&lt;Self::Item&gt;</c-s>
                    where item is an associated type: <c-s>type Item;</c-s>.  Iterator has many additional
                    methods that make it useful for operating on collections.
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a target="_blank" href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">IntoIterator</a>
                  </td>
                  <td class="lightItem">
                    IntoIterator specifies the function: <c-s>fn into_iter(self) -> Self::IntoIter</c-s>
                    where Item is an associated type: <c-s>type Item;</c-s> and IntoIter is also an associated
                    type: <c-s>type IntoIter: Iterator;</c-s>.  IntoIterator defines how a collection type
                    converts to an Iterator.
                  </td>
                </tr>
              </table>
            </t-b>
            <t-b>
              Many of the these traits are derivable for user-defined types, e.g., structs, as shown
              in the opening example. The Rust compiler generates a default implementation if it can.
              You will see traits defined explicitly in the <a target="_blank" href="RustBites_Structs.html">Structs</a>
              Bite.
            </t-b>
            <t-b>
              Steve Donovan has provided a nicely crafted description of these traits, on which much of This
              discussion was based:
              <a target="_blank" href="https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html">
                The Common Rust Traits
              </a>.
            </t-b>
            <t-b>
              There is one important aspect of traits that is not discussed here: use for dynamic dispatch
              and polymorphic operations.  That is deferred to the
              <a target="_blank" href="RustBites_Structs.html">Structs</a> Bite.  If you are curious, Steve Donovan
              briefly discusses dynamic dispatch in the link above. Also, Josh Leeb has provided a related
              description of <a target="_blank" href="https://joshleeb.com/blog/rust-traits-trait-objects/">Trait Objects</a>
              That addresses some of the ideas we will present in Abstraction.
              <s-halfEm></s-halfEm>
            </t-b>
          </div>
          <a id="exercises"></a>
          <h2>3. Exercises:</h2>
          <ol class="tight" style="margin-left:2em;">
            <li>
              Write a generic function that accepts an array, [N; T] and converts that to a
              Vec&lt;T&gt;. Do that directly, without using any additional help from the
              Rust libraries.
            </li>
            <li>
              Repeat exercise #1 using an iterator to do all the work. Write the shortest
              line of code you can to accomplish this.
            </li>
            <li>
              Create a struct that holds the fields: name, occupation, and age (you pick the types).
              Now, can you endow that with the Display trait?
            </li>
            <li>
              Write code to demonstrate all the ways you can think of to convert a literal string:
              &quot;a string&quot; into a String instance.
            </li>
          </ol>
          </li>
          </ol>
        </t-b>
  <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#generics">generics</a>
        <a href="#traits">traits</a>
        <a href="#freq">freq</a>
        <a href="#exercises">exercises</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/RustBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 18, 10);
  </script>
</body>
</html>
<!DOCTYPE html>
<html id="top">
<!--
  SWDesignBites_StructureDataFlow.html
-->
<head>
  <title>DataFlow Structure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeSWDev.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/SplitterComponent.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="../js/SitePagesForTools.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css">
  <script src="../js/prism.js"></script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreSWDev.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    #github #statustable {
      table-layout: fixed;
      width: calc(100% - 0rem);
    }
    #github td {
      vertical-align: top;
      line-height: 1rem;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="CppRepos.html"></a>
  <a id="prev" class="hidden" href="CppRepos.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    SWDesignBites_StructureDataFlow.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/13/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">SW Design Bites: DataFlow Structure</h2>
        <h4 id="subtitle" class="indent">
          
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="SWDevHome.html" style="color:var(--atten); margin-left:1rem;">SWDev Track</a>
      </div>

      <!--<div style="padding-right:25px; position:absolute; top:1.1em; right:13em; z-index:5;">-->
    </header>
    <div style="height:0.75rem;"></div>
        <t-b class="indent">
          &quot;Begin at the beginning, the King said gravely, and go on till you come to the end;
          then stop.&quot;<br />
          - Lewis Carroll, Alice in Wonderland
        </t-b>
        <hr style="margin:1em 0em 1.5em 0em;" />
        <a id="intro"></a>
        <h3>1.0 Introduction</h3>
        <div class="indent">
          <t-b>
            This DesignBite sequence was inspired by BuildOn project <a href="../BuildOn/Step0.html">TextFinder</a>.
            As that project is designed and implemented, a number of design decisions are made, consciously or unconsciously.
            Each of these pages addresses one answer to questions about the fundamental structure design decisions.
          </t-b>
          <t-b>
            To make discussion pragmatic and concrete, we implement a program that evaluates the number of lines
            in text files.  Processing is quite simple so it allows us to see how each
            structure alternative is implemented.
          </t-b>
          <t-b>
            We consider both package structure and logical structure, e.g., functions and structs used to order
            design and implementation.  In this Dataflow Structure page, code is implemented in a set of packages
            Executive, Input, Compute, and Output and their
            structs.  That provides all of the organization for processing.
          </t-b>
        </div>
        <a id="structure"></a>
        <div style="height:0.25rem;"></div>
        <h3>2. Application Structure - DataFlow</h3>
        <div class="indent">
          <t-b>
            This structure is modular with a data flow structure.  It differs from the previous factored structure
            in that:
            <ul class="tight">
              <li>
                Output can now be shown to the user while processing continues.  This is often a very big
                ergonomic advantage.
              </li>
              <li>
                The Executive no longer owns all of the parts.  Now, Input owns Compute and Compute owns Output.
              </li>
              <li>
                Testing becomes more complicated because each of the non-Executive parts must provide a test mock
                for the part to which it sends output.
              </li>
            </ul>
          </t-b>
        </div>

        <div id="fig1" style="width:calc(100vw - 4rem);">
          <div style="display:flex; float:right; padding:1rem;">
            <photosizer-block src="pictures/Design4.jpg" width="400" class="photoSizerBlock" style="margin-top:0; float: right;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS', Tahoma;
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 3. DataFlow Pkg Structure
              </span>
            </photosizer-block>
          </div>
            <div style="border:1px solid var(--dark); padding: 0rem 1.0em;">
              <h4>Data Flow Structure</h4>
              <t-b>
                Data flow structure is designed to provide continuing output to users while the application
                is running, e.g., not just at the end.  For programs that process a lot of data and may
                continue running for a while, continuous display is much more satisfactory for the user, e.g.,
                no questions like: is it still running? am I getting the output I want? did the program crash?
              </t-b>
              <t-b>
                Data flow structure changes ownership.  Instead of the Executive owning everything, a pipeline
                is set up where each element of the pipeline owns the next element in the sequence.
              </t-b>
              <hr />
              <pros-cons>
                <div>
                  <h4>Pros:</h4>
                  <ol class="tight">
                    <li>Continuous output</li>
                    <li>Data has fewer passes, e.g., doesn't need to go back to Executive</li>
                    <li>
                      Data flow can be implemented with message passing.
                      That allows each stage in the pipeline to run on its own thread,
                      passing its results as messages to a blocking queue owned by the next stage.
                      Concurrent processing in each stage may make significant overall
                      performance improvements.
                    </li>
                  </ol>
                </div>
                <div>
                  <h4>Cons:</h4>
                  <ol class="tight">
                    <li>Harder to implement and test piece by piece</li>
                    <li>Most data flow applications will need test mocks</li>
                  </ol>
                </div>
                <div style="height: 1rem;"></div>
              </pros-cons>
            </div>
            <!-- </div> -->
          </div>
        </div>
          <!-- </div> -->
        </div>
        <div style="height:0.5rem;"></div>
        <a class="indent" href="https://github.com/JimFawcett/DesignStructure/tree/master/FactoredStructure">Factored Code Repository</a>
        <div style="height:1.0rem;"></div>
        <div style="height:1.0rem;"></div>
        <div id="executive" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Executive</span>
          <span style="float:right; font-weight:bold">Output</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// DataFlowStructure::Executive::main.rs                   //
//   - Executive creates and uses all lower level parts    //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    Executive only creates Input instance.  The rest of
    the pipeline self installs, e.g., Input creates Compute,
    and Compute creates Output.
*/
use input::*;

fn main() {
  let putln = || println!();

  print!(&quot;&#92;n  -- DataFlowStructure::Executive --&#92;n&quot;);

  let mut lines = 0;

  let mut inp = Input::new();
  let name = &quot;./src/main.rs&quot;;
  lines += inp.do_input(name);
  putln();

  let name = &quot;../Input/src/lib.rs&quot;;
  lines += inp.do_input(name);
  let name = &quot;../Input/examples/test1.rs&quot;;
  lines += inp.do_input(name);
  putln();

  let name = &quot;../Compute/src/lib.rs&quot;;
  lines += inp.do_input(name);
  let name = &quot;../Compute/examples/test1.rs&quot;;
  lines += inp.do_input(name);
  putln();

  let name = &quot;../Output/src/lib.rs&quot;;
  lines += inp.do_input(name);
  let name = &quot;../Output/examples/test1.rs&quot;;
  lines += inp.do_input(name);
  putln();

  let name = &quot;../Fileutils/src/lib.rs&quot;;
  lines += inp.do_input(name);
  putln();

  print!(&quot;&#92;n  total lines: {}&quot;, lines);

  print!(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}            </code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo run -q

  -- DataFlowStructure::Executive --

  file "./src/main.rs" has 52 lines of code      

  file "../Input/src/lib.rs" has 78 lines of code
  file "../Input/examples/test1.rs" has 18 lines of code

  file "../Compute/src/lib.rs" has 105 lines of code
  file "../Compute/examples/test1.rs" has 27 lines of code

  file "../Output/src/lib.rs" has 24 lines of code
  file "../Output/examples/test1.rs" has 16 lines of code

  file "../Fileutils/src/lib.rs" has 93 lines of code

  total lines: 413

  That's all Folks!
</code></pre>
              <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
                Cargo.toml
              </div>
            <pre><code class="language-tern">[package]
name = "executive"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
input = { path = "../Input" }
            </code></pre>
            <div style="height: 0.5rem;"></div>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Executive code resides in the left panel. It creates and uses instances of the type 
                  Input.
                </li>
                <li>
                  This type is defined by library Input::lib.rs.
                </li>
                <li>
                  Input provides function <c-s>fn do_input(&mut self, name: &str)</c-s>.
                  That attempts to open a named file and return its handle.
                </li>
              </ul>
            </div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="input" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Input Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// DataFlowStructure::Input::lib.rs                        //
//   - Attempts to return line count from file             //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - Input owns and instantiates Compute.
    - It attempts to open file and pass to Compute for
      processing.
    - Returns line count if successful
*/
use compute::*;
use file_utils::{open_file_for_read};

#[derive(Debug)]
pub struct Input {
  name: String,
  compute: Compute,
}
impl Input {
  pub fn new() -&gt; Input {
    Input {
      name: String::new(),
      compute: Compute::new(),
    }
  }
  pub fn do_input(&mut self, name: &str) -&gt; usize {
    let mut lines: usize = 0;
    self.name = name.to_string();
    let rslt = open_file_for_read(name);
    if let Ok(file) = rslt {
      self.compute.do_compute(name, file);
      lines = self.compute.lines();
    } else {
      print!(&quot;&#92;n  can't open file {:?}&quot;, name);
    }
    lines
  }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::Write;

    /// Helper to create a temp file with arbitrary contents
    /// and return its filesystem path.
    fn make_path(contents: &str) -&gt; String {
        let mut tmp = NamedTempFile::new().expect(&quot;create temp file&quot;);
        write!(tmp, &quot;{}&quot;, contents).expect(&quot;write to temp file&quot;);
        tmp.flush().expect(&quot;flush&quot;);
        let path = tmp.into_temp_path();
        let s = path.to_str().unwrap().to_string();
        // Keep the file around for the duration of the test suite
        path.keep().unwrap();
        s
    }

    #[test]
    fn missing_file_returns_zero() {
        let mut inp = Input::new();
        let lines = inp.do_input(&quot;definitely_not_a_file.txt&quot;);
        assert_eq!(lines, 0, &quot;should return 0 when the file can't be opened&quot;);
    }

    #[test]
    fn existing_file_invokes_compute() {
        // we don't assert an exact count here-just that it
        // recognized the file and returned &gt;0 for nonempty contents.
        let path = make_path(&quot;anything&quot;);
        let mut inp = Input::new();
        let lines = inp.do_input(&path);
        assert!(lines &gt; 0, &quot;should return a positive count for an existing file&quot;);
    }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-rust">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Fileutils)
   Compiling output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Output)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Compute)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Input)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
  C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Input
  > cargo test --lib
    Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Input)
      Finished `test` profile [unoptimized + debuginfo] target(s) in 0.21s
      Running unittests src\lib.rs (target\debug\deps\input-09ddb55c91a23b85.exe)

  running 2 tests
  test tests::test_do_input_no_file ... ok
  test tests::test_do_input_line_count ... ok

  test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
  </code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "input"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
compute = { path = "../Compute" }
file_utils = { path = "../Fileutils" }

[dev-dependencies]
tempfile = "3"      // tempfile crate from crates.io
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Input library defines the type <c-s>Input</c-s> containing one String data member. 
                </li>
                <li>
                  It defines one method <c-s>fn do_input(&mut self, name:&str) -> Option&lt;File&gt;</c-s>
                </li>
                <li>
                  That attempts to open a named file for reading, and, if successful, calls <c-s>compute.do_compute(name, file)</c-s>.
                </li>
                <li>
                  The Input library depends on the libraries <c-s>compute</c-s>, and <c-s>file_utils</c-s>.
                </li>
                <li>
                  It also depends on a crate, tempfile from crates.io, supporting creation of temporary files that 
                  self destruct when no longer referenced.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="compute" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Comp Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// DataFlowStructure::Compute::lib.rs                      //
//   - Attempts to read opened file to string, count lines //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - creates instance of Output
    - attempts to read file to string and count its lines
    - sends results to Output
*/
use output::Output;
use std::fs::*;

use file_utils::read_file_to_string;

#[derive(Debug)]
pub struct Compute {
  lines: usize,
  out: Output,
}
impl Compute {
  pub fn new() -&gt; Compute {
    Compute {
      lines: 0,
      out: Output::new(),
    }
  }
  pub fn do_compute(&mut self, name: &str, mut file: File) {
    let rslt = read_file_to_string(&mut file);
    if let Ok(contents) = rslt {
      if contents.len() == 0 {
        self.lines = 0;
      }
      else {
        self.lines = 1;
      }
      for ch in contents.chars() {
        if ch == '&#92;n' {
          self.lines += 1;
        }
      }
      self.out.do_output(name, self.lines);
    } else {
      print!(&quot;&#92;n  could not read {:?}&quot;, name);
    }
  }
  pub fn lines(&self) -&gt; usize {
    self.lines
  }
}

/// unit tests generated using ChatGPT 4o

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::{Write};

    /// Helper to write `contents` into a NamedTempFile and
    /// return a fresh File handle opened at the start.
    fn make_file(contents: &str) -&gt; std::fs::File {
        let mut tmp = NamedTempFile::new().expect(&quot;failed to create temp file&quot;);
        write!(tmp, &quot;{}&quot;, contents).expect(&quot;failed to write to temp file&quot;);
        tmp.flush().expect(&quot;failed to flush temp file&quot;);
        // Re-open so that the read pointer is at the start
        tmp.reopen().expect(&quot;failed to reopen temp file&quot;)
    }

    #[test]
    fn empty_file_has_zero_lines() {
        let file = make_file(&quot;&quot;);
        let mut comp = Compute::new();
        comp.do_compute(&quot;empty&quot;, file);
        assert_eq!(comp.lines(), 0);
    }

    #[test]
    fn file_without_newlines_has_one_line() {
        let file = make_file(&quot;just one line&quot;);
        let mut comp = Compute::new();
        comp.do_compute(&quot;single&quot;, file);
        assert_eq!(comp.lines(), 1);
    }

    #[test]
    fn file_with_multiple_lines_counts_correctly() {
        // Three logical lines separated by two '&#92;n's, no trailing newline
        let file = make_file(&quot;line1&#92;nline2&#92;nline3&quot;);
        let mut comp = Compute::new();
        comp.do_compute(&quot;three&quot;, file);
        assert_eq!(comp.lines(), 3);
    }

    #[test]
    fn file_with_trailing_newline_counts_empty_line() {
        // Two content lines + trailing '&#92;n' ␦ counts as 3 lines
        let file = make_file(&quot;foo&#92;nbar&#92;n&quot;);
        let mut comp = Compute::new();
        comp.do_compute(&quot;trailing&quot;, file);
        assert_eq!(comp.lines(), 3);
    }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Fileutils)
   Compiling output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Output)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Compute)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.34s
C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Compute
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling fastrand v2.3.0
   Compiling once_cell v1.21.3
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\DataFlowStructure\Compute)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.82s
     Running unittests src\lib.rs (target\debug\deps\compute-2bf6b10a5844dd6d.exe)

running 4 tests
test tests::empty_file_has_zero_lines ... ok
test tests::file_with_multiple_lines_counts_correctly ... ok
test tests::file_with_trailing_newline_counts_empty_line ... ok
test tests::file_without_newlines_has_one_line ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s     
            </code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "compute"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
output = { path = "../Output" }
file_utils = { path = "../Fileutils" }

[dev-dependencies]
tempfile = "3"
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  The Comp library defines the type Compute with two data members, lines and out, 
                  an instance of type Out. 
                </li>
                <li>
                  It provides two functions <c-s>fn do_compute(&mut self, name: &str, mut file: File)</c-s>
                  and <c-s>fn lines(&self) -> usize</c-s>.
                </li>
                <li>
                  This library defines unit tests for writing a string to a file and reading 
                  it back again, using either a filename string or a file handle.
                </li>
                <li>
                  <c-s>do_compute</c-s> attempts to read contents of file handle file into a String.
                  If successful it counts its lines and stores in self.lines.
                </li>
                <li>
                  <c-s>lines</c-s> returns the value stored in self.lines.
                </li>
                <li>
                  Cargo.toml [dependencies] identifies crates the library depends on.
                </li>
                <li>
                  Cargo.toml [dev-dependencies] identifies crates library tests depend on.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="output" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Output Library</span>
          <span style="float:right; font-weight:bold">Build</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// DataFlowStructure::Output::lib.rs                       //
//   - Sends results to console                            //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////

#[derive(Debug)]
pub struct Output {}
impl Output {
  pub fn new() -&gt; Output {
    Output {}
  }
  pub fn do_output(&self, name: &str, lines: usize) {
    print!(&quot;&#92;n  file {:?} has {} lines of code&quot;, name, lines);
  }
}
#[cfg(test)]
mod tests {
  #[test]
  fn it_works() {
    assert_eq!(2 + 2, 4);
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\FactoredStructure\Output)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.57s
C:\github\JimFawcett\NewSite\Code\DesignStructure\FactoredStructure\Output
            </code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "output"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Output library defines the type Output with no data members. 
                </li>
                <li>
                  It provides two functions <c-s>new()</c-s> and <c-s>fn do_output(&mut self, name: &str, lines: usize)</c-s>.
                </li>
                <li>
                  <c-s>do_output</c-s> displays a file name and its line count.
                </li>
                <li>
                  Because of its simplicity this library defines only one default unit test that always passes.
                </li>
                <li>
                  Cargo.toml [dependencies] is empty, signifying that this library only depends on the Rust standard library.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="fileutils" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Fileutils Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// FactoredStructure::Input::file_utilities.rs             //
//   - Input attempts to open named file and return File   //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  This code may be useful for other programs so it is
  factored into a module here.
*/
#![allow(dead_code)]

use std::fs::*;
use std::io::{Error, ErrorKind, Read, Write};

pub fn open_file_for_read(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let rfile = OpenOptions::new().read(true).open(file_name);
  rfile
}

pub fn read_file_to_string(f: &mut File) -&gt; Result&lt;String, std::io::Error&gt; {
  let mut contents = String::new();
  let bytes_rslt = f.read_to_string(&mut contents);
  if bytes_rslt.is_ok() {
    Ok(contents)
  } else {
    Err(Error::new(ErrorKind::Other, &quot;read error&quot;))
  }
}

pub fn open_file_for_write(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let wfile = OpenOptions::new()
    .write(true)
    .truncate(true)
    .open(file_name);
  wfile
}

pub fn write_string_to_file_handle(s: &str, mut f: std::fs::File) -&gt; std::io::Result&lt;()&gt; {
  f.write_all(s.as_bytes())?;
  f.flush()?;
  Ok(())
}

pub fn write_string_to_file(s: &str, file_name: &str) -&gt; std::io::Result&lt;()&gt; {
  std::fs::write(file_name, s)?;
  Ok(())
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn file_name_write_read() {
    let file_name = &quot;temp.txt&quot;;
    let test_string = &quot;test string&quot;;

    // Write using the filename
    open_file_for_write(file_name)
      .expect(&quot;open for write failed&quot;);
    write_string_to_file(test_string, file_name)
      .expect(&quot;write string failed&quot;);

    // Read back
    let mut rfile = open_file_for_read(file_name)
      .expect(&quot;open for read failed&quot;);
    let r_string = read_file_to_string(&mut rfile)
      .expect(&quot;read to string failed&quot;);

    assert_eq!(r_string, test_string);
  }

  #[test]
  fn file_handle_write_read() {
    let file_name = &quot;temp.txt&quot;;
    let test_string = &quot;test string&quot;;

    // Open for writing and write using handle
    let wfile = open_file_for_write(file_name)
      .expect(&quot;open for write failed&quot;);
    write_string_to_file_handle(test_string, wfile)
      .expect(&quot;write string failed&quot;);

    // Read back
    let mut rfile = open_file_for_read(file_name)
      .expect(&quot;open for read failed&quot;);
    let r_string = read_file_to_string(&mut rfile)
      .expect(&quot;read to string failed&quot;);

    assert_eq!(r_string, test_string);
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\FactoredStructure\Fileutils)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
C:\github\JimFawcett\NewSite\Code\DesignStructure\FactoredStructure\Fileutils
> cargo test --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\FactoredStructure\Fileutils)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running unittests src\lib.rs (target\debug\deps\file_utils-c70071d2546d9160.exe)

running 2 tests
test tests::file_handle_write_read ... ok
test tests::file_name_write_read ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

            </code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "file_utils"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Fileutils library has no dependencies other than the Rust standard libraries, 
                  as shown in the Cargo.toml file at the top of this view.
                </li>
                <li>
                  It does not define any new types, but does define several functions:
                  <ol>
                    <li>
                      <c-s>fn open_file_for_read(file_name: &str) -> Result&lt;File: std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a handle to its String contents. 
                      The return type is <c-s>Result&lt;File, std::io::Error&gt;</c-s>
                    </li>
                    <li>
                      <c-s>fn read_file_to_string(f: &mut File) -> Result&lt;String, std::io::Error&gt;</c-s><br>
                      Attempts to read contents referred to by file handle and return the string of contents 
                      wrapped in Ok(contents).
                    </li>
                    <li>
                      <c-s>fn open_file_for_write(file_name: &str) -> Result&lt;File, std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a File handle to the opened named file. 
                    </li>
                    <li>
                      <c-s>fn write_string_to_file_handle(s: &str, mut f: std::fs:::File) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to by the File handle and flush the handle.
                    </li>
                    <li>
                      <c-s>fn write_string_to_file(s: &str, file_name: &str) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to named file.
                    </li>
                  </ol> 
                </li>
                <li>
                  The Build and Test view above shows successful build and execution 
                  of two unit test functions.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.00rem;"></div>
        <a id="epilogue"></a>
        <div style="height:0.75rem;"></div>
        <h3>3. Epilogue</h3>
        <div class="indent">
          <t-b>
            The fourh design alternatives considered here:
            <ol class="tight">
              <li><a href="DesignBites_StructureBasic.html">Monolithic Structure</a></li>
              <li><a href="DesignBites_StructureFactored.html">Factored Structure</a></li>
              <li><a href="DesignBites_StructureDataFlow.html">DataFlow Structure</a></li>
              <li><a href="DesignBites_StructureTypeErase.html">TypeErase Structure</a></li>
              <li><a href="DesignBites_StructurePlugIn.html">PlugIn Structure</a></li>
            </ol>
            are progressively more flexible, eventually resulting in reusable components, but also increasingly
            complex.  Where you settle in these alternatives is determined by design context.  Is this a
            one-of-a-kind project that you want to finish quickly or is it
            heading for production code that will be maintained by more than one developer?
          </t-b>
        </div>
      </content>
      <a id="bottom"></a>
    <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#structure">structure</a>
        <a href="#executive">executive</a>
        <a href="#input">input</a>
        <a href="#compute">compute</a>
        <a href="#output">output</a>
        <a href="#fileutils">fileutills</a>
        <a href="#epilogue">epilog</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/DesignBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 4, 10);
  </script>
</body>
</html>
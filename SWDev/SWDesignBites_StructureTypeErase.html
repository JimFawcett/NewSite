<!DOCTYPE html>
<html id="top">
<!--
  SWDesignBites_StructureTypeErase.html
-->
<head>
  <title>Type Erase Structure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeSWDev.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/SplitterComponent.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="../js/SitePagesForTools.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css">
  <script src="../js/prism.js"></script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreSWDev.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    #github #statustable {
      table-layout: fixed;
      width: calc(100% - 0rem);
    }
    #github td {
      vertical-align: top;
      line-height: 1rem;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="CppRepos.html"></a>
  <a id="prev" class="hidden" href="CppRepos.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    SWDesignBites_StructureTypeErase.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/14/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">SW Design Bites: TypeErase Structure</h2>
        <h4 id="subtitle" class="indent">
          
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="SWDevHome.html" style="color:var(--atten); margin-left:1rem;">SWDev Track</a>
      </div>

      <!--<div style="padding-right:25px; position:absolute; top:1.1em; right:13em; z-index:5;">-->
    </header>
    <div style="height:0.75rem;"></div>
        <t-b class="indent">
          &quot;You can&apos;t depend on your eyes when your imagination is out of focus.&quot;<br />
          - Mark Twain
        </t-b>
        <hr style="margin:1em 0em 1.5em 0em;" />
        <a id="intro"></a>
        <h3>1.0 Introduction</h3>
        <div class="indent">
          <t-b>
            This DesignBite sequence was inspired by project <a href="SWDevProjects.html">TextFinder</a>.
            As that project is designed and implemented, a number of design decisions are made, consciously or unconsciously.
            Each of these pages addresses one answer to questions about fundamental decisions of structure.
          </t-b>
          <t-b>
            To make discussion pragmatic and concrete, we implement a program that evaluates the number of lines
            in text files.  Processing is quite simple so it allows us to see how each
            structure alternative is implemented.
          </t-b>
          <t-b>
            We consider both package structure and logical structure, e.g., functions and structs used to order
            design and implementation.  In this TypeErase Structure page, code is implemented in a set of packages
            Executive, Input, Compute, and Output and their
            structs.  That provides all of the organization for processing.
          </t-b>
          <t-b>
            An additional package, Fileutils, defines a series of file-handling functions used to implement 
            unit tests.
          </t-b>
        </div>
        <a id="structure"></a>
        <div style="height:0.25rem;"></div>
        <h3>2. Application Structure - TypeErase</h3>
        <div class="indent">
          <t-b>
            This structure is modular with a data flow structure.  It differs from the previous dataflow structure
            in that:
            <ul class="tight">
              <li>
                Its Input and Compute parts are parameterized on the types to which they send output.
              </li>
              <li>
                Each parameterized part depends only on the trait defined by its up-stream component part.
              </li>
              <li>
                That means that all non-Executive parts are immune to build breakage when other parts change.
              </li>
              <li>
                Its dependencies are opposite of the data flow structure.  Each part depends on its upstream
                package where the trait it uses is defined.  For that reason it is often said to implement the
                Dependency Inversion Principle.
              </li>
            </ul>
          </t-b>
        </div>
        <div style="height:0.75rem;"></div>
        <div style="width:calc(100vw - 4rem);">
          <div style="display:flex; float:right; padding:1rem;">
            <photosizer-block src="pictures/Design5a.png" width="500" class="photoSizerBlock" style="margin-top:0; float: right;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS', Tahoma;
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 4. Type Erasure Structure
              </span>
            </photosizer-block>
          </div>
            <div style="border:1px solid var(--dark); padding: 0rem 1.0em;">
            <h4>Type Erasure Structure</h4>
            <t-b>
              Type erasure can change dependency relationships. In Figure 4, <c-s>Input</c-s> holds a &quot;type erased&quot;
              instance of the compute block.  Input defines an interface it will call, <c-s>Compute</c-s>, that
              <c-s>ComputeImpl</c-s> implements.
              The Executive creates an instance of <c-s>Input&lt;ComputeImpl&lt;OutputImpl&gt;&gt;</c-s>.
              Input, internally, just uses the Compute interface, <c-s>Compute</c-s>.
            </t-b>
            <t-b>
              That means that both <c-s>InputImpl</c-s> and <c-s>ComputeImpl</c-s> depend on <c-s>Compute</c-s>.
              Since <c-s>InputImpl</c-s> defines <c-s>Compute</c-s>,
              the Compute package now depends on the Input package - the opposite of the basic
              data flow structure.  Because of that, we say this design uses dependency inversion.
            </t-b>
            <t-b>
              Now, Input can be instantiated by Executive with <strong>any</strong> type that implements Comp.
              It does not depend on any of the downstream implementation details, and so can be reusable.
            </t-b>
            <t-b>
              Similarly, Input instantiates an instance of <c-s>ComputeImpl&lt;Output&gt;</c-s> and 
              <c-s>ComputeImpl&lt;Output&gt;</c-s> instantiates an 
              instance of Output.
            </t-b>
            <t-b>
              Note that Executive is the only component that knows the concrete types of the other components. Each 
              of the other components know only the trait interface it implements.
            </t-b>
            <div style="height:0.75rem;"></div>
            <hr />
            <pros-cons>
              <div>
                <h4>Pros:</h4>
                <ol class="tight">
                  <li>Same as data flow</li>
                  <li>
                    The Input, Compute, and Output parts are now decoupled, each depending only on
                    the interfaces it defines and the interfaces of upstream components.
                  </li>
                </ol>
              </div>
              <div>
                <h4>Cons:</h4>
                <ol class="tight">
                  <li>
                    The building process becomes more complex.  Each component needs to use a factory
                    function to create its downstream component (to maintain type ignorance).
                  </li>
                </ol>
              </div>
              <div style="height:1.5rem;"></div>
            </pros-cons>
          </div>
        </div>
        <div style="height:0.5rem;"></div>
        <hr class="spread" />
        <a class="indent" href="https://github.com/JimFawcett/DesignStructure/tree/master/TypeEraseDataFlowStructure">TypeErase Code Repository</a>
        <div style="height:1.0rem;"></div>
        <div id="executive" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Executive</span>
          <span style="float:right; font-weight:bold">Output</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Executive::main.rs        //
//   - Executive creates and uses all lower level parts    //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    Executive only creates Input instance.  The rest of
    the pipeline self installs, e.g., Input creates Compute,
    and Compute creates Output.
*/
use compute::*;
use input::*;
use output::*;

fn main() {

  print!(&quot;&#92;n  -- TypeErasureDataFlowStructure::Executive --&#92;n&quot;);

  type Comp = ComputeImpl&lt;OutputImpl&gt;;
  let mut input = Input::&lt;Comp&gt;::new();  // factory function

  // Use it generically:
  let mut total = 0;
  for path in &[
    &quot;./src/main.rs&quot;,
    &quot;../Input/src/lib.rs&quot;,
    &quot;../Compute/src/lib.rs&quot;,
    &quot;../Output/src/lib.rs&quot;,
    &quot;../Fileutils/src/lib.rs&quot;
  ] {
    total += input.do_input(path);
  }

  print!(&quot;&#92;n  total lines: {}&quot;, total);

  print!(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo run -q

  -- TypeErasureDataFlowStructure::Executive --

  file "./src/main.rs": 39 lines

  file "../Input/src/lib.rs": 109 lines

  file "../Compute/src/lib.rs": 63 lines

  file "../Output/src/lib.rs": 26 lines

  file "../Fileutils/src/lib.rs": 94 lines

  total lines: 331

  That's all Folks!

</code></pre>
              <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
                Cargo.toml
              </div>
            <pre><code class="language-tern">[package]
name = "executive"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
input = { path = "../Input" }
compute = { path = "../Compute" }
output = { path = "../Output" }
            </code></pre>
            <div style="height: 0.5rem;"></div>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Executive code resides in the left panel. It creates and uses instances of the types 
                  OutputImpl, ComputeImpl, and InputImpl, all stored in heap memory.
                </li>
                <li>
                  The instances are wired into a dataflow pipeline: input to compute to output.
                </li>
                <li>
                  InputImpl provides function <c-s>fn do_input(&mut self, name: &str)</c-s>.
                  That attempts to open a named file and return its handle.
                </li>
                <li>
                  ComputeImple reads the file into a string and counts its lines. It then calls OutputImpl 
                  to display the name and lines.
                </li>
                <li>
                  Only Executive knows the concrete type names.  The other components simply use trait objects 
                  through their trait specified interface.
                </li>
              </ul>
            </div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="input" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Input Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Input::lib.rs             //
//   - Attempts to return line count from file             //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - Input owns and instantiates Compute.
    - It attempts to open file and pass to Compute for
      processing.
    - Returns line count if successful
*/
use file_utils::open_file_for_read;
use std::fs::*;

pub trait Compute {
  fn new() -&gt; Self;  // factory function
  fn do_compute(&mut self, name: &str, file: File);
  fn lines(&self) -&gt; usize;
}

#[derive(Debug)]
pub struct Input&lt;T: Compute&gt; {
  name: String,
  compute: T,
}
impl&lt;T: Compute&gt; Default for Input&lt;T&gt; {
  fn default() -&gt; Self {
    Self::new()
  }
}
impl&lt;T: Compute&gt; Input&lt;T&gt; {
  pub fn new() -&gt; Input&lt;T&gt; {
    Input {
      name: String::new(),
      compute: T::new(),    // factory function
    }
  }
  pub fn do_input(&mut self, name: &str) -&gt; usize {
    let mut lines: usize = 0;
    self.name = name.to_string();
    let rslt = open_file_for_read(name);
    if let Ok(file) = rslt {
      self.compute.do_compute(name, file);
      lines = self.compute.lines();
    } else {
      print!(&quot;&#92;n  can't open file {:?}&quot;, name);
    }
    lines
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::io::Write;
  use tempfile::NamedTempFile;

  /// A Compute stub: tracks if do_compute() was invoked,
  /// and always reports 42 lines.
  struct StubCompute {
    called: bool,
    return_lines: usize,
  }

  impl Compute for StubCompute {
    fn new() -&gt; Self {
      StubCompute {
        called: false,
        return_lines: 42,
      }
    }

    fn do_compute(&mut self, _name: &str, _file: File) {
      self.called = true;
    }

    fn lines(&self) -&gt; usize {
      self.return_lines
    }
  }

  #[test]
  fn missing_file_returns_zero_and_skips_compute() {
    let mut inp: Input&lt;StubCompute&gt; = Input::new();
    let count = inp.do_input(&quot;definitely_not_a_file.txt&quot;);
    assert_eq!(count, 0, &quot;should return 0 when file open fails&quot;);
    assert!(!inp.compute.called, &quot;do_compute must not be called&quot;);
  }

  #[test]
  fn existing_file_invokes_compute_and_returns_stub_value() {
    // create a real temp file so open_file_for_read succeeds
    let mut tmp = NamedTempFile::new().expect(&quot;create temp file&quot;);
    write!(tmp, &quot;ignored contents&quot;).expect(&quot;write to temp file&quot;);
    tmp.flush().expect(&quot;flush temp file&quot;);
    let path = tmp.path().to_str().unwrap();

    let mut inp: Input&lt;StubCompute&gt; = Input::new();
    let count = inp.do_input(path);

    assert_eq!(count, 42, &quot;should return the stub's return_lines value&quot;);
    assert!(
      inp.compute.called,
      &quot;do_compute must be called for existing file&quot;
    );
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-rust">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling once_cell v1.21.3
   Compiling fastrand v2.3.0
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.06s
     Running unittests src\lib.rs (target\debug\deps\input-f4e2ad4738f6bc68.exe)

running 2 tests
test tests::missing_file_returns_zero_and_skips_compute ... ok
test tests::existing_file_invokes_compute_and_returns_stub_value ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "input"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
file_utils = { path = "../Fileutils" }

[dev-dependencies]
tempfile = "3"        # tempfile crate from crates.io
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Input library defines the trait Compute and type <c-s>InputImpl</c-s> containing one String data member, 
                  and a smart Box pointer to trait object Compute in the heap.
                </li>
                <li>
                  It defines a <c-s>fn new(compute: Box&lt;dyn Computer&gt;)</c-s> that returns an InputImpl holding a 
                  smart Box pointer to the trait object Compute.
                </li>
                <li>
                  It defines another method <c-s>fn do_input(&mut self, name:&str) -> Option&lt;File&gt;</c-s>
                </li>
                <li>
                  That attempts to open a named file for reading, and, if successful, calls <c-s>compute.do_compute(name, file)</c-s>.
                </li>
                <li>
                  The Input library depends on the library <c-s>file_utils</c-s>.
                </li>
                <li>
                  It also depends on a crate, tempfile from crates.io, supporting creation of temporary files that 
                  self destruct when no longer referenced.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="compute" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Comp Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Compute::lib.rs           //
//   - Attempts to read opened file to string, count lines //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - creates instance of Output
    - attempts to read file to string and count its lines
    - sends results to Output
*/
use file_utils::read_file_to_string;
use input::Compute;
use std::fs::*;

pub trait Output {
  fn new() -&gt; Self;
  fn do_output(&self, name: &str, lines: usize);
}

#[derive(Debug)]
pub struct ComputeImpl&lt;Out: Output&gt; {
  lines: usize,
  out: Out,
}
impl&lt;Out: Output&gt; Compute for ComputeImpl&lt;Out&gt; {
  fn new() -&gt; ComputeImpl&lt;Out&gt; {
    ComputeImpl {
      lines: 0,
      out: Out::new(),
    }
  }
  fn do_compute(&mut self, name: &str, mut file: File) {
    let rslt = read_file_to_string(&mut file);
    if let Ok(contents) = rslt {
      if contents.is_empty() {
        self.lines = 0;
      } else {
        self.lines = 1;
      }
      for ch in contents.chars() {
        if ch == '&#92;n' {
          self.lines += 1;
        }
      }
      self.out.do_output(name, self.lines);
    } else {
      print!(&quot;&#92;n  could not read {:?}&quot;, name);
    }
  }
  fn lines(&self) -&gt; usize {
    self.lines
  }
}
#[cfg(test)]
mod tests {
  use super::*;
  use std::cell::RefCell;
  use std::fs::File;
  use std::io::Write;
  use std::rc::Rc;
  use tempfile::NamedTempFile;

  /// A stub Output that records the last (name, lines) it was given.
  struct StubOutput {
    last: Rc&lt;RefCell&lt;Option&lt;(String, usize)&gt;&gt;&gt;,
  }

  impl Output for StubOutput {
    fn new() -&gt; Self {
      // We never call this in tests; we construct StubOutput by hand.
      unreachable!(&quot;StubOutput::new should not be used in tests&quot;);
    }

    fn do_output(&self, name: &str, lines: usize) {
      *self.last.borrow_mut() = Some((name.to_string(), lines));
    }
  }

  /// Write `contents` into a temp file and reopen it so reads start at the beginning.
  fn make_file(contents: &str) -&gt; File {
    let mut tmp = NamedTempFile::new().expect(&quot;create temp file&quot;);
    write!(tmp, &quot;{}&quot;, contents).expect(&quot;write to temp file&quot;);
    tmp.flush().expect(&quot;flush temp file&quot;);
    tmp.reopen().expect(&quot;reopen temp file&quot;)
  }

  #[test]
  fn empty_file_emits_zero_and_reports_zero() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput {
      last: Rc::clone(&record),
    };
    // Construct ComputeImpl directly, bypassing ComputeImpl::new()
    let mut comp = ComputeImpl {
      lines: 0,
      out: stub,
    };

    let file = make_file(&quot;&quot;);
    comp.do_compute(&quot;empty&quot;, file);

    // internal count
    assert_eq!(comp.lines(), 0);
    // output called with (&quot;empty&quot;, 0)
    assert_eq!(*record.borrow(), Some((&quot;empty&quot;.to_string(), 0)));
  }

  #[test]
  fn no_newline_emits_one_and_reports_one() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput {
      last: Rc::clone(&record),
    };
    let mut comp = ComputeImpl {
      lines: 0,
      out: stub,
    };

    let file = make_file(&quot;single line&quot;);
    comp.do_compute(&quot;single&quot;, file);

    assert_eq!(comp.lines(), 1);
    assert_eq!(*record.borrow(), Some((&quot;single&quot;.to_string(), 1)));
  }

  #[test]
  fn multiple_lines_counted_correctly() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput {
      last: Rc::clone(&record),
    };
    let mut comp = ComputeImpl {
      lines: 0,
      out: stub,
    };

    let file = make_file(&quot;l1&#92;nl2&#92;nl3&quot;);
    comp.do_compute(&quot;multi&quot;, file);

    assert_eq!(comp.lines(), 3);
    assert_eq!(*record.borrow(), Some((&quot;multi&quot;.to_string(), 3)));
  }

  #[test]
  fn trailing_newline_adds_empty_line() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput {
      last: Rc::clone(&record),
    };
    let mut comp = ComputeImpl {
      lines: 0,
      out: stub,
    };

    let file = make_file(&quot;a&#92;nb&#92;n&quot;);
    comp.do_compute(&quot;trail&quot;, file);

    assert_eq!(comp.lines(), 3);
    assert_eq!(*record.borrow(), Some((&quot;trail&quot;.to_string(), 3)));
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\compute)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\compute
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling once_cell v1.21.3
   Compiling fastrand v2.3.0
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\compute)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.53s
     Running unittests src\lib.rs (target\debug\deps\compute-076bb42754ebb50e.exe)

running 4 tests
test tests::empty_file_emits_zero_and_reports_zero ... ok
test tests::multiple_lines_counted_correctly ... ok
test tests::no_newline_emits_one_and_reports_one ... ok
test tests::trailing_newline_adds_empty_line ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "compute"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
input = { path = "../Input" }
file_utils = { path = "../Fileutils" }

[dev-dependencies]
tempfile = "3"
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  The Comp library defines the type ComputeImpl with two data members, lines and out, 
                  a generic parameter that is required to implement the Output trait, as specified by 
                  <c-s>ComputeImpl&lt;Out: Output&gt;</c-s>. 
                </li>
                <li>
                  It provides thre functions <c-s>fn new()</c-s>,  
                  <c-s>fn do_compute(&mut self, name: &str, mut file: File)</c-s>
                  and <c-s>fn lines(&self) -> usize</c-s>.
                </li>
                <li>
                  <c-s>do_compute</c-s> attempts to read contents of file handle file into a String.
                  If successful it counts its lines and stores in self.lines.
                </li>
                <li>
                  <c-s>lines</c-s> returns the value stored in self.lines.
                </li>
                <li>
                  Cargo.toml [dependencies] identifies crates the library depends on.
                </li>
                <li>
                  Cargo.toml [dev-dependencies] identifies crates library tests depend on.
                </li>
                <li>
                  This library defines unit tests for counting lines in a file, considering several
                  cases indicated with function name and comments.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="output" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Output Library</span>
          <span style="float:right; font-weight:bold">Build</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Output::lib.rs            //
//   - Sends results to console                            //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////

use compute::Output;

#[derive(Debug)]
pub struct OutputImpl {}
impl Output for OutputImpl {
  fn new() -&gt; OutputImpl {
    OutputImpl {}
  }
  fn do_output(&self, name: &str, lines: usize) {
    print!(&quot;&#92;n  file {:?}: {:?} lines&#92;n&quot;, name, lines);
  }
}
#[cfg(test)]
mod tests {
  use super::*;

  /// `new()` + `Debug` should yield the type name.
  #[test]
  fn new_and_debug() {
    let out = OutputImpl::new();
    // The derived Debug for an empty struct prints exactly &quot;OutputImpl&quot;
    assert_eq!(format!(&quot;{:?}&quot;, out), &quot;OutputImpl&quot;);
  }

  /// `do_output()` returns unit and never panics.
  #[test]
  fn do_output_returns_unit() {
    let out = OutputImpl::new();
    // We don't capture stdout here; we just ensure it runs successfully and returns ()
    let ret = out.do_output(&quot;example.rs&quot;, 123);
    assert_eq!(ret, ());
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Compute)
   Compiling output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Output)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.34s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Output
> cargo test --lib
   Compiling output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Output)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running unittests src\lib.rs (target\debug\deps\output-e8639558e699949f.exe)

running 2 tests
test tests::do_output_returns_unit ... ok
test tests::new_and_debug ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "output"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
compute = { path = "../Compute" }
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Output library defines the type OutputImpl with no data members. 
                </li>
                <li>
                  It provides two functions <c-s>new()</c-s> and <c-s>fn do_output(&mut self, name: &str, lines: usize)</c-s>.
                </li>
                <li>
                  <c-s>do_output</c-s> displays a file name and its line count.
                </li>
                <li>
                  This library implements 2 simple unit tests.
                </li>
                <li>
                  Output depends only on Compute, as show in its Cargo.toml file.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="fileutils" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Fileutils Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// FactoredStructure::Fileutils::file_utilities.rs         //
//   - Input attempts to open named file and return File   //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  This code may be useful for other programs so it is
  factored into a module here.
*/
#![allow(dead_code)]

use std::fs::*;
use std::io::{Error, ErrorKind, Read, Write};

pub fn open_file_for_read(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let rfile = OpenOptions::new().read(true).open(file_name);
  rfile
}

pub fn read_file_to_string(f: &mut File) -&gt; Result&lt;String, std::io::Error&gt; {
  let mut contents = String::new();
  let bytes_rslt = f.read_to_string(&mut contents);
  if bytes_rslt.is_ok() {
    Ok(contents)
  } else {
    Err(Error::new(ErrorKind::Other, &quot;read error&quot;))
  }
}

pub fn open_file_for_write(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let wfile = OpenOptions::new()
    .write(true)
    .create(true)
    .truncate(true)
    .open(file_name);
  wfile
}

pub fn write_string_to_file_handle(s: &str, mut f: std::fs::File) -&gt; std::io::Result&lt;()&gt; {
  f.write_all(s.as_bytes())?;
  f.flush()?;
  Ok(())
}

pub fn write_string_to_file(s: &str, file_name: &str) -&gt; std::io::Result&lt;()&gt; {
  std::fs::write(file_name, s)?;
  Ok(())
}

#[cfg(test)]
mod tests {
  use super::*;
  use tempfile::NamedTempFile;

  /// Test the filename-based API: write_string_to_file + open_file_for_read + read_file_to_string
  #[test]
  fn write_and_read_via_filename() {
    // Create a temporary file and get its path as a String
    let tmp = NamedTempFile::new().expect(&quot;failed to create temp file&quot;);
    let path = tmp.path().to_str().unwrap().to_owned();

    let test_string = &quot;hello via filename&quot;;
    // Write via the file_name API
    write_string_to_file(test_string, &path).expect(&quot;write_string_to_file failed&quot;);

    // Read back
    let mut f = open_file_for_read(&path).expect(&quot;open_file_for_read failed&quot;);
    let contents = read_file_to_string(&mut f).expect(&quot;read_file_to_string failed&quot;);

    assert_eq!(contents, test_string);
  }

  /// Test the handle-based API: open_file_for_write + write_string_to_file_handle + open/read
  #[test]
  fn write_and_read_via_handle() {
    let tmp = NamedTempFile::new()
      .expect(&quot;failed to create temp file&quot;);
    let path = tmp.path().to_str().unwrap().to_owned();

    let test_string = &quot;hello via handle&quot;;
    // Open for write, then write via handle
    let wfile = open_file_for_write(&path)
      .expect(&quot;open_file_for_write failed&quot;);
    write_string_to_file_handle(test_string, wfile)
      .expect(&quot;write_string_to_file_handle failed&quot;);

    // Read back
    let mut f2 = open_file_for_read(&path)
      .expect(&quot;open_file_for_read failed&quot;);
    let contents2 = read_file_to_string(&mut f2)
      .expect(&quot;read_file_to_string failed&quot;);

    assert_eq!(contents2, test_string);
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling once_cell v1.21.3
   Compiling fastrand v2.3.0
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.02s
     Running unittests src\lib.rs (target\debug\deps\file_utils-43bed36694d2543d.exe)

running 2 tests
test tests::write_and_read_via_handle ... ok
test tests::write_and_read_via_filename ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "file_utils"
version = "0.1.0"
edition = "2024"

[dependencies]


[dev-dependencies]
tempfile = "3"
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Fileutils library has no dependencies other than the Rust standard libraries, 
                  as shown in the Cargo.toml above.
                </li>
                <li>
                  It does not define any new types, but does define several functions:
                  <ol>
                    <li>
                      <c-s>fn open_file_for_read(file_name: &str) -> Result&lt;File: std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a handle to its String contents. 
                      The return type is <c-s>Result&lt;File, std::io::Error&gt;</c-s>
                    </li>
                    <li>
                      <c-s>fn read_file_to_string(f: &mut File) -> Result&lt;String, std::io::Error&gt;</c-s><br>
                      Attempts to read contents referred to by file handle and return the string of contents 
                      wrapped in Ok(contents).
                    </li>
                    <li>
                      <c-s>fn open_file_for_write(file_name: &str) -> Result&lt;File, std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a File handle to the opened named file. 
                    </li>
                    <li>
                      <c-s>fn write_string_to_file_handle(s: &str, mut f: std::fs:::File) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to by the File handle and flush the handle.
                    </li>
                    <li>
                      <c-s>fn write_string_to_file(s: &str, file_name: &str) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to named file.
                    </li>
                  </ol> 
                </li>
                <li>
                  The Build and Test view above shows successful build and execution 
                  of two unit test functions.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.00rem;"></div>
        <a id="epilogue"></a>
        <div style="height:0.75rem;"></div>
        <h3>3. Epilogue</h3>
        <div class="indent">
          <t-b>
            The fourh design alternatives considered here:
            <ol class="tight">
              <li><a href="DesignBites_StructureBasic.html">Monolithic Structure</a></li>
              <li><a href="DesignBites_StructureFactored.html">Factored Structure</a></li>
              <li><a href="DesignBites_StructureDataFlow.html">DataFlow Structure</a></li>
              <li><a href="DesignBites_StructureTypeErase.html">TypeErase Structure</a></li>
              <li><a href="DesignBites_StructurePlugIn.html">PlugIn Structure</a></li>
            </ol>
            are progressively more flexible, eventually resulting in reusable components, but also increasingly
            complex.  Where you settle in these alternatives is determined by design context.  Is this a
            one-of-a-kind project that you want to finish quickly or is it
            heading for production code that will be maintained by more than one developer?
          </t-b>
        </div>
      </content>
    <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#structure">structure</a>
        <a href="#executive">executive</a>
        <a href="#input">input</a>
        <a href="#compute">compute</a>
        <a href="#output">output</a>
        <a href="#epilogue">epilogue</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/DesignBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 5, 10);
  </script>
</body>
</html>
<!DOCTYPE html>
<html id="top">
<!--
  SWDesignBites_StructureTypeErase.html
-->
<head>
  <title>Type Erase Structure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeSWDev.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/SplitterComponent.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="../js/SitePagesForTools.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css">
  <script src="../js/prism.js"></script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreSWDev.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    #github #statustable {
      table-layout: fixed;
      width: calc(100% - 0rem);
    }
    #github td {
      vertical-align: top;
      line-height: 1rem;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="CppRepos.html"></a>
  <a id="prev" class="hidden" href="CppRepos.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    SWDesignBites_StructureTypeErase.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/14/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">SW Design Bites: TypeErase Structure</h2>
        <h4 id="subtitle" class="indent">
          
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="SWDevHome.html" style="color:var(--atten); margin-left:1rem;">SWDev Track</a>
      </div>

      <!--<div style="padding-right:25px; position:absolute; top:1.1em; right:13em; z-index:5;">-->
    </header>
    <div style="height:0.75rem;"></div>
        <t-b class="indent">
          &quot;You can&apos;t depend on your eyes when your imagination is out of focus.&quot;<br />
          - Mark Twain
        </t-b>
        <hr style="margin:1em 0em 1.5em 0em;" />
        <a id="intro"></a>
        <h3>1.0 Introduction</h3>
        <div class="indent">
          <t-b>
            This DesignBite sequence was inspired by BuildOn project <a href="../BuildOn/Step0.html">TextFinder</a>.
            As that project is designed and implemented, a number of design decisions are made, consciously or unconsciously.
            Each of these pages addresses one answer to questions about fundamental decisions of structure.
          </t-b>
          <t-b>
            To make discussion pragmatic and concrete, we implement a program that evaluates the number of lines
            in text files.  Processing is quite simple so it allows us to see how each
            structure alternative is implemented.
          </t-b>
          <t-b>
            We consider both package structure and logical structure, e.g., functions and structs used to order
            design and implementation.  In this TypeErase Structure page, code is implemented in a set of packages
            Executive, Input, Compute, and Output and their
            structs.  That provides all of the organization for processing.
          </t-b>
        </div>
        <a id="structure"></a>
        <div style="height:0.25rem;"></div>
        <h3>2. Application Structure - TypeErase</h3>
        <div class="indent">
          <t-b>
            This structure is modular with a data flow structure.  It differs from the previous dataflow structure
            in that:
            <ul class="tight">
              <li>
                Its Input and Compute parts are parameterized on the types to which they send output.
              </li>
              <li>
                Each parameterized part depends only on the trait used by its downstream part.  That trait
                is definded in the caller&apos;s package.
              </li>
              <li>
                That means that all non-Executive parts are immune to build breakage when other parts change.
              </li>
              <li>
                Its dependencies are opposite of the data flow structure.  Each part depends on its upstream
                package where the trait it uses is defined.  For that reason it is often said to implement the
                Dependency Inversion Principle.
              </li>
            </ul>
          </t-b>
        </div>
        <div style="width:calc(100vw - 4rem);">
          <div style="display:flex; float:right; padding:1rem;">
            <photosizer-block src="pictures/Design5d.png" width="450" class="photoSizerBlock" style="margin-top:0; float: right;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS', Tahoma;
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 4. Type Erasure Structure
              </span>
            </photosizer-block>
          </div>
            <div style="border:1px solid var(--dark); padding: 0rem 1.0em;">
            <h4>Type Erasure Structure</h4>
            <t-b>
              Type erasure can change dependency relationships. In Figure 4, <c-s>InputImpl</c-s> holds a &quot;type erased&quot;
              instance of the compute block.  Input defines an interface it will call, <c-s>Compute</c-s>, that
              <c-s>ComputeImpl</c-s> implements.
              The Executive creates an instance of <c-s>InputImpl</c-s> that holds a smart pointer reference to a Compute trait object.
              Input, internally, just uses the Compute interface, <c-s>Compute</c-s> via its trait object member.
            </t-b>
            <t-b>
              That means that both <c-s>InputImpl</c-s> and <c-s>ComputeImpl</c-s> depend on <c-s>Compute</c-s>.
              Since <c-s>InputImpl</c-s> defines <c-s>Compute</c-s>,
              the Compute package now depends on the Input package - the opposite of the basic
              data flow structure.  Because of that, we say this design uses dependency inversion.
            </t-b>
            <t-b>
              Now, Input can be instantiated by Executive with <strong>any</strong> type that implements Comp.
              It does not depend on any of the downstream implementation details, and so can be reusable.
            </t-b>
            <t-b>
              Executive also creates trait objects for Output and Compute, using the concrete types OutputImpl and ComputeImpl.
              It is the only component that uses concrete types.  All the other components use trait objects and don&apos;t have 
              knowledge of, or dependencies on, concrete types.
            </t-b>
            <div style="height:0.75rem;"></div>
            <hr />
            <pros-cons>
              <div>
                <h4>Pros:</h4>
                <ol class="tight">
                  <li>Same as data flow</li>
                  <li>
                    The Input, Compute, and Output parts are now decoupled, each depending only on
                    the interfaces it defines and the interfaces of upstream components.
                  </li>
                </ol>
              </div>
              <div>
                <h4>Cons:</h4>
                <ol class="tight">
                  <li>
                    The building process becomes more complex.  Each component needs to use a factory
                    function to create its downstream component (to maintain type ignorance).
                  </li>
                </ol>
              </div>
              <div style="height:1.5rem;"></div>
            </pros-cons>
          </div>
        </div>
        <div style="height:0.5rem;"></div>
        <hr class="spread" />
        <a class="indent" href="https://github.com/JimFawcett/DesignStructure/tree/master/TypeEraseDataFlowStructure">TypeErase Code Repository</a>
        <div style="height:1.0rem;"></div>
        <div id="executive" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Executive</span>
          <span style="float:right; font-weight:bold">Output</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Executive::main.rs        //
//   - Executive creates and uses all lower level parts    //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    Executive creates trait objects for Output and Compute
    and wires them into a dataflow pipeline with InputImpl.
    None of the other components use concrete types. 
*/
// executive/src/main.rs
use compute::ComputeImpl;
use input::InputImpl;
use output::OutputImpl;

fn main() {
  println!(&quot;&#92;n-- Type-Erasure Pipeline via dyn --&#92;n&quot;);

  // Create trait objects and wire up the pipeline
  let output: Box&lt;dyn compute::Output&gt; = Box::new(OutputImpl::new());
  let compute: Box&lt;dyn input::Compute&gt; = Box::new(ComputeImpl::new(output));
  let mut input: InputImpl = InputImpl::new(compute);

  // Use it generically:
  let mut total = 0;
  for path in &[
    &quot;./src/main.rs&quot;,
    &quot;../Input/src/lib.rs&quot;,
    &quot;../Compute/src/lib.rs&quot;,
    &quot;../Output/src/lib.rs&quot;,
    &quot;../Fileutils/src/lib.rs&quot;
  ] {
    total += input.do_input(path);
    println!();
  }

  println!(&quot;total lines: {}&quot;, total);
  println!(&quot;&#92;nThat's all Folks!&#92;n&quot;);
}            </code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo run -q

-- Type‑Erasure Pipeline via dyn --

./src/main.rs => 41 lines

../Input/src/lib.rs => 116 lines

../Compute/src/lib.rs => 139 lines

../Output/src/lib.rs => 62 lines

../Fileutils/src/lib.rs => 86 lines

total lines: 444

That's all Folks!

</code></pre>
              <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
                Cargo.toml
              </div>
            <pre><code class="language-tern">[package]
name = "executive"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
input = { path = "../Input" }
compute = { path = "../Compute" }
output = { path = "../Output" }
            </code></pre>
            <div style="height: 0.5rem;"></div>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Executive code resides in the left panel. It creates and uses instances of the types 
                  OutputImpl, ComputeImpl, and InputImpl, all stored in heap memory.
                </li>
                <li>
                  The instances are wired into a dataflow pipeline: input to compute to output.
                </li>
                <li>
                  InputImpl provides function <c-s>fn do_input(&mut self, name: &str)</c-s>.
                  That attempts to open a named file and return its handle.
                </li>
                <li>
                  ComputeImple reads the file into a string and counts its lines. It then calls OutputImpl 
                  to display the name and lines.
                </li>
                <li>
                  Only Executive knows the concrete type names.  The other components simply use trait objects 
                  through their trait specified interface.
                </li>
              </ul>
            </div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="input" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Input Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Input::lib.rs             //
//   - Attempts to return line count from file             //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - Input owns and instantiates Compute.
    - It attempts to open file and pass to Compute for
      processing.
    - Returns line count if successful
*/
// input/src/lib.rs
use file_utils::open_file_for_read;
use std::fs::File;

/// Down-stream abstraction: Input only needs to know about &quot;Compute&quot; behavior.
pub trait Compute {
  fn do_compute(&mut self, name: &str, file: File);
  fn lines(&self) -&gt; usize;
}

/// The Input implementation only "owns" a Box&lt;dyn Compute&gt;.
pub struct InputImpl {
  name: String,
  compute: Box&lt;dyn Compute&gt;,
}

impl InputImpl {
  /// Caller wires in any Compute-impl with factory function new.
  pub fn new(compute: Box&lt;dyn Compute&gt;) -&gt; Self {
    InputImpl {
      name: String::new(),
      compute,
    }
  }

  /// Opens the file, hands it to compute, and returns the line count.
  pub fn do_input(&mut self, name: &str) -&gt; usize {
    self.name = name.to_string();
    if let Ok(file) = open_file_for_read(name) {
      self.compute.do_compute(name, file);
      self.compute.lines()
    } else {
      eprintln!(&quot;can't open {:?}&quot;, name);
      0
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*; // brings in Compute and InputImpl
  use std::cell::RefCell;
  use std::fs::File;
  use std::io::Write;
  use std::rc::Rc;
  use tempfile::NamedTempFile;

  /// A test-stub Compute that records the last name it was handed,
  /// and returns a preconfigured `desired` line count.
  struct TestCompute {
    last: Rc&lt;RefCell&lt;Option&lt;String&gt;&gt;&gt;,
    desired: usize,
  }

  impl Compute for TestCompute {
    fn do_compute(&mut self, name: &str, _file: File) {
      *self.last.borrow_mut() = Some(name.to_string());
    }
    fn lines(&self) -&gt; usize {
      self.desired
    }
  }

  #[test]
  fn missing_file_returns_zero_and_compute_not_called() {
    let last = Rc::new(RefCell::new(None));
    let stub = TestCompute {
      last: Rc::clone(&last),
      desired: 42,
    };
    let mut inp = InputImpl::new(Box::new(stub));

    let count = inp.do_input(&quot;definitely_not_a_file.rs&quot;);
    assert_eq!(count, 0, &quot;should return 0 for missing file&quot;);
    assert!(last.borrow().is_none(), &quot;compute should not be called&quot;);
  }

  #[test]
  fn existing_file_calls_compute_and_returns_desired() {
    let last = Rc::new(RefCell::new(None));
    let stub = TestCompute {
      last: Rc::clone(&last),
      desired: 7,
    };
    let mut inp = InputImpl::new(Box::new(stub));

    // create a real temp file so open succeeds
    let mut tmp = NamedTempFile::new().expect(&quot;create temp file&quot;);
    write!(tmp, &quot;ignored contents&quot;).expect(&quot;write temp file&quot;);
    tmp.flush().expect(&quot;flush temp file&quot;);
    let path = tmp.path().to_str().unwrap().to_string();

    let count = inp.do_input(&path);
    assert_eq!(count, 7, &quot;should return stub's desired count&quot;);

    // verify that compute.do_compute was called with the same path
    assert_eq!(
      last.borrow().as_ref(),
      Some(&path),
      &quot;compute should be called with the file name&quot;
    );
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-rust">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling fastrand v2.3.0
   Compiling once_cell v1.21.3
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.47s
     Running unittests src\lib.rs (target\debug\deps\input-f4e2ad4738f6bc68.exe)

running 2 tests
test tests::missing_file_returns_zero_and_compute_not_called ... ok
test tests::existing_file_calls_compute_and_returns_desired ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
  </code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "input"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
file_utils = { path = "../Fileutils" }

[dev-dependencies]
tempfile = "3"        // tempfile crate from crates.io
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Input library defines the trait Compute and type <c-s>InputImpl</c-s> containing one String data member, 
                  and a smart Box pointer to trait object Compute in the heap.
                </li>
                <li>
                  It defines a <c-s>fn new(compute: Box&lt;dyn Computer&gt;)</c-s> that returns an InputImpl holding a 
                  smart Box pointer to the trait object Compute.
                </li>
                <li>
                  It defines another method <c-s>fn do_input(&mut self, name:&str) -> Option&lt;File&gt;</c-s>
                </li>
                <li>
                  That attempts to open a named file for reading, and, if successful, calls <c-s>compute.do_compute(name, file)</c-s>.
                </li>
                <li>
                  The Input library depends on the library <c-s>file_utils</c-s>.
                </li>
                <li>
                  It also depends on a crate, tempfile from crates.io, supporting creation of temporary files that 
                  self destruct when no longer referenced.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="compute" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Comp Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Compute::lib.rs           //
//   - Attempts to read opened file to string, count lines //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - creates instance of Output
    - attempts to read file to string and count its lines
    - sends results to Output
*/
// compute/src/lib.rs
use file_utils::read_file_to_string;
use input::Compute;
use std::fs::File; // import the trait from input

/// Down-stream abstraction: Compute only needs to know about &quot;Output&quot;.
pub trait Output {
  fn do_output(&self, name: &str, lines: usize);
}

/// Concrete Compute implementation, type-erased over any Output.
pub struct ComputeImpl {
  lines: usize,
  out: Box&lt;dyn Output&gt;,
}

impl ComputeImpl {
  /// Caller wires in any Output-impl.
  pub fn new(out: Box&lt;dyn Output&gt;) -&gt; Self {
    ComputeImpl { lines: 0, out }
  }
}

impl Compute for ComputeImpl {
  fn do_compute(&mut self, name: &str, mut file: File) {
    match read_file_to_string(&mut file) {
      Ok(contents) =&gt; {
        // count lines in contents
        let mut count = if contents.is_empty() { 0 } else { 1 };
        count += contents.chars().filter(|&c| c == '&#92;n').count();
        self.lines = count;
        self.out.do_output(name, count);
      }
      Err(_) =&gt; eprintln!(&quot;could not read {:?}&quot;, name),
    }
  }

  fn lines(&self) -&gt; usize {
    self.lines
  }
}
#[cfg(test)]
mod tests {
  use super::*; // brings in ComputeImpl and Output
  use std::cell::RefCell;
  use std::fs::File;
  use std::io::Write;
  use std::rc::Rc;
  use tempfile::NamedTempFile;

  /// A test-output that records the last (name, lines) it was asked to print.
  struct TestOutput {
    record: Rc&lt;RefCell&lt;Option&lt;(String, usize)&gt;&gt;&gt;,
  }

  impl TestOutput {
    fn new(record: Rc&lt;RefCell&lt;Option&lt;(String, usize)&gt;&gt;&gt;) -&gt; Self {
      TestOutput { record }
    }
  }

  impl Output for TestOutput {
    fn do_output(&self, name: &str, lines: usize) {
      *self.record.borrow_mut() = Some((name.to_string(), lines));
    }
  }

  /// Helper: write `contents` into a temp file, then reopen so reading starts at 0.
  fn make_file(contents: &str) -&gt; File {
    let mut tmp = NamedTempFile::new().expect(&quot;create temp file&quot;);
    write!(tmp, &quot;{}&quot;, contents).expect(&quot;write temp file&quot;);
    tmp.flush().expect(&quot;flush temp file&quot;);
    tmp.reopen().expect(&quot;reopen temp file&quot;)
  }

  #[test]
  fn empty_file_emits_zero() {
    let record = Rc::new(RefCell::new(None));
    let out = TestOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(out));

    let file = make_file(&quot;&quot;);
    comp.do_compute(&quot;empty&quot;, file);

    assert_eq!(comp.lines(), 0);
    assert_eq!(*record.borrow(), Some((&quot;empty&quot;.to_string(), 0)));
  }

  #[test]
  fn single_line_emits_one() {
    let record = Rc::new(RefCell::new(None));
    let out = TestOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(out));

    let file = make_file(&quot;just one line&quot;);
    comp.do_compute(&quot;single&quot;, file);

    assert_eq!(comp.lines(), 1);
    assert_eq!(*record.borrow(), Some((&quot;single&quot;.to_string(), 1)));
  }

  #[test]
  fn multiple_lines_counted_correctly() {
    let record = Rc::new(RefCell::new(None));
    let out = TestOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(out));

    let file = make_file(&quot;a&#92;nb&#92;nc&quot;);
    comp.do_compute(&quot;multi&quot;, file);

    assert_eq!(comp.lines(), 3);
    assert_eq!(*record.borrow(), Some((&quot;multi&quot;.to_string(), 3)));
  }

  #[test]
  fn trailing_newline_adds_empty_line() {
    let record = Rc::new(RefCell::new(None));
    let out = TestOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(out));

    let file = make_file(&quot;x&#92;ny&#92;n&quot;);
    comp.do_compute(&quot;trail&quot;, file);

    assert_eq!(comp.lines(), 3);
    assert_eq!(*record.borrow(), Some((&quot;trail&quot;.to_string(), 3)));
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Compute)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Compute
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling fastrand v2.3.0
   Compiling once_cell v1.21.3
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Compute)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.60s
     Running unittests src\lib.rs (target\debug\deps\compute-076bb42754ebb50e.exe)

running 4 tests
test tests::empty_file_emits_zero ... ok
test tests::single_line_emits_one ... ok
test tests::trailing_newline_adds_empty_line ... ok
test tests::multiple_lines_counted_correctly ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
            </code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "compute"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
input = { path = "../Input" }
file_utils = { path = "../Fileutils" }

[dev-dependencies]
tempfile = "3"
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  The Comp library defines the type Compute with two data members, lines and out, 
                  a trait object for Compute, stored in the heap. 
                </li>
                <li>
                  It provides thre functions <c-s>fn new(out: Box&lt;dyn Output&gt;)</c-s>,  
                  <c-s>fn do_compute(&mut self, name: &str, mut file: File)</c-s>
                  and <c-s>fn lines(&self) -> usize</c-s>.
                </li>
                <li>
                  <c-s>do_compute</c-s> attempts to read contents of file handle file into a String.
                  If successful it counts its lines and stores in self.lines.
                </li>
                <li>
                  <c-s>lines</c-s> returns the value stored in self.lines.
                </li>
                <li>
                  Cargo.toml [dependencies] identifies crates the library depends on.
                </li>
                <li>
                  Cargo.toml [dev-dependencies] identifies crates library tests depend on.
                </li>
                <li>
                  This library defines unit tests for counting lines in a file, considering several
                  cases indicated with comments.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="output" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Output Library</span>
          <span style="float:right; font-weight:bold">Build</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// TypeErasureDataFlowStructure::Output::lib.rs            //
//   - Sends results to console                            //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////

// use std::fs::File;

// output/src/lib.rs
use compute::Output as ComputeOutput; // rename to avoid conflict

/// Concrete Output implementation.
#[derive(Debug)]
pub struct OutputImpl;

impl OutputImpl {
  pub fn new() -&gt; Self {
    OutputImpl
  }
  pub fn do_output(&self, name: &str, lines: usize) {
    println!(&quot;{} =&gt; {} lines&quot;, name, lines);
  }
}
impl Default for OutputImpl {
  fn default() -&gt; Self {
    Self::new()
  }
}

// Hook the Compute::Output trait from the compute crate to this impl:
impl ComputeOutput for OutputImpl {
  fn do_output(&self, name: &str, lines: usize) {
    self.do_output(name, lines)
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use compute::Output as ComputeOutput;

  #[test]
  fn new_creates_instance_and_debugs() {
    let out = OutputImpl::new();
    // Debug must print the struct name:
    assert_eq!(format!(&quot;{:?}&quot;, out), &quot;OutputImpl&quot;);
  }

  #[test]
  fn do_output_does_not_panic() {
    let out = OutputImpl::new();
    // Simply ensure calling do_output is safe
    out.do_output(&quot;some_file.rs&quot;, 7);
  }

  #[test]
  fn trait_object_dispatches_correctly() {
    // Box it as the compute::Output trait
    let out_obj: Box&lt;dyn ComputeOutput&gt; = Box::new(OutputImpl::new());
    // Must still work through the trait
    out_obj.do_output(&quot;foo.rs&quot;, 13);
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Input)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Compute)
   Compiling output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Output)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Output
> cargo test --lib
   Compiling output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Output)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src\lib.rs (target\debug\deps\output-e8639558e699949f.exe)

running 3 tests
test tests::do_output_does_not_panic ... ok
test tests::new_creates_instance_and_debugs ... ok
test tests::trait_object_dispatches_correctly ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "output"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
compute = { path = "../Compute" }
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Output library defines the type OutputImpl with no data members. 
                </li>
                <li>
                  It provides two functions <c-s>new()</c-s> and <c-s>fn do_output(&mut self, name: &str, lines: usize)</c-s>.
                </li>
                <li>
                  <c-s>do_output</c-s> displays a file name and its line count.
                </li>
                <li>
                  This library implements 3 simple unit tests.
                </li>
                <li>
                  Output depends only on Compute, as show in its Cargo.toml file.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="fileutils" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Fileutils Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// FactoredStructure::Input::file_utilities.rs             //
//   - Input attempts to open named file and return File   //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  This code may be useful for other programs so it is
  factored into this library.
*/
#![allow(dead_code)]

use std::fs::*;
use std::io::{Error, ErrorKind, Read, Write};

pub fn open_file_for_read(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let rfile = OpenOptions::new().read(true).open(file_name);
  rfile
}

pub fn read_file_to_string(f: &mut File) -&gt; Result&lt;String, std::io::Error&gt; {
  let mut contents = String::new();
  let bytes_rslt = f.read_to_string(&mut contents);
  if bytes_rslt.is_ok() {
    Ok(contents)
  } else {
    Err(Error::new(ErrorKind::Other, &quot;read error&quot;))
  }
}

pub fn open_file_for_write(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let wfile = OpenOptions::new()
    .write(true)
    .create(true)
    .truncate(true)
    .open(file_name);
  wfile
}

pub fn write_string_to_file_handle(s: &str, mut f: std::fs::File) -&gt; std::io::Result&lt;()&gt; {
  f.write_all(s.as_bytes())?;
  f.flush()?;
  Ok(())
}

pub fn write_string_to_file(s: &str, file_name: &str) -&gt; std::io::Result&lt;()&gt; {
  std::fs::write(file_name, s)?;
  Ok(())
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn file_name_write_read() {
    let file_name = &quot;temp.txt&quot;;
    let test_string = &quot;test string&quot;;

    // Write using the filename
    open_file_for_write(file_name).expect(&quot;open for write failed&quot;);
    write_string_to_file(test_string, file_name).expect(&quot;write string failed&quot;);

    // Read back
    let mut rfile = open_file_for_read(file_name).expect(&quot;open for read failed&quot;);
    let r_string = read_file_to_string(&mut rfile).expect(&quot;read to string failed&quot;);

    assert_eq!(r_string, test_string);
  }

  #[test]
  fn file_handle_write_read() {
    let file_name = &quot;temp.txt&quot;;
    let test_string = &quot;test string&quot;;

    // Open for writing and write using handle
    let wfile = open_file_for_write(file_name).expect(&quot;open for write failed&quot;);
    write_string_to_file_handle(test_string, wfile).expect(&quot;write string failed&quot;);

    // Read back
    let mut rfile = open_file_for_read(file_name).expect(&quot;open for read failed&quot;);
    let r_string = read_file_to_string(&mut rfile).expect(&quot;read to string failed&quot;);

    assert_eq!(r_string, test_string);
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.34s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils
> cargo test --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running unittests src\lib.rs (target\debug\deps\file_utils-c70071d2546d9160.exe)

running 2 tests
test tests::file_handle_write_read ... ok
test tests::file_name_write_read ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "file_utils"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Fileutils library has no dependencies other than the Rust standard libraries, 
                  as shown in the Cargo.toml above.
                </li>
                <li>
                  It does not define any new types, but does define several functions:
                  <ol>
                    <li>
                      <c-s>fn open_file_for_read(file_name: &str) -> Result&lt;File: std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a handle to its String contents. 
                      The return type is <c-s>Result&lt;File, std::io::Error&gt;</c-s>
                    </li>
                    <li>
                      <c-s>fn read_file_to_string(f: &mut File) -> Result&lt;String, std::io::Error&gt;</c-s><br>
                      Attempts to read contents referred to by file handle and return the string of contents 
                      wrapped in Ok(contents).
                    </li>
                    <li>
                      <c-s>fn open_file_for_write(file_name: &str) -> Result&lt;File, std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a File handle to the opened named file. 
                    </li>
                    <li>
                      <c-s>fn write_string_to_file_handle(s: &str, mut f: std::fs:::File) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to by the File handle and flush the handle.
                    </li>
                    <li>
                      <c-s>fn write_string_to_file(s: &str, file_name: &str) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to named file.
                    </li>
                  </ol> 
                </li>
                <li>
                  The Build and Test view above shows successful build and execution 
                  of two unit test functions.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.00rem;"></div>
        <div style="height:0.5rem;"></div>
        <a id="epilogue"></a>
        <div style="height:0.75rem;"></div>
        <h3>3. Epilogue</h3>
        <div class="indent">
          <t-b>
            The fourh design alternatives considered here:
            <ol class="tight">
              <li><a href="DesignBites_StructureBasic.html">Monolithic Structure</a></li>
              <li><a href="DesignBites_StructureFactored.html">Factored Structure</a></li>
              <li><a href="DesignBites_StructureDataFlow.html">DataFlow Structure</a></li>
              <li><a href="DesignBites_StructureTypeErase.html">TypeErase Structure</a></li>
              <li><a href="DesignBites_StructurePlugIn.html">PlugIn Structure</a></li>
            </ol>
            are progressively more flexible, eventually resulting in reusable components, but also increasingly
            complex.  Where you settle in these alternatives is determined by design context.  Is this a
            one-of-a-kind project that you want to finish quickly or is it
            heading for production code that will be maintained by more than one developer?
          </t-b>
        </div>
      </content>
    <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#structure">structure</a>
        <a href="#executive">executive</a>
        <a href="#input">input</a>
        <a href="#compute">compute</a>
        <a href="#output">output</a>
        <a href="#epilogue">epilogue</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/DesignBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 5, 10);
  </script>
</body>
</html>
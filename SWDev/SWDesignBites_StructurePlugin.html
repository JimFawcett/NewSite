<!DOCTYPE html>
<html id="top">
<!--
  SWDesignBites_StructurePlugin.html
-->
<head>
  <title>Plugin Structure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeSWDev.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/SplitterComponent.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="../js/SitePagesForTools.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css">
  <script src="../js/prism.js"></script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreSWDev.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    #github #statustable {
      table-layout: fixed;
      width: calc(100% - 0rem);
    }
    #github td {
      vertical-align: top;
      line-height: 1rem;
    }
  </style>
  <!-- <style>
    #github #url {
      user-select: all; 
      position:fixed; 
      bottom:0.5rem; 
      right:3rem; 
      z-index: 100; 
      padding:0.5rem 1rem; 
      width:max-content; 
      height:2.5rem; 
      border:1px solid var(--dark);
      background-color: var(--light);
    }
  </style> -->
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="CppRepos.html"></a>
  <a id="prev" class="hidden" href="CppRepos.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    SWDesignBites_StructurePlugin.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 07/14/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">SW Design Bites: Plugin Structure</h2>
        <h4 id="subtitle" class="indent">
          
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="SWDevHome.html" style="color:var(--atten); margin-left:1rem;">SWDev Track</a>
      </div>

      <!--<div style="padding-right:25px; position:absolute; top:1.1em; right:13em; z-index:5;">-->
    </header>
    <div style="height:0.75rem;"></div>
        <t-b class="indent">
          &quot;I am always doing that which I can not do, in order that I may learn how to do it.&quot;<br />
          - Pablo Picasso
        </t-b>
        <hr style="margin:1em 0em 1.5em 0em;" />
        <a id="intro"></a>
        <h3>1.0 Introduction</h3>
        <div class="indent">
          <t-b>
            This DesignBite sequence was inspired by BuildOn project <a href="../BuildOn/Step0.html">TextFinder</a>.
            As that project is designed and implemented, a number of design decisions are made, consciously or unconsciously.
            Each of these pages addresses one answer to questions about fundamental decisions of structure.
          </t-b>
          <t-b>
            To make discussion pragmatic and concrete, we implement a program that evaluates the number of lines
            in text files.  Processing is quite simple so it allows us to see how each
            structure alternative is implemented.
          </t-b>
          <t-b>
            We consider both package structure and logical structure, e.g., functions and structs used to order
            design and implementation.  In this PlugIn Structure page, code is implemented in a set of packages
            Executive, Input, Compute, and Output and their
            structs.  That provides all of the organization for processing.
          </t-b>
        </div>
        <a id="structure"></a>
        <div style="height:0.25rem;"></div>
        <h3>2. Application Structure - PlugIn</h3>
        <div class="indent">
          <t-b>
            This structure is modular with a data flow structure.  It differs from the previous TypeErase structure
            in that:
            <ul class="tight">
              <li>
                Its ComputeImpl type is not parameterized.
              </li>
              <li>
                That allows the Output type to be determined at run-time, affording application flexability
                in the way it displays output, based on user input.
              </li>
              <li>
                It also means that Executive instantiates the Output type and delivers that to ComputeImpl.
              </li>
              <li>
                The Rust data model requires that to be a trait object created on the heap (wrapped in a Box).
              </li>
            </ul>
          </t-b>
        </div>
        <div id="fig1" style="width:calc(100vw - 4rem);">
          <div style="display:flex; float:right; padding:1rem;">
            <photosizer-block src="pictures/Design6a.png" width="400" class="photoSizerBlock" style="margin-top:0; float: right;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS', Tahoma;
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 5. Plugin Structure
              </span>
            </photosizer-block>
          </div>
            <div style="border:1px solid var(--dark); padding: 0rem 1.0em;">
            <h4>PlugIn Structure</h4>
            <t-b>
              The PlugIn structure is very similar to Type Erasure, but with the flexibility to define output processing
              at run-time.  The <c-s>Executive</c-s> creates an <c-s>OutputImpl</c-s> type at run-time and configures
              <c-s>ComputeImpl</c-s> with that type.
            </t-b>
            <t-b>
              That can be any type that implements the <c-s>Output</c-s> trait.  We get that freedom by not
              parameterizing <c-s>ComputeImpl</c-s> on <c-s>OutputImpl</c-s>, as we did in Type Erasure.
              Now, <c-s>ComputeImpl</c-s> cannot
              create an instance of the <c-s>OutputImpl</c-s> type because it only has the <c-s>Output</c-s> trait
              definition, but no paramaterized type to get an instance using a factory function.
            </t-b>
            <t-b>
              This gives the application freedom to choose the type of output processing based on a command line input.
              PlugIn has most of the characteristics of the Type Erasure structure, with the addition of freedom of
              choice for output processing.
            </t-b>
            <t-b>
              Implementation gets a bit more complicated because <c-s>Executive</c-s> has to create an instance of
              the desired type and give it to <c-s>ComputeImpl</c-s>.  
            </t-b>
            <hr />
            <pros-cons>
              <div>
                <h4>Pros:</h4>
                <ol class="tight">
                  <li>Same as data flow</li>
                  <li>
                    The Input, Compute, and Output parts are now decoupled, each depending only on
                    the interfaces it defines and the interfaces of upstream components.
                  </li>
                  <li>
                    Freedom to define <c-s>Output</c-s> processing at run-time through a polymorphic run-time
                    dispatch.
                  </li>
                </ol>
              </div>
              <div>
                <h4>Cons:</h4>
                <ol class="tight">
                  <li>
                    The building process becomes more complex.  Each component needs to use a factory
                    function to create its downstream component (to maintain type ignorance).
                  </li>
                  <li>
                    Again, more complex because <c-s>Executive</c-s> needs access to <c-s>Compute</c-s> to configure
                    it with <c-s>Output</c-s>.
                  </li>
                </ol>
              </div>
              <div style="height:1.5rem;"></div>
            </pros-cons>
          </div>
        </div>
          <!-- </div> -->
        </div>
        <div style="height:0.5rem;"></div>
        <div id="pnotes" style="height:0.75rem;"></div>
        <div style="padding:0.5rem 1.0rem; border:1px solid var(--dark);">
          <strong>Project Notes:</strong>
          <t-b style="margin-left:1.0rem; margin-top:0.5rem;">
            Plugin structures use trait objects:
            <ul class="tight">
              <li>
                A trait object is an instance of a concrete type stored in the heap using a statement like this:
                <inset>
                  <c-s>let comp : Box&lt;dyn CompTrait&gt; = Box::new(ConcreteType::new());</c-s>
                </inset> 
                where <c-s>ConcreteType</c-s> is required to imlement <c-s>CompTrait</c-s>.
              </li>
              <li>
                Two important things happen here:
                <ol class="tight" style="font-size:0.95rem;">
                  <li>
                    The type used on the right hand side can be chosen at run-time. You will see an 
                    example of that in the Executive, below. All of the other structure types discussed 
                    previously use types that must be defined at compile-time. 
                  </li>
                  <li>
                    The instance on the left, <c-s>comp</c-s>, has knowledge of only the <c-s>CompTrait</c-s>, 
                    not the <c-s>ConcreteType</c-s>.
                  </li>
                </ol>
              </li>
            </ul>
          </t-b>
          <t-b style="margin-left:1.0rem;">
            Plugins support choosing a component at run-time. In this example, we will select, using command line 
            arguments, the output component type. One writes line counts to the user&apos;s console, the other 
            writes to a file.
          </t-b>
          <t-b style="margin-left:0.0rem; margin-top:0.5rem;">
            <strong style="margin-bottom: 0rem;">Citations:</strong>
            <t-b style="margin-left:1.0rem; margin-bottom:0rem; margin-top:0.5rem;">
              ChatGPT 4o was used to:
              <ul class="tight">
                <li>
                  help establish dataflow wiring between components and corresponding 
                  complex trait object syntax.
                </li>
                <li>
                  write all of the unit tests for each of the libraries in this project. 
                </li>
              </ul>
            </t-b>
          </t-b>
          <div style="height:0.5rem;"></div>
        </div>
        <div style="height:1.5rem;"></div>
        <div id="executive" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Executive</span>
          <span style="float:right; font-weight:bold">Output</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// PluginWithTraitObjects::Executive::main.rs              //
//   - Executive creates and uses all lower level parts    //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    Executive creates Input Comp and Output instances. 

    cargo run -- console
      or
    cargo run -- file &lt;file name&gt;, e.g., file count.txt

    The file name must not be an existing source code file
*/
use compute::ComputeImpl;
use compute::Output as ComputeOutput;
use input::InputImpl;
use std::env;

fn main() {
  // Choose plugin via CLI: e.g. `--output=file out.txt` or `--output=console`
  //---------------------------------------------------------------------------
  let mut args = env::args().skip(1);
  let plugin = args.next().unwrap_or_else(|| &quot;console&quot;.into());

  // plugin = &quot;console&quot;.to_string();

  // Instantiate the right boxed Output
  //---------------------------------------------------------------------------
  let out: Box&lt;dyn ComputeOutput&gt; = match plugin.as_str() {
    &quot;console&quot; =&gt; Box::new(console_output::ConsoleOutput::new()),
    &quot;file&quot; =&gt; {
      let path = args
        .next()
        .expect(&quot;usage: executive --output=file &lt;out-path&gt; &lt;files&gt;...&quot;);
      Box::new(file_output::FileOutput::new(&path).expect(&quot;failed to create FileOutput&quot;))
    }
    other =&gt; {
      eprintln!(&quot;unknown output plugin "{}"&quot;, other);
      std::process::exit(1);
    }
  };

  // Wire Compute and Input
  //---------------------------------------------------------------------------
  let compute = Box::new(ComputeImpl::new(out));
  let mut input = InputImpl::new(compute);

  let mut total = 0;
  for path in &[
    &quot;./src/main.rs&quot;,
    &quot;../Input/src/lib.rs&quot;,
    &quot;../Compute/src/lib.rs&quot;,
    &quot;../ConsoleOutput/src/lib.rs&quot;,
    &quot;../FileOutput/src/lib.rs&quot;,
    &quot;../Fileutils/src/lib.rs&quot;,
  ] {
    total += input.do_input(path);
  }
  println!(&quot;&#92;ntotal lines: {:?}&#92;n&quot;, total);
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo run -q console

./src/main.rs: 67 lines

../Input/src/lib.rs: 51 lines

../Compute/src/lib.rs: 62 lines

../ConsoleOutput/src/lib.rs: 36 lines

../FileOutput/src/lib.rs: 35 lines

../Fileutils/src/lib.rs: 86 lines

total lines: 337

------------------------------------------------------

C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Executive
> cargo run -q file count.txt

total lines: 337

------------------------------------------------------
count.txt
------------------------------------------------------
./src/main.rs -> 67 lines
../Input/src/lib.rs -> 51 lines
../Compute/src/lib.rs -> 62 lines
../ConsoleOutput/src/lib.rs -> 36 lines
../FileOutput/src/lib.rs -> 35 lines
../Fileutils/src/lib.rs -> 86 lines
</code></pre>
              <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
                Cargo.toml
              </div>
            <pre><code class="language-tern">[package]
name = "executive"
version = "0.1.0"
edition = "2021"

[dependencies]
input           = { path = "../Input" }
compute         = { path = "../Compute" }
console_output  = { path = "../ConsoleOutput" }
file_output     = { path = "../FileOutput" }
</code></pre>
            <div style="height: 0.5rem;"></div>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Executive code resides in the left panel. It creates and uses instances of the types 
                  OutputImpl, ComputeImpl, and InputImpl, all stored in heap memory.
                </li>
                <li>
                  The instances are wired into a dataflow pipeline: input to compute to output.
                </li>
                <li>
                  InputImpl provides function <c-s>fn do_input(&mut self, name: &str)</c-s>.
                  That attempts to open a named file and return its handle.
                </li>
                <li>
                  ComputeImple reads the file into a string and counts its lines. It then calls OutputImpl 
                  to display the name and lines.
                </li>
                <li>
                  Only Executive knows the concrete type names.  The other components simply use trait objects 
                  through their trait specified interface.
                </li>
              </ul>
            </div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="input" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Input Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// PlugInWithTraitObjects::Input::lib.rs                   //
//   - Attempts to return line count from file             //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - Input owns and instantiates Compute.
    - It attempts to open file and pass to Compute for
      processing.
    - Returns line count if successful
*/
use file_utils::open_file_for_read;
use std::fs::File;

/// The trait for anything that can count lines.
pub trait Compute {
  fn do_compute(&mut self, name: &str, file: File);
  fn lines(&self) -&gt; usize;
}

/// Your InputImpl just needs a boxed Compute.
pub struct InputImpl {
  compute: Box&lt;dyn Compute&gt;,
}

impl InputImpl {
  /// `compute` is any implementor of the Compute trait.
  pub fn new(compute: Box&lt;dyn Compute&gt;) -&gt; Self {
    InputImpl { compute }
  }

  /// Opens `name`, hands it to compute, returns the line count.
  pub fn do_input(&mut self, name: &str) -&gt; usize {
    if let Ok(f) = open_file_for_read(name) {
      self.compute.do_compute(name, f);
      self.compute.lines()
    } else {
      eprintln!(&quot;could not open {:?}&quot;, name);
      0
    }
  }
}
#[cfg(test)]
mod tests {
  use super::*;
  use std::cell::RefCell;
  use std::io::Write;
  use std::rc::Rc;
  use tempfile::NamedTempFile;

  /// Stub Compute that records the last filename it saw
  /// and returns a fixed line count.
  struct StubCompute {
    last_name: Rc&lt;RefCell&lt;Option&lt;String&gt;&gt;&gt;,
    return_lines: usize,
  }

  impl StubCompute {
    fn new(record: Rc&lt;RefCell&lt;Option&lt;String&gt;&gt;&gt;, return_lines: usize) -&gt; Self {
      StubCompute {
        last_name: record,
        return_lines,
      }
    }
  }

  impl Compute for StubCompute {
    fn do_compute(&mut self, name: &str, _file: File) {
      *self.last_name.borrow_mut() = Some(name.to_string());
    }
    fn lines(&self) -&gt; usize {
      self.return_lines
    }
  }

  #[test]
  fn missing_file_returns_zero_and_skips_compute() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubCompute::new(Rc::clone(&record), 99);
    let mut inp = InputImpl::new(Box::new(stub));

    let count = inp.do_input(&quot;definitely_not_a_file.txt&quot;);
    assert_eq!(count, 0, &quot;should return 0 for missing file&quot;);
    assert!(record.borrow().is_none(), &quot;do_compute should not be called&quot;);
  }

  #[test]
  fn existing_file_calls_compute_and_returns_stub_value() {
    // prepare a real file so open_file_for_read succeeds
    let mut tmp = NamedTempFile::new().expect(&quot;create temp file&quot;);
    write!(tmp, &quot;ignored&quot;).expect(&quot;write to temp file&quot;);
    tmp.flush().expect(&quot;flush temp file&quot;);
    let path = tmp.path().to_str().unwrap().to_string();

    let record = Rc::new(RefCell::new(None));
    let stub = StubCompute::new(Rc::clone(&record), 7);
    let mut inp = InputImpl::new(Box::new(stub));

    let count = inp.do_input(&path);
    assert_eq!(count, 7, &quot;should return the stub's line count&quot;);
    assert_eq!(
      record.borrow().as_ref(),
      Some(&path),
      &quot;do_compute should be called with the file name&quot;
    );
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-rust">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Input)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.35s
C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Input
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling once_cell v1.21.3
   Compiling fastrand v2.3.0
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Input)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.36s
     Running unittests src\lib.rs (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\target\debug\deps\input-3f3680d8940bbc10.exe)

running 2 tests
test tests::missing_file_returns_zero_and_skips_compute ... ok
test tests::existing_file_calls_compute_and_returns_stub_value ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "input"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
file_utils = { path = "../Fileutils" }

[dev-dependencies]
tempfile = "3"        # tempfile crate from crates.io
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Input library defines the trait Compute and type <c-s>InputImpl</c-s> containing one String data member, 
                  and a smart Box pointer to trait object Compute in the heap.
                </li>
                <li>
                  It defines a <c-s>fn new(compute: Box&lt;dyn Computer&gt;)</c-s> that returns an InputImpl holding a 
                  smart Box pointer to the trait object Compute.
                </li>
                <li>
                  It defines another method <c-s>fn do_input(&mut self, name:&str) -> Option&lt;File&gt;</c-s>
                </li>
                <li>
                  That attempts to open a named file for reading, and, if successful, calls <c-s>compute.do_compute(name, file)</c-s>.
                </li>
                <li>
                  The Input library depends on the library <c-s>file_utils</c-s>.
                </li>
                <li>
                  It also depends on a crate, tempfile from crates.io, supporting creation of temporary files that 
                  self destruct when no longer referenced.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="compute" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Comp Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// PlugInWithTraitObjects::Compute::lib.rs                 //
//   - Attempts to read opened file to string, count lines //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  Note:
    - creates instance of Output
    - attempts to read file to string and count its lines
    - sends results to Output
*/
use file_utils::read_file_to_string;
use input::Compute;
use std::fs::File;
// use output::console_output as OutputTrait;  // downstream abstraction from output crate

/// The trait you expect from any Output plugin.
pub trait Output {
  fn do_output(&self, name: &str, lines: usize);
}

/// Your ComputeImpl just holds a boxed Output.
pub struct ComputeImpl {
  lines: usize,
  out: Box&lt;dyn Output&gt;,
}

impl ComputeImpl {
  /// `out` is any implementor of OutputTrait.
  pub fn new(out: Box&lt;dyn Output&gt;) -&gt; Self {
    ComputeImpl { lines: 0, out }
  }
}

impl Compute for ComputeImpl {
  fn do_compute(&mut self, name: &str, mut file: File) {
    match read_file_to_string(&mut file) {
      Ok(contents) =&gt; {
        // count lines
        let mut count = if contents.is_empty() { 0 } else { 1 };
        count += contents.chars().filter(|&c| c == '&#92;n').count();
        self.lines = count;
        self.out.do_output(name, count);
      }
      Err(e) =&gt; eprintln!(&quot;&#92;ncompute failed to read {:?}: {}&#92;n&quot;, name, e),
    }
  }
  fn lines(&self) -&gt; usize {
    self.lines
  }
}

// Re-export Compute trait under its old name if you wish:
pub use input::Compute as ComputeTrait;

#[cfg(test)]
mod tests {
  use super::*; // brings in ComputeImpl, Output, Compute
  use std::cell::RefCell;
  use std::fs::File;
  use std::io::Write;
  use std::rc::Rc;
  use tempfile::NamedTempFile;

  /// A stub Output that records the last (name, lines) it was asked to output.
  struct StubOutput {
    record: Rc&lt;RefCell&lt;Option&lt;(String, usize)&gt;&gt;&gt;,
  }

  impl StubOutput {
    fn new(record: Rc&lt;RefCell&lt;Option&lt;(String, usize)&gt;&gt;&gt;) -&gt; Self {
      StubOutput { record }
    }
  }

  impl Output for StubOutput {
    fn do_output(&self, name: &str, lines: usize) {
      *self.record.borrow_mut() = Some((name.to_string(), lines));
    }
  }

  /// Write `contents` to a temp file and reopen it for reading from the start.
  fn make_file(contents: &str) -&gt; File {
    let mut tmp = NamedTempFile::new().expect(&quot;create temp file&quot;);
    write!(tmp, &quot;{}&quot;, contents).expect(&quot;write temp file&quot;);
    tmp.flush().expect(&quot;flush temp file&quot;);
    tmp.reopen().expect(&quot;reopen temp file&quot;)
  }

  #[test]
  fn empty_file_emits_zero_and_reports_zero() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(stub));

    let file = make_file(&quot;&quot;);
    comp.do_compute(&quot;empty.txt&quot;, file);

    assert_eq!(comp.lines(), 0);
    assert_eq!(*record.borrow(), Some((&quot;empty.txt&quot;.to_string(), 0)));
  }

  #[test]
  fn single_line_emits_one_and_reports_one() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(stub));

    let file = make_file(&quot;just one line&quot;);
    comp.do_compute(&quot;single.txt&quot;, file);

    assert_eq!(comp.lines(), 1);
    assert_eq!(*record.borrow(), Some((&quot;single.txt&quot;.to_string(), 1)));
  }

  #[test]
  fn multiple_lines_counted_correctly() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(stub));

    let file = make_file(&quot;a&#92;nb&#92;nc&quot;);
    comp.do_compute(&quot;multi.txt&quot;, file);

    assert_eq!(comp.lines(), 3);
    assert_eq!(*record.borrow(), Some((&quot;multi.txt&quot;.to_string(), 3)));
  }

  #[test]
  fn trailing_newline_counts_empty_line() {
    let record = Rc::new(RefCell::new(None));
    let stub = StubOutput::new(Rc::clone(&record));
    let mut comp = ComputeImpl::new(Box::new(stub));

    let file = make_file(&quot;x&#92;ny&#92;n&quot;);
    comp.do_compute(&quot;trail.txt&quot;, file);

    assert_eq!(comp.lines(), 3);
    assert_eq!(*record.borrow(), Some((&quot;trail.txt&quot;.to_string(), 3)));
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Input)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Compute)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.49s
C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Compute
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling fastrand v2.3.0
   Compiling once_cell v1.21.3
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Compute)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.58s
     Running unittests src\lib.rs (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\target\debug\deps\compute-061f996749009d21.exe)

running 4 tests
test tests::empty_file_emits_zero_and_reports_zero ... ok
test tests::trailing_newline_counts_empty_line ... ok
test tests::multiple_lines_counted_correctly ... ok
test tests::single_line_emits_one_and_reports_one ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "compute"
version = "0.1.0"
edition = "2021"

[dependencies]
# console_output = { path = "../ConsoleOutput" }
file_utils = { path = "../Fileutils" }
input = { path = "../Input" }

[dev-dependencies]
tempfile = "3"
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  The Comp library defines the type ComputeImpl with two data members, lines and out, 
                  a generic parameter that is required to implement the Output trait, as specified by 
                  <c-s>ComputeImpl&lt;Out: Output&gt;</c-s>. 
                </li>
                <li>
                  It provides thre functions <c-s>fn new()</c-s>,  
                  <c-s>fn do_compute(&mut self, name: &str, mut file: File)</c-s>
                  and <c-s>fn lines(&self) -> usize</c-s>.
                </li>
                <li>
                  <c-s>do_compute</c-s> attempts to read contents of file handle file into a String.
                  If successful it counts its lines and stores in self.lines.
                </li>
                <li>
                  <c-s>lines</c-s> returns the value stored in self.lines.
                </li>
                <li>
                  Cargo.toml [dependencies] identifies crates the library depends on.
                </li>
                <li>
                  Cargo.toml [dev-dependencies] identifies crates library tests depend on.
                </li>
                <li>
                  This library defines unit tests for counting lines in a file, considering several
                  cases indicated with function name and comments.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="consoleoutput" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Console Output Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// PlugInWithTraitObjects::ConsoleOutput::lib.rs           //
//   - Sends results to console                            //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////

use compute::Output as ComputeOutput;

/// A trivial console printer
pub struct ConsoleOutput;

impl ConsoleOutput {
  pub fn new() -&gt; Self {
    ConsoleOutput
  }
}

impl Default for ConsoleOutput {
  fn default() -&gt; ConsoleOutput {
    Self::new()
  }
}

impl ComputeOutput for ConsoleOutput {
  fn do_output(&self, name: &str, lines: usize) {
    println!(&quot;&#92;n{}: {} lines&quot;, name, lines);
  }
}
#[cfg(test)]
mod tests {
  use super::*;
  use compute::Output as ComputeOutput;
  use std::any::{Any, TypeId};

  /// new() and default() both produce the same ConsoleOutput type.
  #[test]
  fn new_and_default_same_type() {
    let a = ConsoleOutput::new();
    let b: ConsoleOutput = ConsoleOutput::default();

    // `type_id()` comes from the Any trait, so import it.
    assert_eq!(TypeId::of::&lt;ConsoleOutput&gt;(), a.type_id());
    assert_eq!(TypeId::of::&lt;ConsoleOutput&gt;(), b.type_id());
  }

  /// do_output() returns the unit value and never panics.
  #[test]
  fn do_output_returns_unit() {
    let out = ConsoleOutput::new();
    let ret = out.do_output(&quot;example.rs&quot;, 7);
    assert_eq!(ret, ());
  }

  /// It still works via a Box&lt;dyn ComputeOutput&gt; trait object.
  #[test]
  fn trait_object_dispatches() {
    let obj: Box&lt;dyn ComputeOutput&gt; = Box::new(ConsoleOutput::new());
    let ret = obj.do_output(&quot;foo.rs&quot;, 13);
    assert_eq!(ret, ());
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Input)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Compute)
   Compiling console_output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\ConsoleOutput)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\ConsoleOutput
> cargo test --lib
   Compiling console_output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\ConsoleOutput)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running unittests src\lib.rs (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\target\debug\deps\console_output-3f714d74054ccfe7.exe)

running 3 tests
test tests::do_output_returns_unit ... ok
test tests::new_and_default_same_type ... ok
test tests::trait_object_dispatches ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "console_output"
version = "0.1.0"
edition = "2021"

[dependencies]
compute = { path = "../Compute" }
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  ConsoleOutput library defines the type ConsoleOutput with no data members. 
                </li>
                <li>
                  It provides two functions <c-s>new()</c-s> and <c-s>fn do_output(&self, name: &str, lines: usize)</c-s>.
                </li>
                <li>
                  <c-s>do_output</c-s> displays a file name and its line count.
                </li>
                <li>
                  This library implements 3 unit tests.
                </li>
                <li>
                  Output depends only on Compute, to implement the Output trait, as show in its Cargo.toml file.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="fileoutput" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">File Output Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// PlugInWithTraitObjects::FileOutput::lib.rs              //
//   - Sends results to console                            //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////

use compute::Output as ComputeOutput;
use std::fs::File;
use std::io::Write;

/// Writes each output line into a file.
pub struct FileOutput {
  file: File,
}

impl FileOutput {
  pub fn new(path: &str) -&gt; std::io::Result&lt;Self&gt; {
    let f = File::create(path)?;
    Ok(FileOutput { file: f })
  }
}

impl ComputeOutput for FileOutput {
  fn do_output(&self, name: &str, lines: usize) {
    writeln!(&self.file, &quot;{} -&gt; {} lines&quot;, name, lines).expect(&quot;failed to write to output file&quot;);
  }
}
#[cfg(test)]
mod tests {
    use super::*;
    use compute::Output as ComputeOutput;
    use tempfile::NamedTempFile;
    use std::fs;
    use std::io::Read;

    /// Helper to read the entire contents of a file into a String.
    fn read_file_to_string(path: &str) -&gt; String {
        let mut s = String::new();
        let mut f = fs::File::open(path).expect(&quot;failed to open output file for reading&quot;);
        f.read_to_string(&mut s).expect(&quot;failed to read output file&quot;);
        s
    }

    #[test]
    fn new_creates_file_and_do_output_writes_expected_line() {
        // Create a temporary file and get its path
        let tmp = NamedTempFile::new().expect(&quot;failed to create temp file&quot;);
        let path = tmp.path().to_str().unwrap();

        // Instantiate FileOutput on that path
        let fo = FileOutput::new(path).expect(&quot;FileOutput::new failed&quot;);

        // Write a test line
        fo.do_output(&quot;test.rs&quot;, 7);

        // Read back the file contents
        let contents = read_file_to_string(path);

        // Expect exactly one line in the format: &quot;name -&gt; lines&#92;n&quot;
        assert_eq!(contents, &quot;test.rs -&gt; 7 lines&#92;n&quot;);
    }

    #[test]
    fn multiple_do_output_appends_lines() {
        let tmp = NamedTempFile::new().expect(&quot;failed to create temp file&quot;);
        let path = tmp.path().to_str().unwrap();

        let fo = FileOutput::new(path).expect(&quot;FileOutput::new failed&quot;);

        fo.do_output(&quot;a.rs&quot;, 1);
        fo.do_output(&quot;b.rs&quot;, 2);
        fo.do_output(&quot;c.rs&quot;, 3);

        let contents = read_file_to_string(path);
        let expected = &quot;&#92;
a.rs -&gt; 1 lines
b.rs -&gt; 2 lines
c.rs -&gt; 3 lines
&quot;;
        assert_eq!(contents, expected);
    }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Fileutils)
   Compiling input v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Input)
   Compiling compute v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\Compute)
   Compiling file_output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\FileOutput)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.51s
C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\FileOutput
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling fastrand v2.3.0
   Compiling once_cell v1.21.3
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling file_output v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\FileOutput)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.29s
     Running unittests src\lib.rs (C:\github\JimFawcett\NewSite\Code\DesignStructure\PlugInWithTraitObjects\target\debug\deps\file_output-c072502cc8920022.exe)

running 2 tests
test tests::new_creates_file_and_do_output_writes_expected_line ... ok
test tests::multiple_do_output_appends_lines ... ok        

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "file_output"
version = "0.1.0"
edition = "2021"

[dependencies]
compute = { path = "../Compute" }

[dev-dependencies]
tempfile = "3"
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  ConsoleOutput library defines the type ConsoleOutput with no data members. 
                </li>
                <li>
                  It provides two functions <c-s>new()</c-s> and <c-s>fn do_output(&self, name: &str, lines: usize)</c-s>.
                </li>
                <li>
                  <c-s>do_output</c-s> displays a file name and its line count.
                </li>
                <li>
                  This library implements 3 unit tests.
                </li>
                <li>
                  Output depends only on Compute, to implement the Output trait, as show in its Cargo.toml file.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.0rem;"></div>
        <div id="fileutils" style="padding:0rem 1.5rem;">
          <span style="float:left; font-weight:bold">Fileutils Library</span>
          <span style="float:right; font-weight:bold">Build and Test</span>
        </div>
        <splitter-container style="width:100%">
          <div slot="first" style="padding-left:0.3rem;">
            <pre><code class="language-rust">/////////////////////////////////////////////////////////////
// FactoredStructure::Fileutils::file_utilities.rs         //
//   - Input attempts to open named file and return File   //
// Jim Fawcett, https://JimFawcett.github.io, 04 Mar 2021  //
/////////////////////////////////////////////////////////////
/*
  This code may be useful for other programs so it is
  factored into a module here.
*/
#![allow(dead_code)]

use std::fs::*;
use std::io::{Error, ErrorKind, Read, Write};

pub fn open_file_for_read(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let rfile = OpenOptions::new().read(true).open(file_name);
  rfile
}

pub fn read_file_to_string(f: &mut File) -&gt; Result&lt;String, std::io::Error&gt; {
  let mut contents = String::new();
  let bytes_rslt = f.read_to_string(&mut contents);
  if bytes_rslt.is_ok() {
    Ok(contents)
  } else {
    Err(Error::new(ErrorKind::Other, &quot;read error&quot;))
  }
}

pub fn open_file_for_write(file_name: &str) -&gt; Result&lt;File, std::io::Error&gt; {
  let wfile = OpenOptions::new()
    .write(true)
    .create(true)
    .truncate(true)
    .open(file_name);
  wfile
}

pub fn write_string_to_file_handle(s: &str, mut f: std::fs::File) -&gt; std::io::Result&lt;()&gt; {
  f.write_all(s.as_bytes())?;
  f.flush()?;
  Ok(())
}

pub fn write_string_to_file(s: &str, file_name: &str) -&gt; std::io::Result&lt;()&gt; {
  std::fs::write(file_name, s)?;
  Ok(())
}

#[cfg(test)]
mod tests {
  use super::*;
  use tempfile::NamedTempFile;

  /// Test the filename-based API: write_string_to_file + open_file_for_read + read_file_to_string
  #[test]
  fn write_and_read_via_filename() {
    // Create a temporary file and get its path as a String
    let tmp = NamedTempFile::new().expect(&quot;failed to create temp file&quot;);
    let path = tmp.path().to_str().unwrap().to_owned();

    let test_string = &quot;hello via filename&quot;;
    // Write via the file_name API
    write_string_to_file(test_string, &path).expect(&quot;write_string_to_file failed&quot;);

    // Read back
    let mut f = open_file_for_read(&path).expect(&quot;open_file_for_read failed&quot;);
    let contents = read_file_to_string(&mut f).expect(&quot;read_file_to_string failed&quot;);

    assert_eq!(contents, test_string);
  }

  /// Test the handle-based API: open_file_for_write + write_string_to_file_handle + open/read
  #[test]
  fn write_and_read_via_handle() {
    let tmp = NamedTempFile::new()
      .expect(&quot;failed to create temp file&quot;);
    let path = tmp.path().to_str().unwrap().to_owned();

    let test_string = &quot;hello via handle&quot;;
    // Open for write, then write via handle
    let wfile = open_file_for_write(&path)
      .expect(&quot;open_file_for_write failed&quot;);
    write_string_to_file_handle(test_string, wfile)
      .expect(&quot;write_string_to_file_handle failed&quot;);

    // Read back
    let mut f2 = open_file_for_read(&path)
      .expect(&quot;open_file_for_read failed&quot;);
    let contents2 = read_file_to_string(&mut f2)
      .expect(&quot;read_file_to_string failed&quot;);

    assert_eq!(contents2, test_string);
  }
}</code></pre>
          </div>
          <div slot="second" style="padding-right:0.4rem;">
            <pre><code class="language-term">> cargo build --lib
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils
> cargo test --lib
   Compiling windows_x86_64_msvc v0.52.6
   Compiling getrandom v0.3.3
   Compiling cfg-if v1.0.1
   Compiling once_cell v1.21.3
   Compiling fastrand v2.3.0
   Compiling windows-targets v0.52.6
   Compiling windows-sys v0.59.0
   Compiling tempfile v3.20.0
   Compiling file_utils v0.1.0 (C:\github\JimFawcett\NewSite\Code\DesignStructure\TypeEraseDataFlowStructure\Fileutils)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.02s
     Running unittests src\lib.rs (target\debug\deps\file_utils-43bed36694d2543d.exe)

running 2 tests
test tests::write_and_read_via_handle ... ok
test tests::write_and_read_via_filename ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
  <div style="width:100%; float:right; font-weight:bold; text-align: right; padding-right:1rem; padding-bottom:0.5rem;">
    Cargo.toml
  </div>
 <pre><code class="language-tern">[package]
name = "file_utils"
version = "0.1.0"
edition = "2024"

[dependencies]


[dev-dependencies]
tempfile = "3"
</code></pre>
            <div style="margin: 0.5rem 1.5rem; line-height:1.0rem; font-size:0.9rem;">
              <div style="height: 1.0rem;"></div>
              <strong style="margin-bottom: 0rem;">Comments:</strong>
              <ul class="tights" style="margin: 0rem 1.5rem;">
                <li>
                  Fileutils library has no dependencies other than the Rust standard libraries, 
                  as shown in the Cargo.toml above.
                </li>
                <li>
                  It does not define any new types, but does define several functions:
                  <ol>
                    <li>
                      <c-s>fn open_file_for_read(file_name: &str) -> Result&lt;File: std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a handle to its String contents. 
                      The return type is <c-s>Result&lt;File, std::io::Error&gt;</c-s>
                    </li>
                    <li>
                      <c-s>fn read_file_to_string(f: &mut File) -> Result&lt;String, std::io::Error&gt;</c-s><br>
                      Attempts to read contents referred to by file handle and return the string of contents 
                      wrapped in Ok(contents).
                    </li>
                    <li>
                      <c-s>fn open_file_for_write(file_name: &str) -> Result&lt;File, std::io::Error&gt;</c-s><br>
                      Attempts to open named file and return a File handle to the opened named file. 
                    </li>
                    <li>
                      <c-s>fn write_string_to_file_handle(s: &str, mut f: std::fs:::File) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to by the File handle and flush the handle.
                    </li>
                    <li>
                      <c-s>fn write_string_to_file(s: &str, file_name: &str) -> Result&lt;()&gt; </c-s><br>
                      Attempts to write string to file referred to named file.
                    </li>
                  </ol> 
                </li>
                <li>
                  The Build and Test view above shows successful build and execution 
                  of two unit test functions.
                </li>
              </ul>
            </div>
            <div style="height:1.5rem;"></div>
          </div>
        </splitter-container>
        <div style="height:3.00rem;"></div>
        <div style="height:0.5rem;"></div>
        <a id="epilogue"></a>
        <div style="height:0.75rem;"></div>
        <h3>3. Epilogue</h3>
        <div class="indent">
          <t-b>
            The five design alternatives considered here:
            <ol class="tight">
              <li><a href="DesignBites_StructureBasic.html">Monolithic Structure</a></li>
              <li><a href="DesignBites_StructureFactored.html">Factored Structure</a></li>
              <li><a href="DesignBites_StructureDataFlow.html">DataFlow Structure</a></li>
              <li><a href="DesignBites_StructureTypeErase.html">TypeErase Structure</a></li>
              <li><a href="DesignBites_StructurePlugIn.html">PlugIn Structure</a></li>
            </ol>
            are progressively more flexible, eventually resulting in reusable components, but also increasingly
            complex.  Where you settle in these alternatives is determined by design context.  Is this a
            one-of-a-kind project that you want to finish quickly or is it
            heading for production code that will be maintained by more than one developer?
          </t-b>
        </div>
      </content>
    <div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#intro">introduction</a>
        <a href="#structure">structure</a>
        <a href="#pnotes">project notes</a>
        <a href="#executive">executive</a>
        <a href="#input">input</a>
        <a href="#compute">compute</a>
        <a href="#consoleoutput">console output</a>
        <a href="#fileoutput">file output</a>
        <a href="#fileutils">fileutils</a>
        <a href="#epilogue">epilogue</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/DesignBitesPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 6, 10);
  </script>
</body>
</html>
<!DOCTYPE html>
<html id="top">
<!--
  CppRepos.html
-->
<head>
  <title>Cpp Bites Objects</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/help.css" />
  <link rel="stylesheet" href="../css/ThemeCpp.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <link rel="stylesheet" href="../css/prism.css" />
  <script src="../js/prism.js"></script>
  <link rel="stylesheet" href="../css/StylesSplitterBar.css" />
  <script src="../js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="../css/Styles_BitsContent.css" />
  <script src="../js/Scripts_BitsContent.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreCpp.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
  <style>
    .menuHeader {
      padding:0.0rem 0.5rem 0.25rem 0.5rem;
    }
  </style>
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="CppBites_STR.html"></a>
  <a id="prev" class="hidden" href="CppBites_HelloCpp.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    CppBites_Objects.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 01/06/2025
  </div>

  <content-block>
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle" class="header">
        <h2 id="title">CppBites: Objects</h2>
        <h4 id="subtitle" class="indent">
          C++ type system and instances
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.125em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_self" href="CppHome.html" style="color:var(--atten); margin-left:1rem;">C++ Track</a>
      </div>

      <!--<div style="padding-right:25px; position:absolute; top:1.1em; right:13em; z-index:5;">-->
    </header>
    <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
      <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
      This page demonstrates uses of C++ User-Defined types and their objects.
      The purpose is to quickly acquire some familiarity with user-defined types
      and their implementations.
      <hr class="spread" />
      <ul>
        <li>
          C++ defines special class methods: copy and move constructors, copy and move
          assignment operators, and other operators for indexing and comparison etc.
        </li>
        <li>
          The compiler will generate constructors and assignment operators if needed and
          not provided by the class.  Those are correct if, and only if, the class&apos;s
          members and bases have correct semantics for those operations.
          For other cases, like pointer members, developers must either implement them or
          prohibit them. We will show how in this example.
        </li>
        <li>
          Also, this is the first set of examples to partition code into several files.
          That supports readability, may improve translation times, and makes maintenance
          significantly easier.
        </li>
      </ul>
      <div style="height:0.5em;"></div>
    </t-b>
    <div style="height:0.75em;"></div>
    <details id="aggrtypes">
      <summary class="darkItem">C++ Aggregate Type Structure&nbsp;&nbsp;</summary>
      <div style="padding:0em 1em 1em 1em; width:max-content; border:1px solid var(--dark);">
        <t-b>
          Aggregates are types whose instances hold instances of, or handles to, other types, i.e., an array can hold
          instances of an arbitrary type. Structs and classes can hold named instances or handles to arbitrary other types.
        </t-b>
        <t-b>
          There are three ways that happens:
          <ul>
            <li>
              <strong>Inheritance</strong>
              <t-b>
                A C++ class can inherit multiple base class implementations. The memory footprint of this derived
                class contains the entire footprint of each of its bases.
              </t-b>
            </li>
            <li>
              <h5>Composition</h5>
              <t-b>
                When an instance of a C++ type holds one or more instances of other types, the memory footprint of each composed type
                lies entirely within the memory footprint of its parent instance.  We say the parent
                composes its child elements.
              </t-b>
            </li>
            <li>
              <h5>Aggregation</h5>
              <t-b>
                C++ types can hold references and native pointers to instances in static, stack, or native heap memory,
                and smart pointer handles to instances of types stored in the
                native heap, e.g., std::unique_ptr&lt;T&gt; or std::shared_ptr&lt;T&gt;.
              </t-b>
              <t-b>
                When an instance of a  type holds a pointer or handle to instances of other types,
                the parent&apos;s memory footprint holds only the pointer or handle, not the entire child
                instance.  We say the parent aggregates the type referenced by the pointer or handle.
              </t-b>
            </li>
          </ul>
        </t-b>
        <t-b>
          The freedom to structure classes in so many ways gives designers very powerful
          modeling tools at the expense of complexity and many paths to undefined
          behavior.
        </t-b>
      </div>
    </details>
    <div style="height:0.75rem;"></div>
    <details id="notes">
      <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
      <div style="border:1px solid var(--dark); padding:0em 1em 0.5em; max-width:fit-content;">
        <t-b>
          All of the languages covered in this demonstration support classes<sup>1</sup>.  Each class provides
          a pattern for laying out a memory footprint and defines how data within are accessed.
        </t-b>
        <t-b>
          Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
          is a pattern for defining functions and classes of a specific type.  Thus a generic is a
          pattern for making patterns.
        </t-b>
        <t-b>
          The other two, Python and JavaScript, are dynamically typed and already support defining
          functions and classes that work for multiple types, e.g., no need for generics.
        </t-b>
        <t-b>
          This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
          are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
          stored in managed heaps.
        </t-b>
        <t-b>
          A few functions in this code are generic, e.g., have type(s) to be specified by the caller
          at compile time. The next bit explores generics in greater detail with more discussion.
        </t-b>
        <div style="margin:0.25em 1em; font-size:0.85em; max-width:75%;">
          <hr />
          <ol>
            <li>
              Rust uses structs to implement objects in the same way that the other languages
              use classes.  Here we will just use the term class for all of them.
            </li>
          </ol>
        </div>
      </div>
    </details>
    <div style="height:0.25em;"></div>
    <t-b>
      The examples below show how to create and use instances of library and user defined types, with emphasis on
      illustrating syntax and basic operations.
    </t-b>
    <div style="height:0.15em;"></div>
    <h3 id="code">1.0 Source Code</h3>
    <t-b>
      Code for this &quot;Objects&quot; Bit is presented in a six part sequence:
      <ol>
        <li>
          Demonstrations of common std library types, showing both code and output.
        </li>
        <li>
          Code declaring a user-defined type, Point4D, is presented in the second block. Much of the
          technical weight of this Bit is carried by the left and right panels in this block.
        </li>
        <li>
          The third block illustrates how Point4D is created and used.
        </li>
        <li>
          Next, we show how to create instances of std library types and also Point4D in the
          native heap and how they are used.
        </li>
        <li>
          The next block presents code and discussion for a library of display and analysis
          functions.
        </li>
        <li>
          Finally, we illustrate the program structure for this demonstration. The emphasis here
          is on how functions and files partition processing for this demonstration.
        </li>
      </ol>
    </t-b>
    <t-b id="getsrc" class="note">
      The source code is available
      <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
      Download the entire Bits repository
      <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
    </t-b>
    <div>
      <h3 id="libtyp">1.1 Declaration and use of std::library types</h3>
      <t-b>
        This block presents creation and use of instances of std library types.
        It&apos;s provided here for comparison with the code for user-defined
        type Point4D.
      </t-b>
      <t-b>
        Here you see a side-by-side view of executable code with the output
        it provides. That proximity makes it easier to understand how the code works.
      </t-b>
      <t-b>
        Source code is available
        <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
        Download the entire Bits repository
        <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
      </t-b>
      <t-b>
        The two panels below are separated by a &quot;splitter bar&quot;.  You can drag the
        bar horizontally to view hidden code or output.
      </t-b>
      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
        <splitter-container id="container">
          <first-item id="fig2-first" style="width:52%;">
            <div class="codewrap">
              <pre onclick="cbubbleup('fig2-first')" style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------                              
Demonstration library types std::string and std::vector&lt;T&gt; 
*/
void demo_stdlib() {

print(&quot;Demonstrate C++ Objects&#92;n&quot;);

showNote(&quot;std library types string and vector&lt;T&gt;&quot;);

/* create and display std::string object */
auto str = std::string(&quot;&#92;&quot;Wile E. Coyote&#92;&quot;&quot;);
auto out = std::string(&quot;contents of str = &quot;) + str;
print(out);
print(&quot;--- showType(str, &#92;&quot;str&#92;&quot;); ---&quot;);
showType(str, &quot;str&quot;, nl);

/* create and display std::vector&lt;double&gt; */
auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 };
showOp(&quot;showType(vec, &#92;&quot;vec&#92;&quot;);&quot;);
showType(vec, &quot;vec&quot;);
std::cout &lt;&lt; &quot;&#92;n  vec:&quot; &lt;&lt; vec;
// equivalent to:
// operator&lt;&lt;(operator&lt;&lt;(std::cout, &quot;&#92;n  vec:&quot;), vec);
// uncomment the preceeding line to see the output repeated

showOp(&quot;vec[2] = -2.5;&quot;);
vec[2] = -2.5;
std::cout &lt;&lt; &quot;&#92;n  vec:&quot; &lt;&lt; vec;

showOp(&quot;auto vec2 = vec : copy construction&quot;);
/* copy construction */
auto vec2 = vec;
std::cout &lt;&lt; &quot;&#92;n  vec2:&quot; &lt;&lt; vec2;

showOp(&quot;vec2[0] = 42;&quot;);
vec2[0] = 42;
std::cout &lt;&lt; &quot;&#92;n  vec2: &quot; &lt;&lt; vec2;
std::cout &lt;&lt; &quot;&#92;n  vec: &quot; &lt;&lt; vec;

showNote(
  &quot;Copy construction, auto vec2 = vec, creates&#92;n    &quot;
  &quot;independent instance. So changing target vec2&#92;n    &quot;
  &quot;has no affect on source vec.&quot;
);

showOp(&quot;vec = vec2 : copy assignment&quot;);
vec = vec2;
// equivalent to:
// vec.operator=(vec2);
// uncomment the preceeding line and observe no change
std::cout &lt;&lt; &quot;&#92;n  vec: &quot; &lt;&lt; vec &lt;&lt; &quot;&#92;n&quot;;

</code></pre>
            </div>
          </first-item>
          <splitter-bar id="fig2-seperator"></splitter-bar>
          <second-item id="fig2-second" style="width:48%;">
            <div class="codewrap">
              <pre onclick="obubbleup('fig2-first')" style="width:200em;"><code class="language-shell">
              


Demonstrate C++ Objects

--------------------------------------------------                                        
std library types string and vector&lt;T&gt;
--------------------------------------------------
contents of str = &quot;Wile E. Coyote&quot;
--- showType(str, &quot;str&quot;); ---
str type: class std::basic_string&lt;char,struct std:...
size:  40

vector&lt;T&gt;: {
3.5, 3, 2.5, 2
}
--- showType(vec, &quot;vec&quot;); ---
vec type: class std::vector&lt;double,class std::allo...
size:  32

--- vec[2] = -2.5; ---
vec:
vector&lt;T&gt;: {
3.5, 3, -2.5, 2
}
--- auto vec2 = vec : copy construction ---
vec2:
vector&lt;T&gt;: {
3.5, 3, -2.5, 2
}
--- vec2[0] = 42; ---
vec2:
vector&lt;T&gt;: {
42, 3, -2.5, 2
}
vec:
vector&lt;T&gt;: {
3.5, 3, -2.5, 2
}
--------------------------------------------------
Copy construction, auto vec2 = vec, creates
independent instance. So changing target vec2
has no affect on source vec.
--------------------------------------------------
--- vec = vec2 : copy assignment ---
vec: [42, 3, -2.5, 2]




              </code></pre>
            </div>
          </second-item>
        </splitter-container>
      </div>
      <div style="height:0.25em;"></div>
      <h3 id="points">1.2 Point4D Class</h3>
      <t-b style="margin-bottom:1em;">
        This block presents code that defines a C++ type, Point4D. It defines the
        data held by instances of the type, three double precision coordinates and
        a std::time_t variable, and methods to create, copy, assign, modify
        and destroy instances.
      </t-b>
      <!--           <t-b>
         A C++ class is a pattern for laying out data in memory with member functions,
         called methods, for all of its operations.  Making data members private ensures
         that class methods have valid data for their operations. A class designer may
         choose to selectively allow user data modification.
       </t-b>
-->
      <!--           <t-b>
         This file is a header only library that defines a type, <c-s>Point4D</c-s>, representing
         a point in 3 dimensional space with a forth time dimension.
       </t-b>
       <t-b>
         A sequence of these instances could be used
         to capture flight trajectories for commercial aircraft, for example.
       </t-b>
-->
      <t-b>
        User-defined C++ types are described by classes. A class is a pattern for laying out
        an instance&apos;s data in the stack or heap, and methods that access and modify the data.
      </t-b>
      <t-b>
        Instances, i.e. objects, are created by invoking a constructor method, and are accessed
        and modified by other methods.
        <!-- </t-b>
<t-b> -->
        Code that implements class methods resides in static memory, and has lifetime essentially
        equal to program lifetime.
      </t-b>
      <!--         </div>
     <div id="txt1" class="txt">
       <t-b>
         <c-s>Point4D</c-s> declares all of the C++ special methods: void, copy,
         and move constructors, copy and move assignment, and a destructor.
         All but the void constructor are declared default.
       </t-b>
       <t-b>
         That
         means that the compiler implements them by doing member-wise operations, e.g.,
         the default copy constructor copies each of the class data members and any base
         class instances, using their copy constructors.
       </t-b>
       <t-b>
         Compiler generation works correctly only if all members have correct copy and assignment
         semantics. That is true for all primitive data types and all of the Standard Template
         Library containers, but not true for pointers or handles.
       </t-b>
       <t-b style="color:maroon;">
         All the special methods are described in detail in
         <a target="_blank" href="../../Resources/CppBites/CppBites_STR.html">STR</a>, code for a user-defined
         string class.
       </t-b>
     </div>
     <div id="txt2" class="txt">
       <t-b>
         Methods may be defined inline, like <c-s>xCoor</c-s> and <c-s>tCoor</c-s>.
         Class data, like <c-s>x</c-s> and <c-s>t</c-s>, are declared private so
         they can only be mutated by methods of the class.
       </t-b>
       <t-b>
         Methods like <c-s>xCoor</c-s> that return references allow a class designer
         to selectively expose class data to user modification.
       </t-b>
     </div>
     <div id="txt3" class="txt">
       <t-b>
         Class methods may also be defined outside the bounds of the class declaration,
         as shown for <c-s>Point4D()</c-s>, <c-s>timeToString()</c-s>, et al. Moving all
         complex method definitions below the class declaration makes the class
         interface easier to understand.
       </t-b>
       <t-b>
         Note that doesn&apos;t work for languages like C# and Java.
       </t-b>
-->

      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
        <splitter-container id="container">
          <first-item id="fig3-first" style="width:50%;">
            <div class="codewrap" onclick="cbubbleup('fig3-first')">
              <pre style="width:200em;"><code class="language-cpp">/*---------------------------------------------------------         
Points.h defines a space-time point class:
- Point4D represents points with three double spatial
coordinates and std::time_t time coordinate.
*/
#pragma warning(disable:4996) // warning about ctime use
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
/*---------------------------------------------------------
Point4D class represents a point in a 4-Dimensional 
space-time lattice. Simple enough for illustration, 
but still useful.

It declares all of the special class methods, most with
default qualifiers to indicate that the compiler will
generate them as needed.

The word ctor is an abbreviation of constructor and dtor
an abbreviation for destructor.
*/
class Point4D {
public:
Point4D();                              // void ctor
Point4D(const Point4D& pt) = default;   // copy ctor
Point4D(Point4D&& pt) = default;        // move ctor
Point4D& operator=(const Point4D& pt) = default;
                                      // copy assignment
Point4D& operator=(Point4D&& pt) = default;
                                      // move assignment
~Point4D() = default;                   // dtor
std::string timeToString();
void updateTime();
void show();
double& xCoor() { return x; }
double& yCoor() { return y; }
double& zCoor() { return z; }
std::time_t& tCoor() { return t; }
private:
double x;
double y;
double z;
std::time_t t;
};

Point4D::Point4D() {
x = y = z = 0.0;
t = std::time(0);
}
std::string Point4D::timeToString() {
return ctime(&t);
/*
ctime is depricated due to a thread-safety issue.
That's not a problem here. Compiler warning
recommends converting to ctime_s, which, unfortunately
has a different and awkward interface.
*/
}
void Point4D::updateTime() {
t = std::time(0);
}

void Point4D::show() {
std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; &quot;Point4D {&quot;;
std::cout &lt;&lt; &quot;&#92;n    &quot; 
        &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot;, &quot;;
std::cout &lt;&lt; &quot;&#92;n    &quot; &lt;&lt; timeToString();
std::cout &lt;&lt; &quot;  }&quot;;
}

/* required for showType(T t, const std::string& nm) */

std::ostream& operator&lt;&lt;(
std::ostream& out, Point4D& t1
) {
out &lt;&lt; &quot;Point4D {&quot;;
out &lt;&lt; &quot;    &quot; &lt;&lt; t1.xCoor() &lt;&lt; &quot;, &quot; &lt;&lt; t1.yCoor() &lt;&lt; &quot;, &quot;
            &lt;&lt; t1.zCoor() &lt;&lt; std::endl
            &lt;&lt; &quot;    &quot; &lt;&lt; t1.timeToString() &lt;&lt; std::endl
            &lt;&lt; &quot;  }&quot; &lt;&lt; std::endl;
return out;
}
</code></pre>
            </div>
          </first-item>
          <splitter-bar id="fig3-seperator"></splitter-bar>
          <second-item id="fig3-second" style="width:40em;" onclick="obubbleup('fig3-first')">
            <div class="textwrap noflow commentary">
              <h3>Point4d:</h3>
              <t-b>
                holds data for a point in 3 dimensional space and a time when<br />
                something was at that point.
              </t-b>
              <t-b>
                These points could be collected into a vector to represent a<br />
                trajectory of an aircraft or a machine tool cutting edge.
              </t-b>
              <br /><br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br />
              <h4><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> C++ class syntax:</h4>
              <t-b>
                C++ defines six special methods for construction, assignment,<br />
                and destruction, all based on class name. They are illustrated<br />
                in this block.
              </t-b>
              <t-b>
                The C++ compiler will implement default copy constructor,<br />
                destructor, and assignment operator if using code implies a <br />
                copy and/or assignment and the class designer has not provided<br />
                them. Destructors are always required and are generated if<br />
                the class does not provide one.
              </t-b>
              <t-b>
                The compiler does this by using its member&apos;s and base&apos;s<br />
                construction, assignment, and destruction operations for all parts<br />
                of the class.  These operations are applied member-wise, e.g.,<br />
                to each base class and member datum, in order of their declaration.
              </t-b>
              <t-b>
                However, the implemented methods are correct if, and only if, class<br />
                members and bases have correct copy, destruction, and assignment<br />
                semantics.
              </t-b>
              <t-b>
                This is a common source of errors so it is appropriate to use the<br />
                &quot;default&quot; qualifier to indicate that the designer expects the<br />
                generated methods will be correct. Use the &quot;delete&quot; qualifier to<br />
                prevent the compiler from generating the deleted operation.
              </t-b>
              <h4>
                Function overloading:
              </h4>
              <t-b>
                C++ defines overloading of functions based on function signature.<br />
                Essentially a function overload is a new function with a name based<br />
                on the original function name and the types of its arguments<br />
                created, by a process call &quot;name-mangling&quot;.
              </t-b>
              <t-b>
                Copy and move construction functions Point4D(...) are overloads<br />
                of the void constructor, Point4D(), and the copy and move<br />
                assignment operators are overloads of the operator= function.
              </t-b>
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br />
              <t-b>
                <h4><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> C++ operators</h4>
                are functions that are called when statements with operator symbols<br />
                are encountered, e.g., <c-s>x&nbsp;=&nbsp;y</c-s> is
                equivalent to <c-s>x.operator=(y)</c-s> and<br />
                <c-s>std::cout&nbsp;&lt;&lt;&nbsp;x</c-s> is equivalent to <c-s>operator&lt;&lt;(std::cout,&nbsp;x)</c-s>.
              </t-b>
              <t-b>
                The std::ostream <c-s>operator&lt;&lt;(std::ostream& out, T& t)</c-s> converts<br />
                objects of type <c-s>T</c-s> into parts that the default <c-s>std::operator&lt;&lt;</c-s>
                can<br />
                process. The overload for Point4D is needed by functions in the<br />
                AnalysisObjects.h library.
              </t-b>
            </div>
          </second-item>
        </splitter-container>
        <div style="padding:0.25em 1em;">
          <t-b>
            All the C++ class special methods are described in detail in
            <a target="_blank" href="../../Resources/CppBites/CppBites_STR.html">STR</a>, code for a user-defined
            string class.
          </t-b>
          <t-b>
            Methods may be defined inline, like <c-s>xCoor</c-s> and <c-s>tCoor</c-s>.
            Class data, like <c-s>x</c-s> and <c-s>t</c-s>, are declared private so
            they can only be mutated by methods of the class.
          </t-b>
          <t-b>
            Methods like <c-s>xCoor</c-s> that return references allow a class designer
            to selectively expose class data to user modification.
          </t-b>
          <t-b>
            Class methods may also be defined outside the bounds of the class declaration,
            as shown for <c-s>Point4D()</c-s>, <c-s>timeToString()</c-s>, et al. Moving all
            complex method definitions below the class declaration makes the class
            interface easier to understand.
          </t-b>
        </div>
      </div>
      <div style="height:0.5em;"></div>
      <h3 id="usrdef">1.3 Point4D Demo</h3>
      <t-b>
        The block below illustrates construction and operations of instances of
        the user-defined Point4D class.
      </t-b>
      <t-b>
        The void constructor, one with no arguments, is defined immediately below
        the Point4D class declaration.  All other operations, e.g., copy construction,
        assignment, and destruction are implemented by the compiler, using element-wise
        operations. That is, for copy construction, the compiler generated code uses the
        copy construction code for each element.
      </t-b>
      <t-b>
        Source code is available
        <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
        Download the entire Bits repository
        <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
      </t-b>
      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote2()" />
        <splitter-container id="container">
          <first-item id="point-first" style="width:52%;">
            <div class="codewrap" onclick="cbubbleup('point-first')">
              <pre style="width:200em;"><code class="language-cpp">/*------------------------------------------------*/                                        
showNote(&quot;user-defined type Point4D&quot;);
Point4D p1;
p1.show();
p1.xCoor() = 42;
p1.zCoor() = -3.5;
/*- t contains time of construction -*/
p1.show();
print();

print(&quot;--- showType(p1, &#92;&quot;p1&#92;&quot;, nl) ---&quot;);
showType(p1, &quot;p1&quot;, nl);
std::cout &lt;&lt; &quot;  p1.xCoor() returns value &quot;
&lt;&lt; p1.xCoor() &lt;&lt; &quot;&#92;n&quot;;

showOp("Point4D p2 = p1 : copy construction");
Point4D p2 = p1;  // copy construction
p2.show();

showOp("p2.xCoor() *= 2");
p2.xCoor() *= 2;
p2.show();

showOp("p1 = p2 : copy assignment");
p1 = p2;  // copy assignment
p1.show();






</code></pre>
            </div>
          </first-item>
          <splitter-bar id="point-seperator"></splitter-bar>
          <second-item id="point-second" style="width:48%;">
            <div class="codewrap" onclick="obubbleup('point-first')">
              <pre style="width:200em;"><code class="language-shell">--------------------------------------------------
user-defined type Point4D
--------------------------------------------------                                
Point4D {
0, 0, 0,
Mon May  1 16:04:27 2023
}
Point4D {
42, 0, -3.5,
Mon May  1 16:04:27 2023
}

--- showType(p1, &quot;p1&quot;, nl) ---
p1 type: class Point4D
size:  32
p1.xCoor() returns value 42

--- Point4D p2 = p1 : copy construction---
Point4D {
42, 0, -3.5,
Thu Dec  7 19:34:59 2023
}
--- p2.xCoor() *= 2 ---
Point4D {
84, 0, -3.5,
Thu Dec  7 19:34:59 2023
}
--- p1 = p2 : copy assignment ---
Point4D {
84, 0, -3.5,
Thu Dec  7 19:34:59 2023
}
</code></pre>
            </div>
          </second-item>
        </splitter-container>
      </div>
      <h3 id="heap">1.4 Heap-based operations</h3>
      <t-b>
        C++ code does not use a garbage collector to support creating and releasing
        memory allocations. Therefore class designers must manage those operations.
      </t-b>
      <h3 id="heapstr">1.4.1 Managing std::String instances in the native heap</h3>
      <t-b>
        This block illustrates how that is done for instances of the std::String class,
        using the <c-s>std::unique_ptr&lt;T&gt;</c-s>.
      </t-b>
      <t-b>
        <c-s>std::unique_ptr&lt;T&gt;</c-s> instances are smart pointers that mimic standard
        C++ pointer operations, e.g., same interface for pointer operations, but automatically
        call delete on their internal pointer to heap instance when they go out of scope.
      </t-b>
      <t-b>
        That returns the allocation for future use by another program operation.
      </t-b>
      <t-b>
        Source code is available
        <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
        Download the entire Bits repository
        <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
      </t-b>
      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote3()" />
        <splitter-container id="container">
          <first-item id="fig4-first" style="width:52%;">
            <div class="codewrap">
              <pre onclick="cbubbleup('fig4-first')" style="width:200em;"><code class="language-cpp">
/*------------------------------------------------*/                                        
showNote(&quot;heap-based string instance&quot;);

/* standard library type std::string */
/* uses alias pU for std::unique_ptr */
showOp(
&quot;pU&lt;std::string&gt; &quot;
&quot;pStr(new std::string(&#92;&quot;&#92;&#92;&#92;&quot;Road Runner&#92;&#92;&#92;&quot;&#92;&quot;)&quot;
);
pU&lt;std::string&gt; pStr(
new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;)
);
std::cout &lt;&lt; &quot;&#92;n  pStr contents = &quot;
&lt;&lt; *pStr &lt;&lt; &quot;&#92;n&quot;;

showOp(&quot;showType(*pStr, &#92;&quot;*pStr&#92;&quot;)&quot;);
showType(*pStr, &quot;*pStr&quot;, nl);

/* std::unique_ptr&lt;T&gt; cannot be copied
but can be moved */
showOp(&quot;showType(move(pStr), &#92;&quot;pStr&#92;&quot;)&quot;);
showType(move(pStr), &quot;pStr&quot;, nl);

// showType(pStr, &quot;pStr&quot;) is an illegal call
// since pStr cannot be copied to preserve uniqueness

</code></pre>
            </div>
          </first-item>
          <splitter-bar id="fig4-seperator"></splitter-bar>
          <second-item id="fig4-second" style="width:48%;">
            <div class="codewrap">
              <pre onclick="obubbleup('fig4-first')" style="width:200em;"><code class="language-shell">--------------------------------------------------
heap-based string instance
--------------------------------------------------                                        
--- pU&lt;std::string&gt; pStr(new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;) ---
pStr contents = &quot;Road Runner&quot;

--- showType(*pStr, &quot;*pStr&quot;) ---
*pStr type: class std::basic_string&lt;char,struct std:...
size:  40

--- showType(move(pStr), &quot;pStr&quot;) ---
pStr type: class std::unique_ptr&lt;class std::basic_s...
size:  8














</code></pre>
            </div>
          </second-item>
        </splitter-container>
      </div>
      <h3 id="heapvec">1.4.2 Heap-based operations for std::Vector&lt;T&gt;</h3>
      <t-b>
        The code below substitutes <c-s>std::Vector&lt;T&gt;</c-s> for
        <c-s>std::String</c-s> in the code above.  The operation syntax is the
        same.  We show here that the address of the heap object is returned by
        sending the pointer to standard output, just like native pointers.
      </t-b>
      <t-b>
        Source code is available
        <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
        Download the entire Bits repository
        <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
      </t-b>
      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote4()" />
        <splitter-container id="container">
          <first-item id="fig5-first" style="width:52%;">
            <div class="codewrap">
              <pre onclick="cbubbleup('fig5-first')" style="width:200em;"><code class="language-cpp">/*------------------------------------------------*/                                         
/* standard library type std::vector&lt;T&gt; */
showNote(&quot;heap-based vector instance&quot;);
showOp(
  &quot;pU&lt;std::vector&lt;double&gt;&gt;&#92;n &quot;
  &quot;     pVec(
          new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }
        );&quot;
);
pU&lt;std::vector&lt;double&gt;&gt; pVec(
  new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }
);
std::cout &lt;&lt; &quot;&#92;n  *pVec = &quot; &lt;&lt; *pVec;
showType(*pVec, &quot;*pVec&quot;, nl);
std::cout &lt;&lt; &quot;&#92;n  pVec = &quot; &lt;&lt; pVec;
showType(move(pVec), &quot;move(pVec)&quot;, nl);
              </code></pre>
            </div>
          </first-item>
          <splitter-bar id="fig5-seperator"></splitter-bar>
          <second-item id="fig5-second" style="width:48%;">
            <div class="codewrap">
              <pre onclick="obubbleup('fig5-first')" style="width:200em;"><code class="language-cpp">--------------------------------------------------
heap-based vector instance
--------------------------------------------------                                        
--- pU&lt;std::vector&lt;double&gt;&gt;
pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }); ---
*pVec =
vector&lt;T&gt;: {
1.5, 2.5, 3.5
}
*pVec type: class std::vector&lt;double,class std::allo...
size:  32

pVec = 000002897B682AC0
move(pVec) type: class std::unique_ptr&lt;class std::vector&lt;...
size:  8


</code></pre>
            </div>
          </second-item>
        </splitter-container>
      </div>
      <h3 id="heappt">1.4.3 Heap-based operations for user-defined Point4D</h3>
      <t-b>
        Using the same plan for execution as in the two blocks above, we see that
        all the methods of the heap-based Point4D instance are accessible using
        pointer operations, e.g., <c-s>std::unique_ptr&lt;T&gt;</c-s> uses the same
        pointer syntax for operations as the native C++ pointer.
      </t-b>
      <t-b>
        Source code is available
        <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
        Download the entire Bits repository
        <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
      </t-b>
      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote5()" />
        <splitter-container id="container">
          <first-item id="fig6-first" style="width:52%;">
            <div class="codewrap">
              <pre onclick="cbubbleup('fig6-first')" style="width:200em;"><code class="language-cpp">/*------------------------------------------------*/                                        
/* custom point types */
showNote(&quot;heap-based Point4D instance&quot;);
showOp(&quot;pU&lt;Point4D&gt; pPoint4D(new Point4D())&quot;);
pU&lt;Point4D&gt; pPoint4D(new Point4D());
pPoint4D-&gt;show();
pPoint4D-&gt;xCoor() = 1;
pPoint4D-&gt;yCoor() = 2;
pPoint4D-&gt;zCoor() = -3;
pPoint4D-&gt;updateTime();
pPoint4D-&gt;show();

std::cout &lt;&lt; &quot;&#92;n  pPoint4D-&gt;zCoor() = &quot; 
          &lt;&lt; pPoint4D-&gt;zCoor();
showOp(&quot;showType(*pPoint4D, &#92;&quot;*pPoint4D&#92;&quot;);&quot;);
showType(*pPoint4D, &quot;*pPoint4D&quot;);
showOp(
  &quot;showType(std::move(pPoint4D), &#92;&quot;pPoint4D&#92;&quot;);&quot;
);
showType(std::move(pPoint4D), &quot;pPoint4D&quot;, nl);
/* pPoint4D moved, so now invalid */

print(&quot;&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
</code></pre>
            </div>
          </first-item>
          <splitter-bar id="fig6-seperator"></splitter-bar>
          <second-item id="fig6-second" style="width:48%;">
            <div class="codewrap">
              <pre onclick="obubbleup('fig6-first')" style="width:200em;"><code class="language-cpp">--------------------------------------------------
heap-based Point4D instance
--------------------------------------------------                                        
--- pU&lt;Point4D&gt; pPoint4D(new Point4D()) ---
Point4D {
0, 0, 0,
Mon May  1 16:04:27 2023
}
Point4D {
1, 2, -3,
Mon May  1 16:04:27 2023
}
pPoint4D-&gt;zCoor() = -3
--- showType(*pPoint4D, &quot;*pPoint4D&quot;); ---
*pPoint4D type: class Point4D
size:  32
--- showType(std::move(pPoint4D), &quot;pPoint4D&quot;); ---
pPoint4D type: class std::unique_ptr&lt;class Point4D,stru...
size:  8


That's all Folks!


</code></pre>
            </div>
          </second-item>
        </splitter-container>
      </div>
      <div style="height:1em;"></div>
      <h3 id="analysis">1.5 AnalysisObj.h - Analysis and Display Functions</h3>
      <t-b style="margin-bottom:1em;">
        This block presents code for analysis and display of C++ objects. The source code
        is available
        <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
        Download the entire Bits repository
        <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
      </t-b>
      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
        <splitter-container id="container">
          <first-item id="anal-first" style="width:52%;">
            <div class="codewrap" onclick="cbubbleup('anal-first')">
              <pre style="width:200em;"><code class="language-cpp">/*---------------------------------------------------------
AnalysisObj.h
- Provides functions that analyze types, display results
and other program defined information.
- Some of this code requires complex template operations.
Those will be discussed in the generics bit.
- You can skip the hard parts until then, without loss
of understanding.
*/

#include &lt;typeinfo&gt;     // typeid
#include &lt;utility&gt;      // move()
#include &lt;sstream&gt;      // stringstream
#include &lt;type_traits&gt;  // is_scalar, if constexpr
#include &lt;iostream&gt;     // cout
#include &lt;vector&gt;       // vector

/*---------------------------------------------------------
Display and Analysis function and globals definitions
-----------------------------------------------------------
*/
const std::string nl = &quot;&#92;n&quot;;
/*---------------------------------------------------------
Mutable globals are a common source of bugs.  We try not
to use them, but will use DisplayParams here to control
how insertion operator sends instances to std output.

Only the trunc variable is used in this demo. The others
will be used in the Bits_GenericCpp demo.
*/
struct displayParams {
size_t left = 2;    // number of spaces to indent
size_t width = 7;   // width of display row
size_t trunc = 40;  // replace text after trunc with ...
} DisplayParams;      // global object

/*-----------------------------------------------
Display text after newline and indentation
*/
inline void print(const std::string& txt = &quot;&quot;) {
std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;
}
/*-----------------------------------------------
Display text after newline and indentation
- provides trailing newline
*/
inline void println(const std::string& txt = &quot;&quot;) {
std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;
}
/*-----------------------------------------------
Overload operator&lt;&lt; required for
showType(std::vector&lt;T&gt; v, const std::vector&lt;T&gt;& nm)
*/
template&lt;typename T&gt;
std::ostream& operator&lt;&lt; (
std::ostream& out, const std::vector&lt;T&gt;& vec
) {
out &lt;&lt; &quot;[&quot;;
for (auto it = vec.begin(); it != vec.end(); ++it)
{
    out &lt;&lt; *it;
    if (it != vec.end() - 1)
        out &lt;&lt; &quot;, &quot;;
}
out &lt;&lt; &quot;]&quot;;
return out;
}
/*-----------------------------------------------
Display emphasized text
*/
inline void showNote(
const std::string& txt, const std::string& suffix = &quot;&quot;
) {
print(&quot;--------------------------------------------------&quot;);
print(&quot;  &quot; + txt);
print(&quot;--------------------------------------------------&quot;);
std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
Display emphasized line
*/
inline void showOp(
const std::string& opstr, const std::string& suffix = &quot;&quot;
) {
std::cout &lt;&lt; &quot;&#92;n  --- &quot; &lt;&lt; opstr &lt;&lt; &quot; ---&quot; &lt;&lt; suffix;
}
/*-----------------------------------------------
Helper function for formatting output
- truncates line to N chars and adds ellipsis
*/
inline std::string truncate(size_t N, const char* pStr) {
std::string temp(pStr);
if(temp.length() &gt; N) {
temp.resize(N);
return temp + &quot;...&quot;;
}
return temp;
}
/*-----------------------------------------------
Helper function for formatting output
- generates string of n blanks to offset text
*/
inline std::string indent(size_t n) {
return std::string(n, ' ');
}
/*-----------------------------------------------
Display calling name, static class, and size
*/
template&lt;typename T&gt;
void showType(
T t, const std::string &callname,
const std::string& suffix = &quot;&quot;
) {
std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; callname;  // show name at call site
std::cout &lt;&lt; &quot; type: &quot;
        &lt;&lt; truncate(DisplayParams.trunc,typeid(t).name());
std::cout &lt;&lt; &quot;&#92;n  size:  &quot; &lt;&lt; sizeof(t);  // show size on stack     
std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
Format output for scalar types like primitives
*/
template&lt;typename T&gt;
std::string formatScalar(
const T& t, const std::string& nm,
const std::string& suffix = &quot;&quot;,
size_t left = 2
) {
std::stringstream out;
out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; suffix;
return out.str();
}
/*-----------------------------------------------
Format output for strings
- indent and embed in quotation marks
*/
template&lt;typename T&gt;
std::string formatString(
const T& t, const std::string& nm,
const std::string& suffix = &quot;&quot;,
size_t left = 2
) {
std::stringstream out;
out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm
  &lt;&lt; &quot;: &#92;&quot;&quot; &lt;&lt; t &lt;&lt; &quot;&#92;&quot;&quot; &lt;&lt; suffix;
return out.str();
}
</code></pre>
            </div>
          </first-item>
          <splitter-bar id="anal-seperator"></splitter-bar>
          <second-item id="anal-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('anal-first')">
            <div class="textwrap noflow commentary">
              <h4>Analysis and Display Functions:</h4>

              This code block contains definitions of ten functions, four of<br />
              which are templates.  If this seems too complex for you right<br />
              now, you don&apos;t have to understand them completely to under-<br />
              stand this Bits demo.<br />
              <br />
              You are invited to skim over the definitions to try to see what<br />
              they do, not so much how they do it. You can come back later<br />
              to pick up any missing details.<br />
              <br />
              The next <a target="_blank" href="Bits_GenericCpp.html">Bit</a> will explore generics and will help you understand<br />
              how these functions work.

              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br />
              <h4>Template functions:</h4>

              Template functions are code generators that create function<br />
              overloads for specific template argument types using a template<br />
              pattern.<br />
              <br />
              That creates function overloads for each T argument, e.g.,<br />
              several distinct functions generated from a single template<br />
              function definition.<br />
              <br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br />
              <h3><span style="font-size:1.25em; font-weight:bold;">&lArr;</span>  <c-s>showType(T t, ...)</c-s></h3> 
              is the only analysis function in this file. The next <a target="_blank" href="Bits_GenericCpp.html">Bit</a> will add<br />
              several more.<br />
              <br />
              The other functions simply format and display their instance<br />
              arguments, or provide helper activities for display.

            </div>
          </second-item>
        </splitter-container>
      </div>
      <div style="height:1em;"></div>

      <h3 id="structure">1.6 Program Structure</h3>
      <t-b style="margin-bottom:1em;">
        The block below illustrates how this program is structured using three files:
        PointsObj.h, AnalysisObj.h, and Cpp_Objects.cpp, and several functions
        defined in Cpp_Objects.cpp.
      </t-b>
      <t-b>
        The first two files are header-only libraries and the third defines execution flow
        for demonstration of C++ library and user-defined types.
      </t-b>
      <t-b>
        Source code is available
        <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
        Download the entire Bits repository
        <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
      </t-b>
      <div class="blockSingle" style="padding:0em;">
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
        <splitter-container id="container">
          <first-item id="structure-first" style="width:52%;">
            <div class="codewrap" onclick="cbubbleup('structure-first')">
              <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
Cpp_Objects.cpp
- depends on Points.h to provide user-defined point class
- depends on Analysis.h for several display and analysis functions
*/
#include &lt;iostream&gt;     // std::cout
#include &lt;memory&gt;       // std::unique_ptr
#include &lt;vector&gt;       // vector&lt;T&gt; class
#include &lt;array&gt;        // array&lt;T&gt; class
#include &lt;map&gt;          // map&lt;K,V&gt; class
#include &lt;set&gt;          // set&lt;T&gt; class
#include &quot;AnalysisObj.h&quot;   // Analysis functions for this demo
#include &quot;PointsObj.h&quot;     // Point4D class declaration
/*-----------------------------------------------
Note:
Find all Bits code, including this in
https://github.com/JimFawcett/Bits
You can clone the repo from this link.
-----------------------------------------------*/
/*
This demo uses the std::string and std::vector&lt;T&gt; classes
and a user defined class, Point4D, to illustrate how objects
are defined and instantiated.

Operations:
All the classes discussed here provide operations for:
  T t2 = t1          // copy construction
  T t3 = temporary   // move construction
  t1 = t2            // copy assignment
  t3 = temporary     // move assignment

All instances return their resources when they go out of
scope by implicitly calling their destructor.
Primitive types can all be copied.

Most library and user-defined types can be copied, moved,
and deleted by providing member constructors and destructor.
Often compiler generation works well, but for classes with
pointer members developers must provide those methods.

Processing:
All types are static, operations run as native code, and no
garbage collection is needed. Resources are returned at end
of their declaration scope.
*/

void demo_stdlib() { /*-- code elided --*/ }
void demo_Point4D() { /*-- code elided --*/ }
void demo_heap_string() { /*-- code elided --*/ }
void demo_heap_vector() { /*-- code elided --*/ }
void demo_heap_Point4D() { /*-- code elided --*/ }

int main() {

print(&quot;Demonstrate C++ Objects&#92;n&quot;);

demo_stdlib();
demo_Point4D();
demo_heap_string();
demo_heap_vector();
demo_heap_Point4D();

print(&quot;&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
</code></pre>
            </div>
          </first-item>
          <splitter-bar id="structure-seperator"></splitter-bar>
          <second-item id="structure-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('structure-first')">
            <div class="textwrap noflow commentary">
              <h3>Structure:</h3>
              <br /><br /><br />
              <h4><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> Code in the left panel</h4>
              begins with a series of #include statements that import<br /> declarations for the standard library and also for two header<br />
              only libraries defined in other files in this Bit.<br />
              <br />
              The #include declaratons, shown on in the left panel, are being<br />
              superceded by module imports, as of C++20.<br />
              <br />
              For example, all of the standard library includes like
              <div style="padding:0.25em 1em;">
                <c-s>#include &lt;iostream&gt;;</c-s>
              </div>
              are being replaced with a single:
              <div style="padding:0.25em 1em;">
                <c-s>import std;</c-s>
              </div>
              Individual libraries can be imported with declarations like:<br />
              <div style="padding:0.25em 1em;">
                <c-s>import &lt;iostream&gt;;</c-s>
              </div>
              These modern declarations are not used in this demonstration<br />
              because the build tool I use, CMake, does not support importing<br />
              std::libraries.<br />
              <br />
              Modules do work with code compiled in the Visual Studio IDE.
              <br /><br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br /><br /><br /><br /><br /><br /><br />
              <br /><br /><br />
              <h4><span style="font-size:1.25em; font-weight:bold;">&lArr;</span> Execution Flow:</h4>

              Processing begins on entry to the main function which, in turn<br />
              invokes several functions, devoted to demonstrating standard<br />
              library types and a custom type.<br />
              <br />
              They show, separately, placement of objects in stack memory<br />
              then placement in the native heap.

            </div>
          </second-item>
        </splitter-container>
      </div>


      <div style="height:1em;"></div>
      <h3 id="build">2.0 Build</h3>
      <div class="clear"></div>
      <details>
        <summary class="darkItem">Build&nbsp;&nbsp;</summary>
        <div class="blockSingle">
          <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt; cmake ..
-- Building for: Visual Studio 17 2022
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.
-- The C compiler identification is MSVC 19.34.31942.0
-- The CXX compiler identification is MSVC 19.34.31942.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Objects/build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt; cmake --build .
MSBuild version 17.4.1+9a89d02ff for .NET Framework
Checking Build System
Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Obje
cts/CMakeLists.txt
Bits_Objects.cpp
Cpp_Objects.vcxproj -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Ob
jects&#92;build&#92;Debug&#92;Cpp_Objects.exe
Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Obje
cts/CMakeLists.txt
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt;
</pre>
        </div>
      </details>
    </div>
    <h3 id="ide">3.0 Visual Studio Code View</h3>
    <t-b>
      The code for this demo is available in
      <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
      the Code dropdown you can clone the repository of all code for these demos to your local drive.
      Then, it is easy to bring up any example, in any of the languages, in VS Code.
    </t-b>
    <t-b>
      Here, we do that for Cpp\Cpp_Objects.
    </t-b>
    <photosizer-block src="pictures/VS_Code_Cpp_Objects.JPG" width="800" class="photoSizerBlock left"
                      style="overflow-x:auto;">
      <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE</span>
    </photosizer-block>
    <photosizer-block src="pictures/LaunchJSON_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
                      style="overflow-x:auto;">
      <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
    </photosizer-block>
    <photosizer-block src="pictures/VS_Code_Debugging_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
                      style="overflow-x:auto;">
      <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Objects</span>
    </photosizer-block>
    <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
<span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
</photosizer-block>-->

    <div style="height:0.75em;" class="clear"></div>
    <h3 id="refs">4.0 References</h3>
    <table class="indent">
      <tr>
        <th class="darkItem">Reference</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td>
          <a target="_blank" href="../../CppStoryRepo.html">C++ Story</a>
        </td>
        <td>
          E-book with thirteen chapters covering most of intermediate C++
        </td>
      </tr>
      <tr>
        <td>
          <a target="_blank" href="../CppBites/CppBites_Intro.html">C++ Bites</a>
        </td>
        <td>
          Relatively short feature discussions
        </td>
      </tr>
      <tr>
        <td>
          <a target="_blank " href="../../StrCode.Html">STRCode</a>
        </td>
        <td>
          User-defined string type with all standard methods and functions
          documented with: purpose, declaration, definition, invocation, and notes.
        </td>
      </tr>
      <tr>
        <td>
          <a target="_blank" href="https://www.w3schools.com/cpp/default.asp">w3schools&nbsp;tutorial</a>
        </td>
        <td>
          Slow and easy walk throught basics.
        </td>
      </tr>
      <tr>
        <td>
          <a target="_blank" href="https://en.cppreference.com/w/">cppreference.com</a>
        </td>
        <td>
          Very complete reference with lots of details and examples.
        </td>
      </tr>
    </table>
    <div style="height:10em;"></div>
<div style="height:15em;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#syn">synopsis</a>
        <a href="#aggrtypes">aggr types</a>
        <a href="#notes">notes</a>
        <a href="#code">source code</a>
        <a href="#libtyp">std::lib types</a>
        <menu-elem class="secElem"><a href="#points">points</a></menu-elem>
        <a href="#usrdef">Point4D demo</a>
        <a href="#heap">heap storage</a>
        <a href="#heapstr">heap string</a>
        <a href="#heapvec">heap vector</a>
        <a href="#heappt">heap point</a>
        <menu-elem class="secElem"><a href="#analysis">analysis</a></menu-elem>
        <menu-elem class="secElem"><a href="#structure">structure</a></menu-elem>
        <a href="#build">build</a>
        <a href="#ide">VS Code</a>
        <a href="#refs">references</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
  </div>
  <a id="bottom"></a>
  <script src="js/CppBitesPages.js"></script>
  <script>buildPages()</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 3, 10);
  </script>
  <script>
    onLoadSplitter("fig2");
    onLoadSplitter("fig3");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
    onLoadSplitter("fig6");
    onLoadSplitter("point");
    onLoadSplitter("anal");
    onLoadSplitter("structure");
  </script>
</body>
</html>
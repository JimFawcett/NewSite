<!DOCTYPE html>
<html id="top">
<!--
  RepoCpp_CppProperties.html
-->
<head>
  <title>C++ File Manager</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/ContentMenus.css" />
  <link rel="stylesheet" href="../css/StylesPhoto.css" />
  <link rel="stylesheet" href="../css/StylesSizerComp.css" />
  <link rel="stylesheet" href="../css/StylesWebComponents.css" />
  <!-- <link rel="stylesheet" href="../css/help.css" /> -->
  <link rel="stylesheet" href="../css/Content.css" />
  <link rel="stylesheet" href="../css/ThemeCpp.css" />
  <script src="../js/ScriptsWebComponents.js"></script>
  <script src="../js/Content.js"></script>
  <script src="../js/ContentMenus.js"></script>
  <script src="../js/SitePagesForTools.js"></script>
  <link rel="stylesheet" href="../css/FigureSizer.css" />
  <script src="../js/FigureSizer.js"></script>
  <link rel="stylesheet" href="../css/link-nav.css" />
  <link rel="stylesheet" href="../css/content-links.css" />
  <script src="../js/cookies.js"></script>
  <script src="../js/contentElements.js"></script>
  <script src="../js/contentMessages.js"></script>
  <script>
    function loadInExplorer() {
      const loc = window.location;
      if(loc === window.top.location) {
        window.location = "ExploreReposRust.html?src=" + loc;
      }
    }
    function load() {
      loadInExplorer();
      buildBottomMenu();
      postFileName();
      setPersistantElements();
    }
  </script>
</head>
<body id="github" onload="load()">

  <!-- <a id="next" class="hidden" href="../Cpp/CppHome.html"></a>
  <a id="prev" class="hidden" href="../Site/SiteHome.html"></a> -->

  <!-- show-hide with 'about' message -->
  <div id="about" class="hidden" onclick="this.classList.toggle('hidden')">
    RepoCpp_CppProperties.html<br />
    copyright &copy; James Fawcett<br />
    Revised: 11/18/2025
  </div>

  <content-block>
    <!-- <a id="top"></a> -->
    <header>
      <!--<a class="repoLink" href="https://github.com/JimFawcett">JimFawcett Repositories</a>-->
      <div id="pagetitle">
        <h2 id="title">C++ Properties</h2>
        <h4 id="subtitle" class="indent">
          data properties add-in
        </h4>
      </div>
      <div class="header" style="position:relative; padding:0.0em 0em 0.25em 0em; margin-top:0.05em; border:2px solid var(--dark);">
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-top:0.25em; margin-left:1.5em;">About</a>
        <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett/CppProperties" style="margin-left:1.25em; color:var(--light); ">CppProperties Repo</a>
      </div>

    </header>
    <!-- <div class="note" style="border:2px dashed red;">
      Default settings are not working correctly.  Will fix as time permits.
    </div> -->
        <t-b>
          <h3 id="concept">1.0 Concept</h3>
          <indent-blocks>
            <t-b>
              Properties are a programming language construct that provide encapsulated instances of the property type
              with encapsulated setter and getter methods to access that value. C++ does not provide properties, but this code shows
              that can be done with templates and some specialization magic.
            </t-b>
            <t-b>There are some important reasons for using properties:</t-b>
            <ul>
              <li>
                Provide thread-safe operations for the encapsulated instances.  Property access methods may take
                and release locks as needed, so users of the class don&apos;t have to do that.
              </li>
              <li>
                Provide logging of access to the encapsulated instances.  Again, access methods provide
                whatever logging is needed.
              </li>
              <li>
                Enforce application specific constraints on operations that may be executed on the
                encapsulated instances, e.g., authorization, styling, security checks, ...
              </li>
            </ul>
            <t-b>
              If the Property class provides virtual functions for access, derived classes may simply provide whatever
              their application needs.
            </t-b>
          </indent-blocks>
        </t-b>
          <div class="right">
            <div style="float:right; padding:2rem 0rem 0.5rem 1rem;">
              <photosizer-block src="pictures/PropertyClasses.jpg" width="500" class="photoSizerBlock" style="margin-top:0;">
                <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS', Tahoma;
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;
          ">
                  Fig 1. CppProperties Class Diagram
                </span>
              </photosizer-block>
            </div>
          </div>
          <div class="right clear">
            <div style="clear:both; float:right; padding:0rem 0rem 0.5rem 1rem;">
              <photosizer-block src="pictures/PropertyApplicationCode.JPG" width="500" class="photoSizerBlock" style="margin-top:0;">
                <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS', Tahoma;
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;
          ">
                  Fig 2. Properties Test Code
                </span>
              </photosizer-block>
            </div>
          </div>
          <div class="right clear">
            <div style="clear:both; float:right; padding:0rem 0rem 0.5rem 1rem;">
              <photosizer-block src="pictures/PropertyOut.JPG" width="500" class="photoSizerBlock" style="margin-top:0;">
                <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS', Tahoma;
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;
          ">
                  Fig 3. CppProperties Test Output
                </span>
              </photosizer-block>
            </div>
          </div>
        <t-b>
          <h3 id="design">2.0 Design</h3>
          <div id="fig1"></div>
          <indent-blocks>
            <t-b>
              This project is essentially an &quot;is it possible?&quot; exploration of extending the C++ language 
              in interesting ways. The results are more complex than I expected, and so I have not used them 
              for any of my implementation projects.
            </t-b>
            <t-b>
              This design of properties uses an inheritance hierarchy, shown in Figure 1., to implement the various
              design aspects needed for property behaviors, as described in the concept statement, above.
            </t-b>
            <t-b>
              The first base class, <code-span>PropContainer&lt;T&gt;</code-span>, holds the encapsulated instance t &epsilon; T and provides
              protected virtual methods:
            </t-b><br />
            <ul class="tight pad10">
              <li>
                <span class="code">virtual void set(const T&amp; t)</span>
              </li>
              <li>
                <span class="code">virtual T&amp; get()</span>
              </li>
            </ul>
            <t-b>
              The purpose of these methods is to manage access to the encapsulated type.
              The <code-span>PropertyBase&lt;T&gt;</code-span>
              class inherits those protected methods and uses them to implement the user interface methods:
            </t-b>
            <ul class="tight pad10">
              <li>
                <span class="code">
                  PropertyBase(const T& t)
                </span>
              </li>
              <li>
                <span class="code">PropertyBase<T>& operator=(const T& t)</span>
              </li>
              <li>
                <span class="code">void operator()(const T& t)</span>
              </li>
              <li>
                <span class="code">T operator()()</span>
              </li>
            </ul><br />
            <t-b>
              The first three of these methods call
              <span class="code">void PropContainer&lt;T&gt;::set(const T&amp; t)</span>
              and the last calls
              <span class="code">T&amp; PropContainer&lt;T&gt;::get()</span>.
              Note that the <span class="code">set(const T&amp; t)</span> method copy assigns t to the
              encapsulated instance, e.g., makes a <strong>copy</strong> so users can&apos;t modify the
              inner instance through that reference.  Also note that the <span class="code">operator()()</span>
              method returns a copy of the inner instance, for the same reason.  For large types, those
              copies will have preformance implications, but are necessary to ensure application defined
              constraints on operations are enforced and any changes, for thread-safe properties, happen
              only in a locked critical section.
            </t-b>
            <t-b>
              Since <code-span>Property&lt;T&gt;</code-span> is not a T, it doesn&apos;t have T&apos;s methods.
              If <code-span>Property&lt;T&gt;</code-span>
              derived from T, that would provide those methods, but then it would be very difficult
              (maybe impossible) to enforce application constraints and provide consistent logging and
              thread safety. So, I elected to take the design route described below.
            </t-b>
            <div id="fig2"></div>
            <t-b>The class <code-span>PropertyOps&lt;T&gt;</code-span> provides methods for frequently occurring types:</t-b>
            <ul class="tight pad10">
              <li>fundamental type operations</li>
              <li>operations for STL sequential containers</li>
              <li>operations for STL associative containers</li>
            </ul>
            <t-b>
              Each of these types require different interfaces, so the <code-span>PropertyOps&lt;T&gt;</code-span> class provides
              specializations for each of these, based on custom type traits: <code-span>is_fundamental</code-span>,
              <code-span>is_stl_seq_container</code-span>, and <code-span>is_stl_assoc_container</code-span>.  The selection of those specializations uses some
              template metaprogramming constructs provided by C++14 and C++17. The Property.h and CustomContTypeTraits.h
              files provide some notes about that.
            </t-b>
            <t-b>
              Whenever it can, <code-span>PropertyOps&lt;T&gt;</code-span> uses the protected
              <code-span>PropContainer&lt;T&gt;</code-span> reference-based methods for performance,
              only using instance copy operations when it must to maintain thread-safety or application constraints.
            </t-b>
            <t-b>
              For types not included in <span class="code">PropertyBase&lt;T&gt;</span>, e.g.,
              <span class="code">Widget</span>, applications can retreive
              a copy of the encapsulated type using <span class="code">T PropertyBase&lt;T&gt;::operator()()</span>,
              use the copy&apos;s methods, and set the modified instance with
              <span class="code">void PropertyBase&lt;T&gt;::operator()(const T&amp; t)</span> method.
              That, obviously has performance and convenience issues, but would probably be worthwhile for
              multi-threaded environments or applications needing specific logging operations.
            </t-b>
            <t-b>
              For frequently used types, a developer may always elect to add another <span class="code">PropertyOps</span>
              specialization.  That will probably be easier than for STL containers, since those class interfaces
              are likely to be smaller, simpler, and easier to implement.
            </t-b>
            <div id="fig3"></div>
            <t-b>Three classes derive from <code-span>PropertyOps&lt;T&gt;</code-span>:</t-b>
            <ul>
              <li>
                <span class="code">Property&lt;T&gt;</span> imposes no constraints and does no locking.
              </li>
              <li>
                <span class="code">TS_Property&lt;T&gt;</span> provides locking, by overriding empty public
                <span class="code">lock()</span> and <span class="code">unlock()</span> methods,
                inserting calls to methods <code-span>lock()</code-span> and <code-span>unlock()</code-span>
                in the <span class="code">PropContainer&lt;T&gt;</span> class.
              </li>
              <li>
                <span class="code">Log_Properties&lt;T&gt;</span> provides logging by overriding protected
                methods <span class="code">void set(const T&amp; t)</span> and
                <span class="code">T&amp; get()</span> methods.
              </li>
            </ul>
            <t-b>
              The <code-span>Property&lt;T&gt;</code-span> and <span class="code">TS_Property&lt;T&gt;</span> classes
              have been implemented and are part of this repository.  <code-span>Log_Property&lt;T&gt;</code-span>
              is planned and should appear soon.
              <spacer-15></spacer-15>
              A final observation about this design: note how property operations are factored into
              single-responsibility classes, e.g.:
            </t-b>
            <ul>
              <li>
                <code-span>PropContainer</code-span> provides virtual functions to manage its encapsulated
                instance t&epsilon;T, providing the flexibility needed by applications to enforce constraints
                and thread safety.
              </li>
              <li>
                <code-span>PropBase&lt;T&gt;</code-span> defines the primary user interface.
              </li>
              <li>
                <code-span>PropertyOps&lt;T&gt;</code-span> adds methods for widely used types.
              </li>
              <li>
                The most derived classes
                <code-span>Property&lt;T&gt;</code-span>,
                <code-span>TS_Property&lt;T&gt;</code-span>, and
                <code-span>Log_Property&lt;T&gt;</code-span> simply override
                <code-span>PropContainer&lt;T&gt;</code-span> methods to suit the current application.
              </li>
            </ul>
            <t-b>
              <code-span>PropContainer&lt;T&gt;</code-span> sets up the flexibility infrastructure, and
              <code-span>Property&lt;T&gt;</code-span>,
              <code-span>TS_Property&lt;T&gt;</code-span>, and
              <code-span>Log_Property&lt;T&gt;</code-span> use that for their application.
              The Single-Responsibility Principle is the queen - most important - of all the design principles.
            </t-b>
          </indent-blocks>
          <h3 id="build">3.0 Build</h3>
          <t-b>
            CppProperties was built with Visual Studio Community Edition - 2019 and tested on Windows&nbsp;10.
            <spacer-25></spacer-25>
          </t-b>
          <h3 id="status">4.0 Status</h3>
          <t-b>
            All of the classes except
            <code-Span>Log-Property&lt;T&gt;</code-Span> have been implemented.  The code has not been used
            in any major application yet, so there may be some latent undetected errors.
            <div style="height:0.75em;"></div>
            Two of the STL containers, <code-span>std::stack&lt;T&gt;</code-span> and <code-span>std::queue&lt;T&gt;</code-span>
            are adapters of other containers.  They have a special behavior - provide access only to their end or ends.
            That is, they cannot be iterated and have no <code-span>begin()</code-span> and <code-span>end()</code-span>
            methods.  They need their own <code-span>PropertyOps&lt;T&gt;</code-span> processing.  I have not done that
            yet, so using them will cause compilation failure.  Since you can use the <code-span>std::deque&lt;T&gt;</code-span>
            as a stack or queue, I will not do that for awhile.
          </t-b>
          <t-b>
            This facility needs a better demonstration of typical use. I plan to provide that, but I won&apos;t get
            to that for a while.
          </t-b>
          <t-b>
            All of this is fairly complex.  I probably would not use this facility except for the use-cases cited in
            the <a href="#concept">Concept</a> section.
          </t-b>
        </t-b>
        <div style="height:15rem;"></div>
  </content-block>
  <div id="bottomMenu">
    <div id="keys" class="hidden"></div>
    <div id="sections" class="hidden">
      <div class="darkItem listheader" onclick="toggleSections()">Sections</div>
      <div class="menuBody">
        <a href="#top">top</a>
        <a href="#bottom">bottom</a>
      </div>
    </div>
    <div id="pages" class="hidden"></div>
    <div id="url" class="hidden">url</div>
    <div id="goto" class="hidden">url</div>
  </div>
  <a id="bottom"></a>
  <script src="js/CppRepoPages.js"></script>
  <script>buildPages()</script>
  <script>createSiteNavMenu('goto')</script>
  <script src="../js/link-nav.js" defer></script>
  <script>
    setCookie('#pages', 13, 10);
  </script>
</body>
</html>